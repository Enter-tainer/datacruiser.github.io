<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Datacruiser&#39;s Blog</title>
  
  <subtitle>数海拾荒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://datacruiser.io/"/>
  <updated>2020-01-31T14:37:28.384Z</updated>
  <id>http://datacruiser.io/</id>
  
  <author>
    <name>Datacruiser</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>椭圆曲线密码学简介（二）：有限域的椭圆曲线及离散对数问题</title>
    <link href="http://datacruiser.io/2020/01/15/Elliptic-Curve-Cryptography-finite-fields-and-discrete-logarithms/"/>
    <id>http://datacruiser.io/2020/01/15/Elliptic-Curve-Cryptography-finite-fields-and-discrete-logarithms/</id>
    <published>2020-01-15T10:57:07.000Z</published>
    <updated>2020-01-31T14:37:28.384Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要翻译自<a href="https://andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/" target="_blank" rel="noopener">这篇文章</a></p><h1 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h1><blockquote><p>本文承接上文所讨论的椭圆曲线，并将曲线的定义域从实数域缩小到了有限域，引出离散对数问题</p><p>首先介绍了有限域的定义，并给出了一种基于模运算的有限域$\mathbb{F}_p$</p><p>然后对离散域上的椭圆曲线重新进行群的构建</p><p>接着介绍了群的阶数的概念，介绍了计算椭圆曲线上的群的阶数的算法，并讨论群和子群的阶数的联系</p><p>随后展示了如何用椭圆曲线上的任意一点，通过计算点的倍数的方法，构造一个循环子群</p><p>最后介绍了一种算法，可以在椭圆曲线上找到一个基点，并通过该基点生成一个阶数为大质数的循环子群</p></blockquote><p>在<a href="http://datacruiser.io/2020/01/07/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AE%80%E4%BB%8B/">上一篇文章</a>当中，我们已经了解了在实数域的椭圆曲线可以用来定一个群。特别的，根据群的定义，我们在实数域上面的椭圆曲线定义了一个点加法的二元操作：对于曲线上面对齐的三个点，三点累加之和为0。并对加法运算的几何方法和代数方法进行了推导。</p><p>然后在加法的基础上面介绍了标量乘法，并找到了一种计算标量乘法的简单算法：翻倍和累加，可以使得算法时间复杂度到$O(\log n)$。</p><p>接下来，我们将椭圆曲线限定在有限域内，然后看看会有什么变化。</p><h1 id="模-P-的整数域（The-field-of-integers-modulo-p）"><a href="#模-P-的整数域（The-field-of-integers-modulo-p）" class="headerlink" title="模$P$的整数域（The field of integers modulo p）"></a>模$P$的整数域（The field of integers modulo p）</h1><p>有限域，顾名思义，就是一个包含有限个元素的集合。一个有限域的具体例子就是模$p$的整数域，其中$p$是一个素数。通常它可表示为$\mathbb{Z}/p,GF(p),\mathbb{F}_p$等，为了简洁，本文采用最后一种符号$\mathbb{F}_p$。</p><p>在有限域中，我们有两种二元操作：加法$(+)$和乘法$(\times)$。两者都满足封闭性、结合律和交换律。对这两个操作，存在独一无二的单位元，且对每一个元素都有一个唯一的逆元。</p><p>最后，乘法相对加法满足分配率：$x\times (y+z)=x\times y+x\times z$</p><p>模$p$的整数域是包含所有从0到$p-1$的整数，即集合$\mathbb{F}_p$是定义在整数集$\{0,1,2,…,p-1\}$上。在$\mathbb{F}_p$上面的加法和乘法以<a href="http://en.wikipedia.org/wiki/Modular_arithmetic" target="_blank" rel="noopener">模运算（modular arithmetic）</a>的方式进行工作。下面是一些在$\mathbb{F}_{23}$上面的操作实例：</p><ul><li>加法：$(18+9) \mod 23=4$</li><li>减法：$(7-14) \mod 23 =16$</li><li>乘法：$4\times 7 \mod 23=5$</li><li>加法逆元：$-5 \mod 23=18$<br>实际上：作为加法群时，其单位元为0，根据$(5+(-5)) \mod 23 = (5+18)\mod 23=0$，有$-5 \mod 23=18$</li><li>乘法逆元：$9^{-1}\mod 23=18$<br>实际上：作为乘法群时，其单位元为1，根据$9\times 9^{-1} \mod 23 = 9\times 18\mod = 1$，有$9^{-1}\mod 23=18$</li></ul><p>如果对这些等式看起来有点模式，可以进一步阅读关于模运算的资料，比如wiki百科，或者<a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic" target="_blank" rel="noopener">Khan Academy</a>。</p><p>正如我们之前所说，整数对$p$取模后所组成的有限域将具备以上所有性质。不过需要注意的是，$p$必须是一个质数！否则将无法成为一个域。比如模4整数集就不是一个域：因为2没有乘法逆元，即方程$2\times x \mod 4 = 1$无解。</p><h1 id="模-p-除法（Division-modulo-p）"><a href="#模-p-除法（Division-modulo-p）" class="headerlink" title="模$p$除法（Division modulo p）"></a>模$p$除法（Division modulo p）</h1><p>在完成对$\mathbb{F}_p$域上面对椭圆曲线进行定义之前，我们先来搞搞清楚$\mathbb{F}_p$域上面$x/y$意味着什么。本质上，我们可以认为：$x/y=x\times y^{-1}$，用语言来表示就是$x$ 除以$y$等价于$x$乘以$y$的乘法逆元。这个结果并不意外，且给出了求解除法的基本方法：找到元素的乘法逆元然后再做一个乘法。</p><p>利用<a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm" target="_blank" rel="noopener">扩展欧几里德算法（Extended Euclidean algorithm）</a>可以“方便”地计算乘法逆元，即便在最坏的情况下，算法的时间复杂度也仅为$O(\log p)$，如果考虑$p$的二进制比特长度为$k$的话，则为$O(k)$。</p><p>扩展欧几里德算法的具体细节不在本文的议题范围之内，不过下面是一个python脚本的具体实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended_euclidean_algorithm</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns a three-tuple (gcd, x, y) such that</span></span><br><span class="line"><span class="string">    a * x + b * y == gcd, where gcd is the greatest</span></span><br><span class="line"><span class="string">    common divisor of a and b.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function implements the extended Euclidean</span></span><br><span class="line"><span class="string">    algorithm and runs in O(log b) in the worst case.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s, old_s = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    t, old_t = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    r, old_r = b, a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> r != <span class="number">0</span>:</span><br><span class="line">        quotient = old_r // r</span><br><span class="line">        old_r, r = r, old_r - quotient * r</span><br><span class="line">        old_s, s = s, old_s - quotient * s</span><br><span class="line">        old_t, t = t, old_t - quotient * t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old_r, old_s, old_t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_of</span><span class="params">(n, p)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the multiplicative inverse of</span></span><br><span class="line"><span class="string">    n modulo p.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function returns an integer m such that</span></span><br><span class="line"><span class="string">    (n * m) % p == 1.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    gcd, x, y = extended_euclidean_algorithm(n, p)</span><br><span class="line">    <span class="keyword">assert</span> (n * x + p * y) % p == gcd</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gcd != <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Either n is 0, or p is not a prime number.</span></span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">'&#123;&#125; has no multiplicative inverse '</span></span><br><span class="line">            <span class="string">'modulo &#123;&#125;'</span>.format(n, p))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x % p</span><br></pre></td></tr></table></figure></p><h1 id="mathbb-F-p-域上的椭圆曲线（Elliptic-curves-in-mathbb-F-p-）"><a href="#mathbb-F-p-域上的椭圆曲线（Elliptic-curves-in-mathbb-F-p-）" class="headerlink" title="$\mathbb{F}_p$域上的椭圆曲线（Elliptic curves in $\mathbb{F}_p$）"></a>$\mathbb{F}_p$域上的椭圆曲线（Elliptic curves in $\mathbb{F}_p$）</h1><p>现在，我们有足够的必要条件对$\mathbb{F}_p$域上的椭圆曲线进行定义，前面实数域上的定义如下：<br>$$E=\{(x,y) \in \mathbb{R}^2 | y^2=x^3+ax+b,4a^3+27b^2\neq0\}\cup\{0\}$$<br>$\mathbb{F}_p$有限域上的定义如下：<br>$$E=\{(x,y) \in (\mathbb{F}_p)^2 | y^2=x^3+ax+b \pmod{p},4a^3+27b^2\not\equiv0\pmod{p}\}\cup\{0\}$$</p><p>其中0依然是位于无限远的点，$a$和 $b$是 $\mathbb{F}_p$域上的两个整数。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECCReview/elliptic-curves-mod-p.png" alt="曲线$y^2\equiv x^3-7x+10 \pmod{p}$在 $p=19,97,127,487$时的图形，需要注意的是对于每一个$x$，最多有两个点，且所有的点关于$y=p/2$轴对称"></p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECCReview/singular-mod-p.png" alt="曲线$y^2\equiv x^3 \pmod{p}$，在$(0,0)$存在奇异点，不是一条有效的椭圆曲线"></p><p>从几何的角度，图形则从连续的曲线变成$xy$平面上面的不相连的离散点的集合。好在，我们可以依然证明，即便我们对于定义域进行诸多限制，$\mathbb{F}_p$域上的椭圆曲线依然可以组成一个阿贝尔群。</p><h1 id="点加法（Point-addition）"><a href="#点加法（Point-addition）" class="headerlink" title="点加法（Point addition）"></a>点加法（Point addition）</h1><p>显然，为了使得点加法在$\mathbb{F}_p$域上依然有效，我们需要对定义作一些小小的修改。对于实数，我们定义三个共线的点之和为0。这个定义可以保留，但是我们需要搞明白在$\mathbb{F}_p$域中三点共线意味着什么。</p><p>在实数域，显然，三点共线意味着能够找到一条直线将三个点连在一起就好。当然，在$\mathbb{F}_p$域中，直线与实数域$\mathbb{R}$中的是有所不同的。不太严谨地说，$\mathbb{F}_p$中的直线是满足方程$ax+by+c\equiv 0\pmod{p}$的点$(x,y)$的集合。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECCReview/point-addition-mod-p.png" alt="在曲线$y^2\equiv x^3-x+3\pmod{127}$上的两个点$P=(16,20)$和 $Q=(41,120)$的点加法。注意，直线$y\equiv4x+83 \pmod{127}$是通过平面上面的一组重复的平行线来将这些点连接起来的"></p><p>假设我们在一个群当中，点加法将保留所有我们已知的特性：</p><ul><li>$Q+0=0+Q=Q$</li><li>对于一个非0的点$Q$，逆元$-Q$是横坐标相同但是纵坐标相反的点。或者如果你愿意，可以这样计算，$-Q=(x_Q,-y_Q \mod p)$，举个例子，在$\mathbb{F}_29$域上的曲线有一个点$Q=(2,5)$，则其逆元$-Q=(2,-5 \mod 29)=(2,24)$</li><li>根据逆元的定义有$P+(-P)=0$</li></ul><h1 id="代数加法（Algebraic-sum）"><a href="#代数加法（Algebraic-sum）" class="headerlink" title="代数加法（Algebraic sum）"></a>代数加法（Algebraic sum）</h1><p>除了在每一个表达式后面加上一个$\mod p$的操作以外其它与前一篇文章当中所描述的步骤都相同。因此，令$P=(x_P,y_p),Q=(x_Q,y_Q),R=(x_R,y_R)$，我们可以按如下方程计算$P+Q=-R$：</p><p>$$<br>\begin{align}<br>x_R&amp;=(m^2-x_P-x_Q)\mod\, p\\<br>y_R&amp;=[y_P+m(x_R-x_P)]\mod\, p\\<br>&amp;=[y_Q+m(x_R-x_Q)]\mod\, p<br>\end{align}<br>$$</p><p>如果$P\neqQ$，斜率$m$的形式如下：<br>$$m=(y_P-y_Q){(x_P-x_Q)}^{-1}\mod\,p$$</p><p>如果$P=Q$，则有：<br>$$m=(3x^2_P+a)(2y_P)^{-1}\mod\,p$$</p><p>方程形式的一致并不是巧合：实际上在任何一个域，方程的形式都是相同的，有限的或者无限的，仅在$\mathbb{F}_2$和 $\mathbb{F}_3$两个特定域上不成立。关于数学上的证明有兴趣的话可以参阅<a href="http://math.rice.edu/~friedl/papers/AAELLIPTIC.PDF" target="_blank" rel="noopener">proof from Stefan Friedl</a>。</p><p>另外，考虑到离散化后的曲线切线已无从谈起，以及其它方面的一些问题，在离散化域中，我们不再定义几何加法。</p><h1 id="椭圆曲线群的阶（The-order-of-an-elliptic-curve-group）"><a href="#椭圆曲线群的阶（The-order-of-an-elliptic-curve-group）" class="headerlink" title="椭圆曲线群的阶（The order of an elliptic curve group）"></a>椭圆曲线群的阶（The order of an elliptic curve group）</h1><p>显而易见，有限域上定义的椭圆曲线只有有限个点。但是有一个重要的问题不应该忽略：对于一个特定有限域上的椭圆曲线，到底有多少个点呢？</p><p>首先，我们将群中所包含点的数目定义为<strong>群的阶</strong>。</p><p>通常从$x$到 $p-1$进行暴力枚举不是一个可行的方式，这个需要$O(p)$的步骤，如果$p$是一个很大的质数，这将是一个难题。</p><p>所幸，有一个更快的算法可以计算群的阶：<a href="https://en.wikipedia.org/wiki/Schoof%27s_algorithm" target="_blank" rel="noopener">Schoof’s algorithm</a>，这个算法可以在多项式级别的算法世界复杂度内，这正是我们所需要的。</p><h1 id="标量乘法与循环子群（Scalar-multiplication-and-cyclic-subgroups）"><a href="#标量乘法与循环子群（Scalar-multiplication-and-cyclic-subgroups）" class="headerlink" title="标量乘法与循环子群（Scalar multiplication and cyclic subgroups）"></a>标量乘法与循环子群（Scalar multiplication and cyclic subgroups）</h1><p>$$nP=\underbrace{P+P+…+P}_{n\,times}$$ </p><p>这次我们依然可以使用<a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/#double-and-add" target="_blank" rel="noopener">翻倍累加算法</a>将乘法计算的时间复杂度控制在$O(\log n)$。</p><p>在$\mathbb{F}_p$域上的椭圆曲线进行乘法有一个有趣的性质。以曲线$y^2\equivx^3+2x+3(\mod\,97)$和点$P=(3,6)$为例，<a href="https://andrea.corbellini.name/ecc/interactive/modk-mul.html" target="_blank" rel="noopener">计算</a>$P$的所有乘积：<br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECCReview/cyclic-subgroup.png" alt="$P=(3,6)$的乘积仅有5个离散点$(0,P,2P,3P,4P)$，然后他们会循环出现，显然，可以比较容易辨认出椭圆曲线上标量乘法计算规则与模运算上加法之间的相似性"></p><ul><li>$0P=0$</li><li>$1P=(3,6)$</li><li>$2P=(80,10)$</li><li>$3P=(80,87)$</li><li>$4P=(3,91)$</li><li>$5P=0$</li><li>$6P=(3,6)$</li><li>$7P=(80,10)$</li><li>$8P=(80,87)$</li><li>$9P=(3,91)$</li><li>…</li></ul><p>在此，我们可以确认两件事情：第一，$P$的乘积只有五种可能答案：椭圆曲线上面的其它的点决不会出现；第二，这五个点循环出现。我们可以这样写：</p><ul><li>$5kP=0$</li><li>$(5k+1)P=P$</li><li>$(5k+2)P=2P$</li><li>$(5k+3)P=3P$</li><li>$(5k+4)P=4P$</li></ul><p>对于每一个整数$k$，上述5个方程可以借助模运算符压缩成一个方程：$kP=(k\mod\,5)P$</p><p>不仅如此，我们可以立刻确认这五个点在加法操作上面也是封闭的。这意味着：不管我是加$0,P,2P,3P,4P$中的哪一个，结果都是上述五个点之一，其它的点依然不会出现在结果当中。</p><p>不仅仅对于$P=(3,6)$，对于任何点都有这样的结果。如果我们假设一个通用的点$P$：<br>$$nP+mP=\underbrace{P+P+…+P}_{n\,times}+\underbrace{P+P+…+P}_{n\,times}=(n+m)P$$ </p><p>这意味着：如果我们将两个$P$的乘积相加，我们将得到一个$P$的乘积，$P$的乘积在加法操作下是封闭的。</p><p>这足以证明$P$的乘积的集合是一个由椭圆曲线所组成的群的循环子群（cyclic subgroup）。</p><p>一个“子群”是指另外一个群的子集的群。而“循环子群”则是指子群中的元素循环地出现，就好像在前面的例子当中所示。点$P$被称为<em>发生器（generator）</em>或者<em>基点（base point）</em>。</p><p>循环子群是椭圆曲线密码学以及其它加密系统的基础。</p><h1 id="子群的阶（Subgroup-order）"><a href="#子群的阶（Subgroup-order）" class="headerlink" title="子群的阶（Subgroup order）"></a>子群的阶（Subgroup order）</h1><p>我们可以自问一下：由一个点$P$产生的子群的阶（order）是多少，或者也可以称之为$P$的阶。回答这个问题无法使用<code>Schoof&#39;s algorithm</code>，因为该算法只有在整个椭圆曲线上面是有效的，在子群当中就无效了。在解决这个问题之前，我们需要了解以下几点：</p><ul><li>我们已经对群的阶进行过定义：阶是一个群的点数。目前这个定义依然有效，但是在一个循环子群当中，我们可以给一个新的等价的定义：循环子群的阶是使得$nP=0$的最小正整数$n$。我们可以看之前那个例子，我们的子群有5个点，然后我们有$5P=0$</li><li><a href="https://en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory" target="_blank" rel="noopener">Lagrange’s theorem</a>)，$P$的阶与椭圆曲线本身的阶有联系，一个子群的阶是父群阶的一个因子。换句话说，如果一个椭圆曲线有$N$个点，然后它的一个子群有$n$个点，那么$n$是 $N$的一个因子</li></ul><p>以上两个有用的信息合在一起可以帮助我们找到基于特定几点$P$的子群的阶：</p><ul><li>使用<code>Schoof&#39;s algorithm</code>找到椭圆曲线而阶$N$</li><li>找到$N$的所有因子</li><li>对$N$的每一个因子$n$，都计算$nP$</li><li>满足$nP=0$的最小正整数$n$，就是子群的阶</li></ul><p>举个例子，曲线$y^2=x^3-x+3$在域$\mathbb{F}_37$上的阶为$N=42$，则其子群可能的阶为$n=1,2,3,6,7,14,21,42$。如果我们选取基点$P=(2,3)$，我们可以发现$P\neq 0,2P\neq 0,…,7P=0$，因此基点$P$的阶为$n=7$。</p><p>需要特别注意的是，选取最小的因子非常重要，而不是随机选取。如果随机选取，我们还可能选择$n=14$，虽然$n=14$是满足$nP=0$的，但是它并不是子群的阶，而且其中的一个乘数。</p><p>再举一个例子，曲线$y^2=x^3-x+3$在域$\mathbb{F}_29$上的阶为$N=37$，是一个素数，其子群可能的阶仅为$n=1,37$。不难猜到，当$n=1$时，子群只包含一个在无限远的点；当$n=N=37$时，子群包含椭圆曲线上面所有的点。</p><h1 id="寻找一个基点（Finding-a-base-point）"><a href="#寻找一个基点（Finding-a-base-point）" class="headerlink" title="寻找一个基点（Finding a base point）"></a>寻找一个基点（Finding a base point）</h1><p>对于我们的椭圆曲线加密算法，我们需要一个尽量高阶的子群。通常来说，我们选择一条椭圆曲线，计算它的阶（$N$），确定一个比较大的因子作为子群的阶（$n$），然后据此寻找一个合适的基点。下面来看看我们是如何先确定子群的阶再匹配合适的基点，而不是先找基点再计算子群的阶的。</p><p>首先，需要再介绍一个概念。<a href="https://en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory" target="_blank" rel="noopener">Lagrange’s theorem</a>)表明$h=N/n$一定是一个整数。$h$被称为子群的协因子（cofactor）。</p><p>对于椭圆曲线上面的每一个点，我们有$NP=0$，根据协因子的定义，我们有$n(hP)=0$。</p><p>现在假设$n$是一个素数，那么这个方程告诉我们点$G=hP$可以产出一个阶为$n$的子群。</p><p>综上所述，通过确定子群的阶，再据此寻找合适的基点的算法如下：</p><ul><li>计算椭圆曲线的阶$N$</li><li>选择恰当的子群的阶$n$，为了使得这个算法能够正常工作，这个整数必须是素数，并且是$N$的一个因子</li><li>计算协因子$h=N/n$</li><li>再曲线上面选择一个随机点$P$</li><li>计算$G=hP$</li><li>如果$G$是0，则返回第四步，否则，我们就找到了一个阶为$n$且协因子为$h$的子群</li></ul><p>需要指出的是该算法当且仅当$n$是素数的时候才能够正常工作，如果$n$不是一个素数，则$G$的阶会是$n$的一个因子。</p><h1 id="离散对数（Discrete-logarithm）"><a href="#离散对数（Discrete-logarithm）" class="headerlink" title="离散对数（Discrete logarithm）"></a>离散对数（Discrete logarithm）</h1><p>正如我们再之前那篇文章当中对连续的椭圆曲线所做的，对于定义在离散域当中的椭圆曲线，我们接下来讨论一下下面这个问题：如果已知$P$和 $Q$，如果求得满足$Q=kP$的 $k$呢？</p><p>这个问题，就是经典的椭圆曲线<em>离散对数问题</em>，通常来说是“hard”的问题，在经典的计算机上面是无法通过多项式级别的时间复杂度来解决这个问题的，尽管目前还没有严格的数学证明。</p><p>这个问题和其它加密系统当中使用的离散对数问题类似，比如<code>DSA</code>，<code>D-H</code>和<code>ElGamal</code>。这并不是一个巧合。不同的是，在这些算法当中，我们使用幂模运算来代替标量乘法。这些离散对数问题可以表示如下：<br>已知$a$和 $b$，求满足$b=a^k \mod p$</p><p>两个问题都是离散的，因为它只与有限的集合相关，更加精确地说，是循环子群。而当前椭圆曲线加密更为有趣是在于它比起其它类似的加密系统难题更难，可以使用更小的字节来表示整数$k$来获得的安全级别。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm" target="_blank" rel="noopener">扩展欧几里德算法（Extended Euclidean algorithm）</a></li><li><a href="http://en.wikipedia.org/wiki/Modular_arithmetic" target="_blank" rel="noopener">模运算（modular arithmetic）</a></li><li><a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic" target="_blank" rel="noopener">Khan Academy</a></li><li><a href="https://andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/" target="_blank" rel="noopener">Elliptic Curve Cryptography: finite fields and discrete logarithms</a></li><li><a href="https://blog.csdn.net/mrpre/article/details/72850598" target="_blank" rel="noopener">有限域和离散对数问题(ECC椭圆曲线算法2)</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文对在加密货币当中大量使用的椭圆曲线密码学进行介绍，本文在上一篇文章的基础上，进一步对有限域的椭圆曲线以及离散对数问题进行介绍。
    
    </summary>
    
      <category term="密码学" scheme="http://datacruiser.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="加密货币" scheme="http://datacruiser.io/tags/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/"/>
    
      <category term="加密算法" scheme="http://datacruiser.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="椭圆曲线" scheme="http://datacruiser.io/tags/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/"/>
    
      <category term="公钥加密" scheme="http://datacruiser.io/tags/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/"/>
    
      <category term="区块链" scheme="http://datacruiser.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="非对称加密" scheme="http://datacruiser.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>椭圆曲线密码学简介（一）：实数域的椭圆曲线及其群运算规则</title>
    <link href="http://datacruiser.io/2020/01/07/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AE%80%E4%BB%8B/"/>
    <id>http://datacruiser.io/2020/01/07/椭圆曲线密码学简介/</id>
    <published>2020-01-07T11:11:23.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<p>经过前面几篇文章的介绍，相信对公钥密码学有所了解的各位应该已经听说过<code>ECC</code>，<code>ECDH</code>和<code>ECDSA</code>，<code>ECC</code>是椭圆密码学的简称，后面两个是基于椭圆密码学的具体算法。</p><p>目前我们可以在当前web和IT世界当中的三大主要技术<a href="https://tools.ietf.org/html/rfc4492" target="_blank" rel="noopener">TSL</a>，<a href="https://tools.ietf.org/html/rfc6637" target="_blank" rel="noopener">PGP</a>，<a href="https://tools.ietf.org/html/rfc5656" target="_blank" rel="noopener">SSH</a>当中都可以找到椭圆曲线密码系统，更不用说<a href="https://en.bitcoin.it/wiki/Secp256k1" target="_blank" rel="noopener">Bitcoin</a>以及其它加密货币了。</p><p>在ECC开始流行之前，几乎所有的公钥加密算法都是基于<code>RSA</code>，<code>DSA</code>以及<code>DH</code>，底层的加密系统对应的数学难题是模运算。RSA系列算法依然很重要，常常和ECC一同使用。考虑到RSA系列算法背后的原理比较简单，也很容易解释清楚，而ECC却依然蒙着神秘的面纱，本文将提供一个关于ECC的综述，并解释其安全背后的机理，也一并给出一些具体的例子。文章主要包含以下几个方面的内容：</p><ul><li>基于群论在实数域定义的椭圆曲线</li><li>基于有限域的椭圆曲线和离散对数问题</li><li>密钥对的生成和两个ECC算法：<code>ECDH</code>和<code>ECDSA</code></li><li>ECC破解算法，与RSA算法安全性比较</li></ul><p>在开始之前，你需要对集合论、几何学以及模运算有所了解，并且对对称加密和非对称加密比较熟悉，关于秘密学当中对“easy”问题和“hard”问题的定位也要有清晰的认识。</p><h1 id="椭圆曲线（Elliptic-Curves）"><a href="#椭圆曲线（Elliptic-Curves）" class="headerlink" title="椭圆曲线（Elliptic Curves）"></a>椭圆曲线（Elliptic Curves）</h1><p>首先，什么是椭圆曲线，Wolfram MathWorld给出了完整的<a href="http://mathworld.wolfram.com/EllipticCurve.html" target="_blank" rel="noopener">定义</a>。而ECC算法所采用的椭圆曲线是一类可用Weierstrass公式加以描述的椭圆曲线$E$，即：<br>$$E=\{(x,y)|y^2+A_1 y=x^3+A_2 x^2 +A_3x + A_4\}$$</p><p>其中参数$A_1$至 $A_2$的不同取值决定椭圆曲线在坐标系中的形状。实际常用的形式是一类称为Weierstrass Normal Form（WNF）的的简化形式，即：<br>$$E=\{(x,y)|y^2=x^3+ax + b\}$$</p><p>由于ECC算法运算过程中需要使用WMF曲线的切线，因此为了使WNF曲线没有奇异点，即处处光滑可导，需要满足其判别式不为零，即：<br>$$\Delta=4a^3+27b^2\neq 0$$</p><p>同时，定义射影平面上的无穷远点，记为0.无穷远点是所有曲线在无穷远处的交点，也被称为理想点。因此，下面的论述当中所采用的完整的WNF椭圆曲线公式为：<br>$$E=\{(x,y) \in \mathbb{R}^2 | y^2=x^3+ax+b,\Delta=4a^3+27b^2\neq0\}\cup\{0\}$$</p><p>当令$b=1$， $a$从2递减1到-3的椭圆曲线如下所示：<br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECCReview/curves.png" alt=""></p><p>下面我们再来看两条存在奇异点的曲线，如下图所示：<br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECCReview/singularities.png" alt=""></p><p>左边这条曲线的方程为$y^2=x^3$，右边的这条曲线方程为$y^2=x^3-3x+2$，两者都不是合格可用的椭圆曲线。另外，不难发现，所有的椭圆曲线都是关于$x$轴对称的。</p><h1 id="群论（Groups）"><a href="#群论（Groups）" class="headerlink" title="群论（Groups）"></a>群论（Groups）</h1><p>从数学的角度，一个群是由一种集合以及定义在该群上的一个二元运算所组成，且符合“群公理”。具体完整的定义如下：假设$\mathbb{G}$是一个非空集合，$+$是它的一个二元运算，如果满足以下条件，则$\mathbb{G}$和 $+$构成一个群。</p><ul><li>封闭性（closure）：若$a$和 $b$是集合$\mathbb{G}$的成员，则存在唯一确定的$c \in \mathbb{G}$，使得$c=a+b$</li><li>结合律（associativity）：即对$\mathbb{G}$中任意元素$a,b,c$，都有$(a+b)+c=a+(b+c)$</li><li>单位元（identify element）：存在$\mathbb{G}$中的一个元素$e$ ，对任意所有的$\mathbb{G}$中的元素$a$，总有等式$e+a=a+e=a$。则将$e$称为单位元，也称幺元</li><li>逆元（inverse）：对于$\mathbb{G}$任意一个$a$，存在$\mathbb{G}$中的一个元素$b$，使得总有$a+b=b+a=e$（$e$为单位元），则称$a$与 $b$ 互为逆元素，简称逆元。$b$ 记作$a^{-1}$</li></ul><p>群运算的次序很重要，把元素$a$ 与元素$b$结合，所得到的结果不一定与把元素$b$与元素$a$结合相同；亦即，$a+b=b+a$（交换律）不一定恒成立。满足交换律的群称为交换群（阿贝尔群，以尼尔斯·阿贝尔命名），不满足交换律的群称为非交换群（非阿贝尔群）。</p><p>如果我们将加法作为集合的二元运算，那么加上整数集合$\mathbb{Z}$将得到一个群，且是一个阿贝尔群。而自然数集合$\mathbb{N}$因为不满足逆元，则无法与加法构成一个群。</p><p>群的奇妙之处在于如果你能够上述四个性质，那么你可以获得一些其它有趣的性质。</p><p>比如，单位元是独一无二的，逆元也是独一无二的。对于任何一个$a$，有且仅有一个$b$满足$a+b=0$。</p><h1 id="椭圆曲线的群法则（The-group-law-for-elliptic-cirves）"><a href="#椭圆曲线的群法则（The-group-law-for-elliptic-cirves）" class="headerlink" title="椭圆曲线的群法则（The group law for elliptic cirves）"></a>椭圆曲线的群法则（The group law for elliptic cirves）</h1><p>我们可以基于特定的椭圆曲线定义一个群，作如下规定：</p><ul><li>群的元素是椭圆曲线上面的点的集合</li><li>单位元是在无穷远处的点，记为0</li><li>一个元素点$P$的逆元是其关于$x$轴对称的点</li><li>二元远算操作规则定义如下：在曲线上面找到对齐的在一条直线上面的三个非零的点：$P, Q, R$，三者之和为0，即$P+Q+R=0$</li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECCReview/PQR%20Addition.png" alt=""></p><p>对于最后一点，我们的要求仅仅是一条直线上面对齐的三个点，而对齐本身与顺序是无关的，因此，如果$P, Q, R$是对齐的，则有$P+(Q+R)=Q+(P+R)=R+(P+Q)=…=0$，如此这般，我们也顺带证明了我们所定义的二元操作符是能够同时满足结合律和交换律的，我们在椭圆曲线上面定义的群还是一个阿贝尔群。</p><h1 id="几何加法（Geometric-addition）"><a href="#几何加法（Geometric-addition）" class="headerlink" title="几何加法（Geometric addition）"></a>几何加法（Geometric addition）</h1><p>庆幸我们是在一个阿贝尔群当中，我们可以将$P+Q+R=0$写成$P+Q=-R$。这个形式的方程，可以让我们得到一种计算两个点$P$和 $Q$相加之和的几何方法：如果我们画一条直线通过$P$和 $Q$，那么直线会与曲线相交与第三个点$R$。那么该点的逆元$-R$即为$P+Q$的结果。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECCReview/point-addition.png" alt=""></p><p>几何方法一目了然，但是还需要回答一些边界条件：</p><ul><li>$P=0 \, or\, Q=0$：考虑到无穷远点本身并不在这个平面上面，线是画不出来的，但是我们已经定义了0为单位元，对于任意$P$和 $Q$，都有$P+0=P和0+Q=Q$</li><li>$P=-Q$：经过这两个点的直线是一条垂直线，与椭圆曲线不会有第三个交点。但是$P$是 $Q$的逆元，根据逆元的定义有$P+Q=P+(-P)=0$</li><li>$P=Q$：会有无数条线经过这个点，情况会有一些复杂。令$Q’\neq P$，如果我们让$Q’$无限得接近$P$，则经过它们的直线会变成椭圆曲线的切线，此时有$P+P=-R$，其中$R$是切线与椭圆曲线的交点。如下图所示：</li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECCReview/animation-point-doubling.gif" alt=""></p><ul><li>$P \neq Q$，且找不到第三点$R$：这个情况与上面的情况非常类似，此时过$P,Q$的线就是椭圆曲线的切线。假设$P$就是切点，在前面的一个情况当中，$P+P=-Q$，这个方程现在变成$P+Q=-P$。反过来，如果$Q$是这个切点，则有$P+Q=-Q$。如下图所示：</li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECCReview/animation-tangent-line.gif" alt=""></p><p>现在几何加法已经能够覆盖所有的情况了，你只需要尺规就可以在椭圆曲线上面进行各种加法计算了。如果有兴趣也可以看看本文主要参考资料作者提供的<a href="https://andrea.corbellini.name/ecc/interactive/reals-add.html" target="_blank" rel="noopener">图形化工具</a>，这个工具提供了在实数域和离散有限域上面的加法和乘法实现，可以直观的看出这两者的区别，便于对文章的理解。</p><h1 id="代数加法（Algebraic-addition）"><a href="#代数加法（Algebraic-addition）" class="headerlink" title="代数加法（Algebraic addition）"></a>代数加法（Algebraic addition）</h1><p>如果要使用计算机进行具体的加法远算，那么要从几何方法切换到代数方法。将以上所描述的规则转化为方程组是直截了当的办法，但是因为涉及到求解三次方程，会非常麻烦，这里仅仅给出最终结果，具体的求解和推导过程可以查阅相关资料，比如wiki百科等。</p><p>首先，对于简单的边界条件先排除掉，我们已经知道$P+(-P)=0$，以及$P+0=0+P=P$。因此，我们只需要考虑两个非零且不对称的点$P=(x_P,y_P),Q=(x_Q,y_Q)$。</p><p>如果$P$和 $Q$不相等，则通过这两个点的直线的斜率为：<br>$$m=\frac{y_P-y_Q}{x_P-x_Q}$$</p><p>则直线与椭圆曲线的第三个交点$R(x_R,y_R)$的坐标如下：<br>$$<br>\begin{align}<br>x_R&amp;=m^2-x_P-x_Q\\<br>y_R&amp;=y_P+m(x_R-x_P)<br>\end{align}<br>$$</p><p>或者，等价于：<br>$$y_R=y_Q+m(x_R-x_Q)$$</p><p>因此有：$(x_P,y_P)+(x_Q,y_Q)=(x_R,-y_R)$，需要注意$y_R$的负号。</p><p>为了验证结果的正确性，需要验证以下两点：</p><ul><li>$R$是否在这条曲线上面</li><li>$P,Q,R$是否共线</li></ul><p>验证三点是否共线相对简单，而验证一个点是否在椭圆曲线上面则相对复杂一些，需要求解三次方程。这里我们还是借助前面提到的<a href="https://andrea.corbellini.name/ecc/interactive/reals-add.html" target="_blank" rel="noopener">图形化工具</a>，在曲线$y^2=x^3-7x+10$上面取两点$P=(1,2),Q=(3,4)$，得到$P+Q=-R=(-3，2)$，我们由此验证下前面的代数表达式是否正确：<br>$$<br>\begin{align}<br>m&amp;=\frac{y_P-y_Q}{x_P-x_Q}=\frac{2-4}{1-3}=1\\<br>x_R&amp;=m^2-x_P-x_Q=1^2-1-3=-3\\<br>y_R&amp;=y_P+m(x_R-x_P)=2+1 \times(-3-1)=-2\\<br>&amp;=y_Q+m(x_R-x_Q)=4+1 \times(-3-3)=-2<br>\end{align}<br>$$<br>另外，当$P$或者$Q$其中之一是切点的时候，上述方程依然正确，具体读者可以自行验证。</p><p>而当$P=Q$时，情况会稍微复杂一些：因为$x_P=x_Q$，所以关于斜率我们需要采用另外一个不同的方程：<br>$$m=\frac{3x^2_P+a}{2y_P}$$</p><p>不难发现，正如我们期望的那样，上述$m$的表达式就是下式的一阶导数：<br>$$y_P=\pm \sqrt{x^3_P+ax_P+b}$$</p><p>为了证明这一结果的有效性，只需检查$R$在这条椭圆曲线上，以及经过$R$和 $P$的直线与椭圆曲线只有两个交点。当然，具体证明还是交给相关专业的数学教材，这里只举一个具体的例子：$P=Q=(1，2)$。</p><p>$$<br>\begin{align}<br>m&amp;=\frac{3x^2_P+a}{2y_P}=\frac{3\times 1^2-7}{2\times 2}=-1\\<br>x_R&amp;=m^2-x_P-x_Q=(-1)^2-1-1=-1\\<br>y_R&amp;=y_P+m(x_R-x_P)=2+(-1) \times(-1-1)=4<br>\end{align}<br>$$</p><p>这里我们有$P+P=-R=(-1,-4)$，结果正确。</p><h1 id="标量乘法（Scalar-multiplication）"><a href="#标量乘法（Scalar-multiplication）" class="headerlink" title="标量乘法（Scalar multiplication）"></a>标量乘法（Scalar multiplication）</h1><p>除了加法，我们可以定义另外一个操作：标量乘法，具体如下：</p><p>$$nP=\underbrace{P+P+…+P}_{n\,times}$$ </p><p>其中$n$是一个自然数。这里我们依然可以借助前面提到的<a href="https://andrea.corbellini.name/ecc/interactive/reals-add.html" target="_blank" rel="noopener">图形化工具</a>对标量乘法进行演示。</p><p>从上面的形式可以看出，计算标量乘法$nP$需要进行$n$次的加法。如果$n$有 $k$个二进制位的话，那么我们的算法复杂度将是$O(2^k)$，不过，对于乘法的计算有现成的更为优化的多项式级别复杂度的算法。</p><p>其中一个比较著名的是<strong>加倍累加（double and add ）</strong>算法。我们用一个具体的例子来解释其原理。不妨取$n=151$，其二进制表示形式为：${10010111}_2$。而将二进制转化为十进制的过程可以用2的不同次方的累加表示如下：<br>$$<br>\begin{align}<br>151&amp;=1\times 2^7 + 0 \times 2^6 + 0 \times 2^5 + 1 \times 2^4 + 0 \times 2^3 + 1 \times 2^2 + 1\times 2^1 + 1\times 2^0\\<br>&amp;=2^7+2^4+2^2+2^1+2^0<br>\end{align}<br>$$</p><p>从这个角度，我们可以改写上述变量乘法公式：<br>$$151\times P=2^7\times P+2^4\times P+2^2\times P + 2^1\times P+2^0\times P$$</p><p>这样，标量乘法可以表示为多项式乘法类似的算法，具体步骤如下：</p><ul><li>得到$P$</li><li>翻倍$P$，得到$2P$</li><li>将$2P$加到$P$（得到$2^1\times P+2^0\times P$的结果）</li><li>翻倍$2P$，得到$2^2\times P$</li><li>将翻倍的$2^2\times P$加到上一次的结果当中得到$2^2\times P+2^1\times P+2^0\times P$</li><li>翻倍$2^2\times P$，得到$2^3\times P$</li><li>不对$2^3\times P$进行任何操作</li><li>翻倍$2^3\times P$，得到$2^4\times P$</li><li>将翻倍的$2^4\times P$加到上一次的结果当中得到$2^4\times P+2^2\times P+2^1\times P+2^0\times P$</li><li>…</li></ul><p>最后，我们仅需要7次的翻倍计算和4次的加法计算就可以得到$151\times P$的结果。</p><p>如果这个过程不够清晰，这里有一段实现了这个算法的python脚本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bits</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Generates the binary digits of n, starting</span></span><br><span class="line"><span class="string">    from the least significant bit.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    bits(151) -&gt; 1, 1, 1, 0, 1, 0, 0, 1</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">yield</span> n &amp; <span class="number">1</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double_and_add</span><span class="params">(n, x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the result of n * x, computed using</span></span><br><span class="line"><span class="string">    the double and add algorithm.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    addend = x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> bit <span class="keyword">in</span> bits(n):</span><br><span class="line">        <span class="keyword">if</span> bit == <span class="number">1</span>:</span><br><span class="line">            result += addend</span><br><span class="line">        addend *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>这里我们分析下这个算法的时间复杂度。如果翻倍和加法都是$O(1)$的话，那么这个算法就是$O(\log n)$，比起之前的$O(n)$，算法时间复杂度大大简化。</p><h1 id="对数（Logarithm）"><a href="#对数（Logarithm）" class="headerlink" title="对数（Logarithm）"></a>对数（Logarithm）</h1><p>给定$n$和 $P$，我们有一个至少是多项式时间复杂度的算法来计算$Q=nP$。但是，如果反过来呢？比如已知$Q$和 $P$来计算$n$呢？通常将这种问题叫作对数问题（logarithm problem）。之所以用对数来代替除法是为了与其它的加密系统保持一致。</p><p>对于对数问题我们不知道是否有可以称之为“简单”的算法，但是通过<a href="https://andrea.corbellini.name/ecc/interactive/reals-mul.html?a=-3&amp;b=1&amp;px=0&amp;py=1" target="_blank" rel="noopener">一些乘法实验</a>还是很容易看出一些规律的。比如，以椭圆曲线$y^2=x^3-3x+1$和点$P=(0,1)$为例。我们可以立刻确认，如果$n$是奇数，$nP$将会在曲线的左半部分；如果$n$是偶数，$nP$将会在曲线的右半部分。如果我们做更多的实验，我们可以发现更多的规律，最终可以指引我们写出一个基于特定曲线的求解对数问题的特定算法。</p><p>当然，对数问题也有一些衍生：离散对数问题。这个将在下一篇文章当中进行讨论，如果我们减小椭圆曲线的域，变量乘法依然“简单”，但是离散对数却变成一个“难题”，这个双重特性是椭圆曲线密码学的基石。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction" target="_blank" rel="noopener">Elliptic Curve Cryptography: a gentle introduction</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BE%A4" target="_blank" rel="noopener">wiki百科-群</a></li><li><a href="https://item.jd.com/12782144.html" target="_blank" rel="noopener">区块链理论与方法</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF" target="_blank" rel="noopener">wiki百科-椭圆曲线</a></li><li><a href="https://en.wikipedia.org/wiki/Elliptic_curve" target="_blank" rel="noopener">Elliptic_Curve</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文对在加密货币当中大量使用的椭圆曲线密码学进行介绍。
    
    </summary>
    
      <category term="密码学" scheme="http://datacruiser.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="加密货币" scheme="http://datacruiser.io/tags/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/"/>
    
      <category term="加密算法" scheme="http://datacruiser.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="椭圆曲线" scheme="http://datacruiser.io/tags/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/"/>
    
      <category term="公钥加密" scheme="http://datacruiser.io/tags/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/"/>
    
      <category term="区块链" scheme="http://datacruiser.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="非对称加密" scheme="http://datacruiser.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>ECDSA算法如何保护我们的数据</title>
    <link href="http://datacruiser.io/2019/12/12/%E7%90%86%E8%A7%A3ECDSA%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://datacruiser.io/2019/12/12/理解ECDSA算法如何保护我们的数据/</id>
    <published>2019-12-12T18:41:00.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要翻译自这篇文章<a href="https://www.instructables.com/id/Understanding-how-ECDSA-protects-your-data/" target="_blank" rel="noopener">Understanding how ECDSA protects your data</a></p><p>每个人可能都听说过<code>ECDSA</code>算法。当我提到<strong>数字签名</strong>的时候，有些人能够很好地识别出它，有些人却不知道我说的是什么。</p><p>我曾经试图去理解<code>ECDA</code>是如何工作的，但是大部分的在线参考资料都是有缺失的，不足以让我能够很好地理解它。他们要么太基础了──只是解释算法的基础然后留给你“它是如何工作的？”的疑问──要么就是太高阶了，完全略过那些你本该知道但它却假设你已经知道的基础知识。因此，你始终在“它是如何工作的”和“我们如何才能够理解它的工作原理之间”徘徊。如果你没有一个数学或者密码学的学位，但是依然想知道它到底是如何工作的，而不是“魔术发生了，签名被确认了”，那么你运气不够好，因为哪里都没有“新手ECDSA”的教程。</p><p>我决定对<code>ECDSA</code>进行研究，以便更好地了解它是如何保护我的数据以及实际上它有多安全。在做了大量的研究工作并最终弄清楚以后，我打算写一篇文章来解释<code>ECDSA</code>是如何工作的，具体算法是如何实现的，以及一个数字签名是如何进行确认的且在它被确认以后是如何确保它是不可伪造的。说实话，要了解以上所有内容并不容易，但是我将尽我的最大努力进行解释，并且对于读者所应该掌握的知识进行最小的假设，希望所有的人都能够看懂。</p><h1 id="Step-1-What-is-ECDSA？"><a href="#Step-1-What-is-ECDSA？" class="headerlink" title="Step 1: What is ECDSA？"></a>Step 1: What is ECDSA？</h1><p><code>ECDSA</code>是<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" rel="noopener">Elliptic Curve Digital Signature Algorithm</a>的简称，主要用于对数据（比如一个文件）创建数字签名，以便于你在不破坏它的安全性的前提下对它的真实性进行验证。可以将它想象成一个实际的签名，你可以识别部分人的签名，但是你无法在别人不知道的情况下伪造它。而ECDSA签名和真实签名的区别在于，伪造ECDSA签名是根本不可能的。</p><p>你不应该将<code>ECDSA</code>与用来对数据进行加密的<code>AES</code>（高级加密标准）相混淆。<code>ECDSA</code>不会对数据进行加密、或阻止别人看到或访问你的数据，它可以防止的是确保数据没有被篡改。</p><p><code>ECDSA</code>当中有两个词需要注意：<code>Curve</code>（曲线）和<code>Algorithm</code>（算法），这意味着<code>ECDSA</code>基本上是基于数学的。并且，这些涉及非常复杂的数学原理。因此，即便我尽力试着进行简单化处理以让非技术背景的人也能够理解，为了更好地理解你依然需要一些数学方面的背景知识。我将分两部分讲这部分的内容，首先是对它具体的工作原理进行解释，然后深入其内部工作机理助于你的理解。需要注意的是，虽然我已经很好地理解<code>ECDSA</code>，但我不是这方面的专家，不过这篇文档还是由相关专家审议过的。</p><h1 id="Step-2-Understanding-the-Basics"><a href="#Step-2-Understanding-the-Basics" class="headerlink" title="Step 2: Understanding the Basics"></a>Step 2: Understanding the Basics</h1><p>原理非常简单，有一个数学方程，在图上画了一条曲线，然后你在这条曲线上面随机选取了一个点作为你的<code>原点(point of origin)</code>。接着你产生了一个随机数，作为你的<code>私钥(Private key)</code>，最后你用上面的随机数和原点通过一些复杂的魔法数学方程得到该条曲线上面的第二个点，这是你的<code>公钥(Public key)</code>。</p><p>当你想要对一个文件进行签名的时候，你会用这个私钥（随机数）和文件的哈希（一串独一无二的代表该文件的数）组成一个魔法数学方程，这将给出你的签名。签名本身将被分成两部分，称为<code>R</code>和<code>S</code>。为了验证签名的正确性，你只需要公钥（用私钥在曲线上面产生的点）并将公钥和签名的一部分<code>S</code>一起代入另外一个方程，如果这个签名是由私钥正确签名过的数字签名，那么它将给出签名的另外一部分<code>R</code>。简单来说，一个数字签名包含两个数字，<code>R</code>和<code>S</code>，然后你使用一个私钥来产生<code>R</code>和<code>S</code>，如果将公钥和<code>S</code>代入被选定的魔法数学方程给出<code>R</code>的话，这个签名就是有效的。仅仅知道公钥是无法知道私钥或者创建出数字签名。</p><h1 id="Step-3-Why-Use-ECDSA？"><a href="#Step-3-Why-Use-ECDSA？" class="headerlink" title="Step 3: Why Use ECDSA？"></a>Step 3: Why Use ECDSA？</h1><p>现在你可能知道一些基础，但是还不是特别理解，毕竟它还是太复杂了，公钥、私钥这些，都是什么东西呢？不必担心，我很快会进行具体解释。在这之前，我先介绍下为什么我们使用<code>ECDSA</code>以及其具体的应用场景。</p><p>除了显而易见的“我需要对一份文件/合同进行签名”，还有一个非常流行的应用场景：让我们以一个不想自己的数据被用户修改或者破坏的应用程序为例，比如一个只允许你载入官方地图和不可修改的模块的游戏，或者一部只允许你安装官方应用程序的手机或其它设备。</p><p>在这些案例当中，相关文件（应用程序、游戏地图、数据等）会用<code>ECDSA</code>进行签名，公钥会随应用程序/游戏/设备一起捆绑并用来验证签名来确保数据没有被修改，而私钥在本地一个私密的地方进行保存。由于你可以用公钥对签名进行验证，但是不能用它创建或者伪造新的签名，你可以无所顾忌地将公钥随应用程序/游戏/设备一起分发。</p><p>这与<code>AES</code>相比，区别是显而易见的。<code>AES</code>加密系统允许你对数据进行加密，但是你需要用密钥来解密，这就要求你将密钥与应用程序一起捆绑，破坏了对数据进行保护防止数据被用户修改的目的。</p><p>一个很好的例子就是PS3的控制台，它被大量的破解，所有的文件可以解密，所有的密钥可以从解密的文件当中抽取，但是为了能够在最新的固件上面运行程序，你还需要破解一个<code>ECDSA</code>的数字签名。</p><h1 id="Step-4-Basic-Mathematics-and-Binary"><a href="#Step-4-Basic-Mathematics-and-Binary" class="headerlink" title="Step 4: Basic Mathematics and Binary"></a>Step 4: Basic Mathematics and Binary</h1><p>让我们从一些最基本的开始，如果你已经知道了会觉得很无聊，但是对于不知道的人则是必须了解的：<code>ECDSA</code>只使用整数数学，没有浮点数，这意味着可能的数值是1，2，3……，1.5，2.5……则是不被允许的，并且，整数的范围由签名当中所采用的位数决定，更多的位数意味着更大的数字范围，更高的安全性能，因为这使得“猜”到方程当中所采用的具体数字变得更难。正如你所应该知道的，计算机采用比特来表示数据，一个比特是二进制当中的一位，八个比特表示一个字节。每次你增加一个比特，可表示的最大整数就可以翻一倍，使用4个比特，你可以表示0~15，一共16个数字，5个比特，你可以表示32个数字，6个比特，可以表示64个数字……一个字节，可以表示256个数字，32比特，可以表示4294967296个数字……通常<code>ECDSA</code>会总共使用160比特，它可以表示相当大的数，可以由49个数字在里面。</p><p>另外一个需要知道的数学组成是<a href="https://en.wikipedia.org/wiki/Modular_arithmetic" target="_blank" rel="noopener">模运算</a>，可以简单地说是整数求除之后的余数。举个例子，$x \mod 10$是指$x$除以10以后的余数，这个余数总是在0和10之间，$140 \mod 10$的结果是2 。另外一个例子，对于$x \mod 2$的结果，如果$x$偶数则结果为0，如果$x$奇数则结果为1。</p><h1 id="Step5：The-Hash"><a href="#Step5：The-Hash" class="headerlink" title="Step5：The Hash"></a>Step5：The Hash</h1><p><a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" rel="noopener">ECDSA</a>与消息的<a href="https://en.wikipedia.org/wiki/SHA-1" target="_blank" rel="noopener">SHA-1</a><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">加密哈希</a>一起使用来对文件进行签名。一个<a href="https://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="noopener">哈希</a>是你作用于数据的每一个字节然后给你一个代替该数据的整数的另外一个数学函数。举个例子，所有字节所代表的数值之和可以被认为是一个非常简单的哈希函数。于是，消息或文件当中任何修改，整个哈希就会变得完全不同。在SHA1哈希算法当中，它的输出结果总是20字节，即160比特。在验证文件是否被修改或者破坏，它非常有用，你可以得到任意大小的文件的20字节的哈希，并且你可以非常方便的重新计算哈希以确认他们是否匹配得上。而<code>ECDSA</code>所签名的正是那个哈希，因此，如果文件或者数据发生了改变，哈希就会发生改变，然后签名失效了。</p><p>为了便于理解，让我们举一个例子。我们用一个最简单的哈希函数：将所有的数据求和再对10取模运算。</p><p>第一步，你必须理解所有的数据将用整数来进行表示。一个文本文件就是一系列的字节，正如我们之前所解释的，一个字节表示8个比特，可以表示0~255之间的一个数。因此，如果我们用一个整数来表示每一个字节，并且将文件的每一个字节所代表的数相加，然后将求和后的结果对10取模，我们将能够得到一个0~9之间的数作为最终的结果哈希。对于相同的数据我们将总是得到相同的结果，并且假如你修改了文件中的一个字节，结果将会不同。当然，你也知道，因为这个哈希函数的输出空间只有0~9这10种可能性，你想要获得相同的输出，可以非常容易的通过修改文件内容得到，因此，修改文件内容将有1/10的概率得到相同的哈希。</p><p>这是SHA1出来扮演重要角色的地方，SHA1算法比起我们刚才简单的“对10取模”的哈希函数要复杂复杂得多，它将给出一个非常巨大的数（160位或者比特，如果用十进制表示的话将由49个数字组成），并且随着文件的一点细微的小变化，它也能够产生显著的变化。</p><p>这个不可预测的特性让SHA1算法成为一个非常好的哈希算法，非常安全且产生“碰撞(collision)”（两个不同文件有相同的哈希）的可能性非常低，使得通过伪造数据获得特定的哈希的变得不可能。</p><h1 id="Step6-The-ECDSA-Equation"><a href="#Step6-The-ECDSA-Equation" class="headerlink" title="Step6: The ECDSA Equation"></a>Step6: The ECDSA Equation</h1><p>好了，那到底<code>ECDSA</code>是如何工作的呢？<a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography" target="_blank" rel="noopener">椭圆曲线密码学</a>是基于以下形式的方程：<br>$$y^2 = (x^3+a\times x + b) \mod p$$</p><p>第一点你需要注意的是这里有一个取模运算，然后$y$是进行了平方处理，另外也别忘记这是一条曲线的方程。这意味着对于所有的$x$坐标（x只能取整数），你可以得到两个$y$的值，且曲线关于$X$轴对称。取模运算的底是一个<a href="https://en.wikipedia.org/wiki/Prime_number" target="_blank" rel="noopener">素数</a>且确保所有得到的数值在160比特所能够表示的范围之内，允许采用<a href="https://en.wikipedia.org/wiki/Quadratic_residue" target="_blank" rel="noopener">模平方根</a>和<a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse" target="_blank" rel="noopener">模的乘法逆元</a>来简化运算。因为我们以$p$为模的底，这意味着$y^2$可能的取值在0~p-1之间，一共有$p$个可能的值空间。不过，因为我们只能处理整数，只有一部分取值能够满足<a href="https://en.wikipedia.org/wiki/Square_number" target="_blank" rel="noopener">完美平方数</a>（两个整数的平方值）的要求，我们只能在曲线上面得到$N$个可能的点，且满足$N&lt;p$，其中$N$是0~p之间的完美平方数。</p><p>因为每一个$x$可以得到两个曲线上的点（$y^2$的两个正负平方根），这意味着一共有$N/2$个可行的$x$坐标是有效的，并在曲线上面给出相关的点。且因为整数运算和模运算的存在，这条椭圆曲线上面只有有限个点。</p><p>哈哈，是不是有点难，有点复杂，在继续之前，让我们先总结一下。<code>ECDSA</code>方程给出了而一条曲线，这条曲线上面一共有$N$个有效的点，因为$Y$轴的取值区间由模底$p$来确定，并且需要满足完美平方（$Y^2$）并关于$X$轴对称。我们一共有$N/2$个有效的$x$坐标，最后还有满足$N&lt;p$。</p><h1 id="Step-7-Point-Addition"><a href="#Step-7-Point-Addition" class="headerlink" title="Step 7: Point Addition"></a>Step 7: Point Addition</h1><p>关于<a href="https://en.wikipedia.org/wiki/Elliptic_curve" target="_blank" rel="noopener">椭圆曲线</a>需要了解的另外一个事情是<a href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication" target="_blank" rel="noopener">椭圆曲线点加法</a>的表示方法。它是这样定义的：将一个点$P$和另外一个点$Q$相加将得到点$S$，如果我们从$P$到 $Q$画一条线，并延长与曲线相交于第三个点$R$，则$R$为 $S$的负值，别忘记曲线是关于$X$轴对称的。在这种情况下，我们定义$R=-S$来表示$R$在 $X$轴上面的对称点。具体可以看下面这张图。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECDSA/Elliptic%20curves.jpg" alt=""></p><p>这是令$a=-4, b=0$以后的椭圆曲线，关于$X$轴对称，$P+Q$是 $R$关于 $X$轴上面的对称点，且$R$是从$P$到 $Q$连线延长线与曲线的第三个交叉点。</p><h1 id="Step8-Point-Multiplication"><a href="#Step8-Point-Multiplication" class="headerlink" title="Step8: Point Multiplication"></a>Step8: Point Multiplication</h1><p>同样的机制，如果你进行$P+P$，其结果为经过$P$的切线与曲线的交点关于$X$轴的对称点，然后$P+P+P$可以看作是$P+P$点与 $P$点相加的结果。这就可以用来对<a href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication" target="_blank" rel="noopener">椭圆曲线点乘法</a>进行定义：$k \times P$就是点$P$自身进行$k$次相加，以以下两幅图为例。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECDSA/Elliptic%20curves%20II.jpg" alt=""><br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECDSA/Elliptic%20curves%20III.jpg" alt=""></p><p>这里你可以看到两个椭圆曲线和一个用来作切线的点$P$，它与曲线相交于第三点，然后其对称点是$2P$，接着从这个点开始，你画一条从$2P$到 $P$的直线与曲线相交，交点的对称点为$3P$。你可以类推一直做下去来完成椭圆曲线乘法。你也可以猜出为什么在做加法时需要取$R$的对称点，因为只有这样，才可以避免在做同一点的多次加法的时候得到同一条线和相同的三个交点。</p><h1 id="Step-9-The-Trap-Door-Function"><a href="#Step-9-The-Trap-Door-Function" class="headerlink" title="Step 9: The Trap Door Function!"></a>Step 9: The Trap Door Function!</h1><p>一个椭圆曲线乘法的特性是你有一个点$R=k\times P$，你知道$R$和 $P$，但是你无法据此求出$k$，因为这里并没有椭圆曲线减法或者椭圆曲线除法可用，你并不能通过$k=R/P$得到$k$。并且，因为你可以做成千上万次的加法，最终你只是知道在曲线上面结束的点，但是具体是如何到达这个点你也并不知道。你无法进行反向操作，得到与点$P$相乘以后给你点$R$的 $k$。</p><p>这种即便你知道原点和终点，但是无法知道被乘数是<code>ECDSA</code>算法背后安全性的所有基础，而这一原则也被称为<a href="https://en.wikipedia.org/wiki/Trapdoor_function" target="_blank" rel="noopener">单向陷门函数</a>。</p><h1 id="Step-10-The-ECDSA-Algorithm"><a href="#Step-10-The-ECDSA-Algorithm" class="headerlink" title="Step 10: The ECDSA Algorithm"></a>Step 10: The ECDSA Algorithm</h1><p>现在已经掌握了基础，现在让我们来谈谈实际的<code>ECDSA</code>签名算法。</p><p>对于<code>ECDSA</code>算法，首先你需要知道你的曲线参数，一共有$a,b,p,N,G$，你已经了解$a$和 $b$是曲线方程的参数（$y^2=x^3+a \times x + b$）,$p$是模运算的底，$N$是曲线上面点的个数，对于<code>ECDSA</code>，还需要一个参数<code>G</code>，它表示一个你所选中的一个参考的起始点。它可以是曲线上面的任意一点。</p><p>这些曲线参数非常重要，如果不能够事先获得它们，你显然无法签署或者验证一个签名。是的，验证一个签名并不只是知道公钥，你还需要知道这个公钥是从什么曲线参数推算出来的。<a href="https://www.nist.gov/" target="_blank" rel="noopener">NIST(National Institute of Standards and Technology)</a>和<a href="http://www.secg.org/" target="_blank" rel="noopener">SECG(Standards for Efficient Cryptography Group)</a>已经提供了预处理的已知高效和安全的标准化曲线参数。</p><p>总结一下：首先，你有一对密钥：公钥和私钥，私钥是一个随机数，也是160比特大小，公钥是将曲线上的点$G$与私钥相乘以后的曲线上的点。令$dA$表示私钥，一个随机数，$Qa$表示公钥，曲线上面的一个点，我们有$Qa = dA \times G$，其中$G$是曲线上面的参考点。</p><h1 id="Step-11-Creating-a-Signature"><a href="#Step-11-Creating-a-Signature" class="headerlink" title="Step 11: Creating a Signature"></a>Step 11: Creating a Signature</h1><p>下面的问题来了，那么我们是如何对一个文件或者一个信息进行签名的呢？</p><p>第一步，你需要知道签名本身是40字节，由各20字节的两个值来进行表示，第一个值叫作$R$，第二个叫作$S$。值对$(R,S)$放到一起就是你的<code>ECDSA</code>签名。</p><p>然后来看看为了进行签名如何创建这一值对：</p><ul><li>产生一个随机数$k$，20字节</li><li>利用点乘法计算$P=k \times G$</li><li>点$P$的 $x$坐标即为$R$</li><li>利用SHA1计算信息的哈希，得到一个20字节的巨大的整数$z$</li><li>利用方程$S=k^{-1}(z + dA \times R) \mod p$计算$S$</li></ul><p>其中$k$是用来生成$R$的随机数，$k^{-1}$是 $k$的<a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse" target="_blank" rel="noopener">模的乘法逆元</a>。</p><h1 id="Step-12-Verifying-the-Signature"><a href="#Step-12-Verifying-the-Signature" class="headerlink" title="Step 12: Verifying the Signature"></a>Step 12: Verifying the Signature</h1><p>好了，现在有了你的签名，你想要来验证它，也非常的简单，你只需要公钥和导出这个公钥的曲线参数就可以了。你用以下方程来计算点$P$：<br>$$P=S^{-1}\times z \times G + S^{-1} \times R \times Qa$$</p><p>如果点$P$的 $x$坐标与$R$相等，则意味着这个签名是有效的，否则是无效的。</p><p>非常简单，下面来看看如何一步一步从数学上面进行推导的。</p><p>首先，我们有：<br>$$P=S^{-1}\times z \times G + S^{-1} \times R \times Qa$$</p><p>由于$Qa=dA\times G$，代入上式，则有：<br>$$P=S^{-1}\times z \times G + S^{-1} \times R \times dA \times G=S^{-1}(z+dA\times R)\times G$$</p><p>再由点$P$的 $x$坐标必须与$R$匹配，且$R$是点$k\times P$的 $x$坐标，即 $P=k\times G$，于是有：<br>$$k\times G=S^{-1}(z+dA\times R)\times G$$</p><p>两边将$G$拿掉，有：<br>$$k=S^{-1}(z+dA\times R)$$</p><p>两边求逆，即：<br>$$S=k^{-1}(z + dA \times R)$$</p><p>最后这个就是之前用来产生签名的方程，这是相匹配的，这是我们可以采用本节开头给出的方程进行签名验证的原因。</p><h1 id="Step13-The-Security-of-ECDSA"><a href="#Step13-The-Security-of-ECDSA" class="headerlink" title="Step13: The Security of ECDSA"></a>Step13: The Security of ECDSA</h1><p>你可以注意到你需要同时知道随机数$k$和私钥$dA$才能够计算出$S$，但是你需要$R$和公钥$Qa$来对签名进行确认和验证。并且由于$R=k\times G$以及$Qa = dA\times G$再加上<code>ECDSA</code>点乘法当中的单向陷门函数的特性（在Step9中进行过解释），我们无法通过$Qa$和 $R$来计算$dA$或 $k$，这使得<code>ECDSA</code>算法非常安全，没有办法找到私钥，也无法在不知道私钥的情况下伪造签名。</p><h1 id="Step14-The-Importance-of-a-Random-K"><a href="#Step14-The-Importance-of-a-Random-K" class="headerlink" title="Step14: The Importance of a Random K"></a>Step14: The Importance of a Random K</h1><p>现在我们来讨论一下索尼PS3中使用的<code>ECDSA</code>签名是如何以及为什么产生问题的，以及它是如何允许黑客访问PS3的<code>ECDSA</code>的私钥的。</p><p>你还记得产生一个签名的两个方程，$R=k\times G$ 和 $S=k^{-1}(z+dA\times R) \mod p$，这些方程的强势在于实际上有一个方程里面有两个未知数（$k$和 $dA$），因此你是无法确定其中的任意一个。</p><p>话又说回来，算法的安全是基于其实现的。确保随机数$k$确实是随机产生的变得非常重要，并且没有人能够猜测、计算或者其它任何类型的攻击来得到随机数。但是索尼在它们的实现当中犯了一个巨大的错误，它们在任何地方都采用了同一个随机数，然后它们将具有相同的$R$，这意味着你可以使用两个分别具有散列$z$和 $z’$和签名$S$和 $S’$的两个文件的$S$签名来计算随机数$k$：<br>$$S – S’ = k^{-1} (z + dA\times R) – k^{-1} (z’ + dA\times R) = k^{-1} (z + dA\times R – z’ -dA\times R) = k^{-1} (z – z’)$$</p><p>于是有：<br>$$k = \frac{z-z’}{S-S’}$$</p><p>一旦你知道了随机数$k$，求解$S$的方程就变成了一个只含一个未知数的方程，然后可以很容易地解出$dA$：</p><p>$$dA=（S\times k–z）/R$$</p><p>而一旦你知道了私钥$dA$，你现在可以签署自己的文件，PS3将承认它是一个由索尼签署的官方文件。这就是为什么重要的是要确保用于生成签名的随机数实际上是“加密随机的”。这也是为什么不可能有一个3.56版本以上的自定义固件的原因，因为自从3.56版本以来，索尼已经修复了他们的<code>ECDSA</code>算法实现，并使用了新的密钥，现在不可能这么容易找到私钥。</p><p>这个问题的另一个例子是，一些比特币客户使用非加密随机数生成器（在一些浏览器和一些Android客户机上），导致他们以相同的随机数$k$来签署交易，恶意用户能够据此找到他们比特币钱包的私钥并窃取他们的资金。</p><p>这表明了每次签名时使用真正随机数的重要性，因为如果$(R，S)$签名对的$R$值在两个不同签名上相同，则会暴露私钥。</p><p>下图展示了一个关于随机数的笑话。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/ECDSA/ramdom%20number.jpg" alt=""></p><p>当然，只要实现是正确合理的，<code>ECDSA</code>算法非常安全，不可能找到私钥。如果有办法很容易找到私钥，那么每台计算机、网站、系统的安全都可能受到危害，因为很多系统都依赖<code>ECDSA</code>来保证安全，而且不可能破解。</p><h1 id="Step15-Conclusion"><a href="#Step15-Conclusion" class="headerlink" title="Step15: Conclusion"></a>Step15: Conclusion</h1><p>终于！我希望这能让很多人更清楚整个算法。我知道这仍然很复杂、很难理解。我试图让非技术人员更容易理解，但这个算法太复杂，无法用任何简单的术语解释。</p><p>但是，如果你是一个开发人员或数学家，或者有兴趣学习这方面的知识，因为你想帮助或简单地获得知识，那么我确信这包含了足够的信息，你可以开始学习，或者至少理解这个名为<code>ECDSA</code>的未知野兽背后的概念。</p><p>尽管如此，我还是要感谢一些帮助我理解这一切的人，特别是希望保持匿名的人，以及我在这篇文章中链接到的许多维基百科页面，还有Avi Kak，感谢他解释<code>ECDSA</code>背后的<a href="https://engineering.purdue.edu/kak/compsec/NewLectures/Lecture14.pdf" target="_blank" rel="noopener">数学的论文</a>，我从中借用了上面的这些图片。</p>]]></content>
    
    <summary type="html">
    
      学习区块链，总是无法避开各种加密算法，因为各种加密算法在实现区块链当中的各个环节都有着不可替代的作用。这里介绍一下在比特币以及以太坊当中被大量使用基于离散对数数学难题的ECDSA算法。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="加密算法" scheme="http://datacruiser.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="比特币" scheme="http://datacruiser.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="go语言" scheme="http://datacruiser.io/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>区块链核心技术及其应用演讲脚本</title>
    <link href="http://datacruiser.io/2019/12/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%BC%94%E8%AE%B2%E8%84%9A%E6%9C%AC/"/>
    <id>http://datacruiser.io/2019/12/10/区块链核心技术及应用场景演讲脚本/</id>
    <published>2019-12-10T10:09:26.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<p>﻿大家晚上好，我是来自大数据中心的潘华引，首先非常感谢大家能够从百忙之中抽出宝贵的时间来听我的介绍。</p><p>晚上我分享的题目是《区块链核心技术及应用场景》，主要有以下七个部分的内容，希望通过晚上的分享，能够让大家对区块链的发展历程和底层的数据结构以及主要算法能够有所了解。</p><p>准备的时间比较仓促，区块链技术本身也发展很快，有哪里讲得不对的地方请大家多多包涵~</p><ul><li><p>发展历史</p></li><li><p>技术概括</p></li><li><p>核心技术</p></li><li><p>架构分析</p></li><li><p>应用场景</p></li><li><p>产业政策</p></li><li><p>总结展望</p></li></ul><h1 id="区块链发展历史"><a href="#区块链发展历史" class="headerlink" title="区块链发展历史"></a>区块链发展历史</h1><p>我们首先来看看区块链技术在Gartner历年新兴科技发展历程曲线当中的位置，我看了下近10年，也就是从中本聪的比特币白皮书发布以来历年的曲线，区块链技术是从2016年开始在这个曲线首次出现，而且首次出现就处于过热期的阶段，随后两年徘徊在过热期到幻想破灭期的边缘，今年呢，干脆已经消失了，不过随着越来越多的国家将区块链技术放到比较高的战略位置，特别是中国在中共中央政治局会议上进行了集中学习，希望以后特别是明年，能够进入到复苏期。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%203.png" alt=""></p><p>下面这张片子展示了区块链技术的主要里程碑节点，从中本聪的比特币白皮书，比特币创世区块、比特币的首个与美元的汇率，到以太坊的上线，以及中国人民银行DCEP项目的启动，到各种巨头参与的区块链联盟的成立，以及Facebook发布的Libra加密货币白皮书，大家有兴趣可以看看小扎在美国国会上面的听证会，他们的野心的很大的，不过我们在这方面的研究和积累也是比较深厚的，DCEP项目启动时间早，而且国内阿里巴巴、腾讯等巨头也很早开始投入，</p><p>习主席在中央政治局第十八次集体学习时更是强调把区块链作为核心技术自主创新重要突破口 加快推动区块链技术和产业创新发展。可以说把区块链放到了很高的战略地位。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%204.png" alt=""></p><h1 id="区块链技术概述"><a href="#区块链技术概述" class="headerlink" title="区块链技术概述"></a>区块链技术概述</h1><p>那么我们来看看什么是区块链，狭义地说，区块链是一种分布式账本技术，形式上表现为一种基于哈希密码学和梅克尔树模型的链式数据结构。借助非对称加密、点对点网络、节点共识算法和时间戳等机制，为参与节点提供了一个具有充分可信、不可篡改的、数据透明的分布式账本。</p><p>大家请看屏幕右边的这张示意图，所谓分布式账本，就是A君到B君的这一笔转账，整个网络上面的所有人都会将这一笔交易进行记录。广义的讲，区块链还包括在这个分布式账本上面搭建起来的各种商业逻辑。显然，区块链不等于比特币，比特币只是基于区块链技术的一种较为成功的应用，而且也是比特币首次采用了区块链这一独特的数据结构。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%205.png" alt=""></p><p>随着十年的发展，我们把区块链技术进行了分代，分别为：</p><ul><li><p>以比特币为代表的区块链1.0</p></li><li><p>以以太坊为代表的区块链2.0</p></li><li><p>以EOS、DFINITY为代表的区块链3.0</p></li></ul><p>1.0的应用比较单一，就是数字加密货币，以比特币及各种山寨比特币为代表；</p><p>2.0在1.0的基础上，提供了图灵完备的通用编程语言，可以实现各种具有复杂逻辑的金融交易，所谓的智能合约，不过不要被合约两个字唬住了，其实和现实当中的合约并不相同，只是计算机能够识别并执行的各种代码而已；</p><p>3.0则超越了在金融领域的束缚，试图将区块链技术在其它的垂直领域进行应用，后面将区块链应用场景的时候会再具体展开。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%206.png" alt=""></p><p>下面再来对区块链技术分分类：</p><ul><li><p>以各种数字货币为代表的共有链</p></li><li><p>以Linux基金的超级账本为代表的联盟链</p></li><li><p>最后是各种公司内部的私有链</p></li></ul><p>不同类别的区块链从参与者、共识机制、记账主体、是否需要激励、以及适用的场景等方面都有所不同，片子上面都有，这里就不具体展开了。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%207.png" alt=""></p><p>分布式记账相比起传统的记账方式有如下特点：</p><ul><li><p>账本多点存储，通过P2P网络进行更新</p></li><li><p>将每一笔账都打上时间戳，并采用特殊的节点共识算法，确保账本信息的权威且不可篡改</p></li><li><p>当然，密码学上的非对称加密技术也会被采用，用来确保账本内容和交易的安全性</p></li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%208.png" alt=""></p><p>从交易的流程看，相比起传统账本的记账写入和查账读出，基于区块链的分布式账本要更为复杂。大致需要经过以下五个步骤：</p><ul><li><p>交易创建</p></li><li><p>交易传播</p></li><li><p>交易验证</p></li><li><p>网络核实</p></li><li><p>区块更新</p></li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%209.png" alt=""></p><h1 id="区块链核心技术"><a href="#区块链核心技术" class="headerlink" title="区块链核心技术"></a>区块链核心技术</h1><p>到现在，相信大家对区块链应该有一个大致的了解，接下来我们再看看区块链当中所采用的一些核心技术。首先，区块链技术更多的是对已有技术的一种集成，然后在使用模式上进行大量创新。比如密码学上的加密哈希函数，虽然在前面套上加密两个字，但是本质上还是一个哈希函数，和大学本科《数据结构》里面的哈希函数一样，不过有更多的独特性质。</p><ul><li><p>单向性：对于给定的输入可以简单快捷地得到输出，但是，从输出几乎是无法反推出输入，这个可以从数学上面进行确保，比如幂模运算问题，离散对数问题</p></li><li><p>定时/定长性：定时指的是函数计算时间大致相同，定长指的是函数输出内容长度相同，我们看下面这个例子：以比特币系统当中大量采用的SHA256算法为例，不管输入的是“1”，还是“BlockChain”，输出的摘要长度都是256位，这里的位是二进制，一位只有两个取值，0或者1，这样总共256位，为了便于阅读，片子上面用16进制进行表示</p></li><li><p>抗碰撞性：就是很难找到两个不相同的输入，但是输出是相同的，我们看“BlockChain”和“Blockchian”，虽然只是Chain这个字母大小写不同，但是输出却相差万里</p></li></ul><p>另外，在密码学当中，有个nonce的概念，是一个一次性使用的随机数，通常用来与需要进行加密的数据组合使用，以或得特定的摘要（digest）。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2010.png" alt=""></p><p>基于加密哈希函数，区块链技术当中大量使用非对称加密技术，就是通常所说的公钥加密，开发和运维的同学一定非常熟悉，我们在远程登录服务器的时候一般会采用这一技术达到安全和免密登录的目的。</p><p>与对称加密只有一个密钥不同，非对称加密有一对密钥，一个公钥，一个私钥，公钥由私钥通过加密哈希函数计算产生，即私钥是输入，公钥是输出，显然，无法从公开的公钥反推出私钥。公钥可以公开，但是私钥需要小心保存。</p><p>在区块链当中，非对称加密主用在信息加密和数字签名这两个场景有着具体的应用。</p><ul><li><p>信息加密：信息发送者 A 使用接收者 B 的公钥对信息加密后再发送给 B，B 用自己的私钥对信息进行解密</p></li><li><p>数字签名：发送者 A 采用自己的私钥加密信息后发送给 B，B 使用 A 的公钥对信息解密，从而可确保信息是由 A 发送的</p></li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2011.png" alt=""></p><p>这张图展示了比特币应用当中的钱包的产生过程。</p><p>首先，需要一个随机数，通常会借助操作系统的底层随机数生成器生成一个随机数，为了确保安全，区块链系统当中，可靠的随机源非常重要，因为随机数就是你的私钥，在比特币当中，直接决定着比特币的归属。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2012.png" alt=""></p><p>我们常说，程序=数据结构+算法，区块链也不例外。<br>下面先来看看数据结构，需要说明的是，下面提到的数据结构是比特币的数据结构，可能不同的项目，比如以太坊，可能具体的数据域可能有所不同，但是，大体上的哈希链表框架是一样的。</p><p>随着时间的推移，从创世区块开始，区块一个一个地增加，除了创世区块，每个区块都有一个哈希指针，指向前一个区块。</p><p>单个区块来讲，每个区块主要有两部分数据：区块头和区块数据。</p><ul><li>区块头：里面主要含有指向前一个区块的哈希指针，时间戳，Nonce加密随机数，当前区块的哈希</li><li>区块数据：对于比特币来说区块数据就是交易数据，里面是一条条的交易数据</li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2013.png" alt=""></p><p>再将当个区块拿出来看，区块头与区块数据之间是通过Merkle树进行联系的。</p><p>我们先来看这个Merkle树，不难发现，它其实是一棵二叉树，树是一种数据结构，所谓二叉树就是这棵树除了叶子节点，都有两个子节点。而Merkle树的底下一层是比特币交易数据，每笔交易数据使用加密哈希函数进行取哈希操作，然后每两笔相邻交易的哈希继续取哈希，这样不断重复，直到最后剩下一个根节点，所谓的Merkle Root，就是图中的Hash 12345678. 现实情况下可能有更多笔交易。这样设计的好处是什么呢？</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2014.png" alt=""></p><p>显而易见的一点是：区块头只需要保存Merkle树的根哈希就可以了，而不用去管具体的交易，提高区块链的运行效率和可扩展性，另外一点是充分利用了二叉树这一数据结构的特性，在N个交易组成的区块中确认任一交易的算法复杂度仅为$O(logN)$</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2015.png" alt=""></p><p>下面看一个具体比特币区块的结构，这是第100000个区块。</p><ul><li>区块哈希</li><li>包含交易数目</li><li>区块奖励：50个比特币</li><li>Merkle Root</li><li>时间戳</li><li>加密随机数Nonce</li><li>区块大小</li><li>难度值</li><li>前后区块的指针</li><li>详细的交易列表</li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2016.png" alt=""></p><p>讲完数据结构，下面来看看区块链当中所采用的共识算法，因为是分布式账本，所以如何才能够达成共识非常重要。</p><p>比特币当中所采用的共识算法叫作工作证明，<code>Proof of Work</code>，简称<code>PoW</code>。计算过程如下：</p><ul><li>步骤1: 搜集当前时间段的全网未确认交易, 并增加一个用于发行新比特币奖励的 Coinbase 交易，形成当前区块的交易集合</li><li>步骤2: 计算区块体交易集合的 Merkle 根记入区块头, 并填写区块头的其他元数据, 其中随机数 Nonce 置零</li><li>步骤3: 随机数 Nonce 加 1，采用SHA256算法计算当前区块头的哈希值, 如果小于或等于目标值, 则成功搜索到合适的随机数并获得该区块的记账权; 否则继续步骤 3 直到任一节点搜索到合适的随机数为止</li><li>步骤4: 如果一定时间内未成功, 则更新时间戳和未确认交易集合、重新计算 Merkle 根后继续搜索</li></ul><p>为了确保每十分钟出一个区块，目标值会根据当前网络的算力进行动态调整，具体公式如下：</p><ul><li>目标值 = 最大目标值（恒定值）/ 难度值</li><li>难度值 = 上一个区块难度值 *（过去2016个区块的实际花费时长）/ 20160分钟</li></ul><p>其中最大目标值为（十六进制）：<code>0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code></p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2017.png" alt=""></p><p>下面看一个两个区块信息的对比来加深对PoW算法的理解。</p><p>从时间戳上面可以看出，两个区块被挖出的时间相差将近九年，一个是上个月我做PPT的时候被挖出来的，另外一个是2010年底被挖出来的。</p><p>首先从两个区块区块哈希可以看出，目标值越来越小，也就是难度越来越大，这是因为随着这几年比特币价格的节节升高，不断地有人投入挖矿设备，系统内部的算力越来越大。难度的加大，每次计算哈希的次数也大大增加，加密随机数也增加了一个数量级。</p><p>还有一个是挖矿的奖励，从50个比特币降低到12.5个比特币。<br>这是比特币系统本身的设定，大约4年的时间，挖矿奖励减半，直到最后为0，总的比特币个数为：2100万个。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2018.png" alt=""></p><p>下面再具体看下POW共识算法的共识是如何达成的：</p><ul><li>步骤1: 客户端发生新的交易，向全网广播要求记账</li><li>步骤2: 每个记账（矿工）节点收到请求后，将当前时间段内的所有交易以及增加的一个用于发行新比特币奖励的 Coinbase 交易汇总纳入一个新区块</li><li>步骤3: 每个记账节点开始PoW计算，尝试寻找满足当前网络难度目标要求的nonce随机数</li><li>步骤4: 当某个记账节点完成了PoW计算以后，就将自己记录的区块向全网广播</li><li>步骤5: 其它节点通过计算哈希验证该区块PoW计算所找到的nonce随机数满足要求，并验证包含在该区块中的所有交易都是有效且之前未存在过的，认可该区块的有效性，然后继续向邻近节点转发</li><li>步骤6: 其它节点接受该数据区块，并将其加入本节点账本（链条）的末端，延长区块链</li><li>步骤7: 客户端等待至少6个区块确认，以避免出现“双花”等问题，交易结束</li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2019.png" alt=""></p><p>因为区块大小的限制（1M），以及出块时间的限制（大约十分钟），比特币的交易处理能力低下，并且PoW需要大量哈希计算，这也是它的名字的由来，需要一定的哈希计算工作量。这个过程需要消耗大量电力，目前的统计，比特币每笔交易需要消耗660多度电，比特币整个网络所消耗的电力约占全世界电力消耗的0.33%，与奥地利整个国家的电力消耗接近；以太坊因为10秒钟可以出一个块，单笔交易的电力消耗大约30多度，比比特币的小一个数量级。</p><p>为了提高共识达成的效率，就有人提出了PoS算法，权益证明机制，PoS算法依然还是要不断计算哈希，但是，每个人的难度是不一样的，如果你的权益多，且为了取得某次记账权愿意消耗一部分权益，那么你的挖矿难度将会大大降低。</p><p>这样那些没有权益或者不愿意花费一定权益的节点就不会去挖矿，白白浪费资源。</p><p>目前，点点币是采用了PoS机制，另外以太坊也有这方面的打算，虽然已经这样计划了很久。</p><p>从安全性方面来考虑，PoS比起PoW还有这样一个好处：在应对外部攻击的时候，PoS机制的区块链本身是闭环的。怎么理解这个问题呢？我们来分析一下：对于PoW机制，理论上，如果我有足够的计算设备，就可以控制网络上面的算力，就可以为所欲为，跟我是否有对应的区块链中的权益无关，比如比特币；但是，对于PoS机制，要发起攻击，你只有算力是不够的，你还需要有权益，比如点点币，你需要有点点币，而且持有的时间越长越好，那你的点点币哪里来呢？你必须从市场上面去购买，这样币的价格就会升高，你买到的难度就会加大，这里就像股票交易市场一样，当市场上面有大量的人都冲着某一只股票去的时候，那么它的价格就会升高，你买到的难度或者要付出的成本就要增加。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2020.png" alt=""></p><p>节点共识算法还有很多，包括DPoS，和PBFT等等。DPoS是在PoS的基础之上，选举出一个权益代表委员会，大家轮流记账，产生新区块，那个时候也就不用挖矿了。目前EOS使用的是DPoS机制。</p><p>PBFT是在传统BFT算法的基础上面进行的优化，使得算法复杂度从指数级别下降到$O(N^2)$的程度，在现实当中堪用，通常在联盟链和私有链当中会有所采用，比如Linux基金会的HyperLedger，超级账本。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2021.png" alt=""></p><p>上述几种算法的主要指标对比如下：</p><p>在去中心化、安全性、可用性的“不可能三角”当中，各种算法各有优劣，通常会根据场景综合选择或者组合使用。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2022.png" alt=""></p><p>在区块链的核心技术当中，最后再来讲讲分叉，fork和对区块链的攻击。</p><p>这里强调一点：在区块链当中，最长的链才是合法的链。</p><p>在修复Bug或者更新共识机制的时候，区块链会发生分叉。根据最终结果的不同，可以分为hard fork和soft fork。</p><p>举个例子，比如关于比特币区块的大小，如果从1M调整为8M，那么更新后的算力会挖出小于等于8M的区块，旧的节点是不会对这些区块进行确认的，旧节点依然挖小于等于1M的区块，当然，如果在新的链当中出现了小于等于1M的区块，新节点也是会进行确认的，但是，旧的链上永远不会出现大于1M的区块，这样，最终一条链变成两条链；如果是将区块大小从1M调整为0.5M，那么不管节点是否升级，大家都是认可0.5M大小的区块的，因此，最终，软分叉最终会导致一条新区块的区块大小都是0.5M的新链。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2023.png" alt=""></p><p>对分叉有所了解以后，理解共识攻击应该也不难。</p><p>对于数字货币，比较难解决的一个问题就是双花问题，就是如何杜绝一块钱花两次。因为理论上，在计算机当中，它只是一份数据，可以无限拷贝。而现实中的现金显然不会遇到这个问题，你的现金花出去了就花出去了，后面就不属于你了，根本没有机会让你花两次。</p><p>比特币是这样规定的，其实前面我们已经讲过，只认为最长的链才是合法的。</p><p>我们看下面的第一张图，假设Block 1 和Block 1’里面有两笔相同的交易，如果都有效那么就会发生双花，但是比特币只认上面这条更长的链。这是正常的情况，在有人借助算力优势，发动51%攻击，企图对区块链进行篡改的时候，还是可以进行双花的，即便那样会得不偿失。具体过程是这样的：</p><ul><li>首先，在Block 1进行交易，然后在得到商家的货物以后，马上发起另外一笔交易，这笔交易要花同一笔钱，然后利用算力优势获得记账权并将这笔交易纪录在Block 1’当中，并且以后都在Block 1’后面进行记账，延长这一条链，这样就可以将前面的Block 1的交易作废，达到了双花的目的。</li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2024.png" alt=""></p><p>不过，依据目前比特币网络当中的算力，想发动51%攻击的成本巨大，远远高于双花的收益。同时，如果发生攻击也会大大影响比特币的价值。</p><p>到这里，终于把区块链的核心数据结构和算法讲完了。</p><h1 id="区块链架构分析"><a href="#区块链架构分析" class="headerlink" title="区块链架构分析"></a>区块链架构分析</h1><p>从经典的架构层级分析的角度，区块链的架构如下，主要有数据层、网络层、共识层、激励层、合约层和应用层。</p><p>数据层主要就是各种数据结构和加密算法，是基础。网络层是区块链网络里面的数据如何传播，比如通过P2P、TCP/IP协议等等，是各种数据交换的基础。网络层之上是共识层，承载各种共识协议。激励层为区块链的可持续运行提供措施，合约层和应用层直接解决现实痛点。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2027%2011%3A12%3A2019.png" alt=""></p><p>具体到各个现有案例的传统前后端的架构如下：</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2028%2011%3A12%3A2019.png" alt=""></p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2029%2011%3A12%3A2019.png" alt=""></p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2030%2011%3A12%3A2019.png" alt=""></p><p>下面是具体企业的架构设想，大家可以参考，具体了解可以再看看他们发布的白皮书。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2031%2011%3A12%3A2019.png" alt=""></p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2032%2011%3A12%3A2019.png" alt=""></p><h1 id="区块链应用场景"><a href="#区块链应用场景" class="headerlink" title="区块链应用场景"></a>区块链应用场景</h1><p>根据它的特点，区块链典型的应用场景主要具备以下两个条件：</p><ul><li>注定无法中心化</li><li>有达成共识的刚需</li></ul><p>比如暗网上面的地下交易市场，注定无法使用国家中心化的货币以及当前的全球化的金融体系，同时又有达成交易共识的需求，恰好基于区块链技术的比特币解决了该问题，这也是比特币的价格不断上涨的原因之一。</p><p>另外，比如多家企业需要定期进行结算的这么一个场景：当结算发生争议的时候，比如各家的交易纪录不一致，这个时候免不了需要一些第三方的机构介入，耽误时间不说，成本也不小。如果采用了区块链这一分布式账本，则在每一次<br>记账就自然而然地纪录了相应的交易纪录，且能够做到一致、不可篡改，就能够比较好地解决该问题。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2033%2011%3A12%3A2019.png" alt=""></p><p>腾讯等大公司其实非常早就在区块链应用方面进行了大量的探索，积极拓展、落地相关场景。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2034%2011%3A12%3A2019.png" alt=""></p><p>另外，本人是能源背景，在能源领域有着将近10年的工作经验，区块链技术在能源领域也有一些很好的切入点。</p><p>首先是碳排放权的认证。</p><p>联合国政府间气候变化专门委员会1997年通过《京都议定书》，确立了二氧化碳排放权（简称碳排放权）的认证及其交易机制。顾名思义，碳排放权是对各行业二氧化碳排放的一种 分配和计量方式。政府有关部 门会结合我国碳减排目标 ，根据各行业排放情况，对产生排放的各主体分配一定配额的碳排放权。排放超过配额 的主体要被处以罚款 。多产生的碳排放需要通过额外购买排放权的方式抵消，排放权有余额 的参主体可以将多余部分转移给排放超额的主体，从而获取利润。　</p><p>电力系统是碳排放的大户，将是碳交易的活跃部门，主要的需求是买入排放权，特别是燃煤发电的企业，煤的主要成分是碳，燃烧以后将会排放大量的二氧化碳。而一些新能源领域的企业，比如太阳能发电、风力发电，甚至电动汽车的制造商，本身的碳排放配额会有富余，可以将排放权卖出去，比如特斯拉依靠碳排放权交易，从2010年开始至今已经收入超过20亿美元。</p><p>我国作为负责任的大国，根据《京都议定书》以及《巴黎气候协定》等国际文件的安排，承担了一定的二氧化碳减排要求，也就是说随着时间，我们的碳排放总量在达到一定的峰值以后是要不断减少的，而政府监管部门将会面对碳排放权的配额认证、交易追溯、配额监管等各种痛点，根据目前我们所了解的区块链的一些特性，如果我们用基于区块链技术的分布式账本来构建一个碳排放交易系统，将能够非常好地解决这些痛点。</p><p>给每个有碳排放权的企业或者个体分配一个专用ID，相当于公钥，监管部门定期核定并对其碳排放额进行认证，这相当于比特币当中的<code>coinbase</code>，后面不同企业之间的碳排放权的交易可以一笔笔地记录在不可篡改的区块当中。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2035%2011%3A12%3A2019.png" alt=""></p><p>另外一个能源领域的场景是虚拟发电资源交易系统。考虑到各种分布式电源众多，门类多，容量小，出力间断且随机，需要根据响应结合储能进行集中管理、统一调度，实现不同虚拟发电资源的协同是实现分布式能源消纳的重要途径。</p><p>基于区块链技术的虚拟发电资源交易系统可以实现源、荷、储能以及外面需求的信息双向选择和反馈，在资源加入电厂当中的时候根据达成的协议自动生成智能合约，最终打造一个公平可信、公开透明、成本低廉的交易系统。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2036%2011%3A12%3A2019.png" alt=""></p><p>最后这个是中国人民银行做的数字货币项目，从2014年就开始搞了，目前网上有披露了一些资料，主要实现对M0，即流通中的现金的替代，目前已经有一些城市的部分银行正在试点，相信后续会加快推动。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2037%2011%3A12%3A2019.png" alt=""></p><h1 id="区块链产业政策"><a href="#区块链产业政策" class="headerlink" title="区块链产业政策"></a>区块链产业政策</h1><p>，目前中国在区块链方面的产业政策主要两方面，一个是对打着区块链的名义进行<code>ICO</code>以及对虚拟货币投资炒作的打击，另外一个是对具体合适的场景的产业护持。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2051%E5%AD%A6%E9%99%A2%2036.png" alt=""></p><h1 id="区块链总结展望"><a href="#区块链总结展望" class="headerlink" title="区块链总结展望"></a>区块链总结展望</h1><p>总的来讲，区块链是具有国家战略意义的新兴技术，新旧动能持续转换的重要动力，几年前是各行各业的“互联网+”，接下去几年可能是大家积极探索“区块链+”的时候。</p><p>另外，我个人觉得，“区块链+”可能会像石油、电力、通讯等行业类似，蛋糕很大，但是最终分给谁，可能并不取决于谁家的技术实力，政策以及规则的制定者会有更大的话语权。</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2039%2011%3A12%3A2019.png" alt=""></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.gartner.com/en" target="_blank" rel="noopener">Gartner 历年新兴科技趋势图</a></li><li><a href="https://blockexplorer.com/" target="_blank" rel="noopener">blockexplorer</a></li><li><a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">比特币白皮书</a></li><li><a href="https://github.com/ethereum/wiki/wiki/White-Paper" target="_blank" rel="noopener">以太坊白皮书</a></li><li><a href="https://trustsql.qq.com/chain_oss/TrustSQL_WhitePaper.html" target="_blank" rel="noopener">2019 腾讯区块链白皮书</a></li><li><a href="http://www.cbdio.com/image/site2/20190411/f4285315404f1e19523705.pdf" target="_blank" rel="noopener">京东区块链技术实践白皮书（2019）</a></li><li><a href="http://www.aas.net.cn/CN/article/downloadArticleFile.do?attachType=PDF&amp;id=18837" target="_blank" rel="noopener">袁勇, 王飞跃. 区块链技术发展现状与展望[J]. 自动化学报, 2016, 42(4): 481-494</a></li><li>张亮, 刘百祥, 张如意等. 区块链技术综述[J]. 计算机工程, 2019, 45(5): 1-12</li><li>张宁, 王毅, 康重庆等. 能源互联网中的区块链技术：研究框架与典型应用初探[J]. 中国电机工程学报, 2016, 36(15): 4011-4022</li><li><a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf" target="_blank" rel="noopener">Blockchain Technology Overview. NIST. 2018</a></li><li><a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Blockchain</a></li><li><a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merkle_tree</a></li><li><a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hashcash</a></li><li><a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf" target="_blank" rel="noopener">2018 年中国区块链产业白皮书</a></li><li><a href="https://www.amazon.cn/dp/B071K7FCD4/ref=sr_1_1?keywords=Mastering+Bitcoin&amp;qid=1572521851&amp;sr=8-1" target="_blank" rel="noopener">Andreas M. Antonopoulos, Mastering Bitcoin, 2nd Edition, O•REILLY®, 2017</a></li><li><a href="https://www.searchain.net/news/264496.html" target="_blank" rel="noopener">研报 | 初探中国央行数字货币：目标、定位、机制与影响</a></li></ul>]]></content>
    
    <summary type="html">
    
      最近又在公司更大的范围重新讲了一次上次做的关于区块链的片子，当然随着最近自己也看了一些新的资料，片子本身的内容也进行了大幅度的修改，并且时间上面也允许我花一些时间写一个演讲脚本出来，这样子，整个文章就更加丰满了。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="比特币" scheme="http://datacruiser.io/categories/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    
      <category term="区块链" scheme="http://datacruiser.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="非对称加密" scheme="http://datacruiser.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="比特币" scheme="http://datacruiser.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="共识算法" scheme="http://datacruiser.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="DoW" scheme="http://datacruiser.io/tags/DoW/"/>
    
      <category term="DoS" scheme="http://datacruiser.io/tags/DoS/"/>
    
      <category term="PDoS" scheme="http://datacruiser.io/tags/PDoS/"/>
    
      <category term="PBFT" scheme="http://datacruiser.io/tags/PBFT/"/>
    
  </entry>
  
  <entry>
    <title>SHA256算法原理及其实现</title>
    <link href="http://datacruiser.io/2019/11/22/SHA256%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://datacruiser.io/2019/11/22/SHA256算法原理及其实现/</id>
    <published>2019-11-22T20:25:25.000Z</published>
    <updated>2020-01-31T14:37:28.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SHA-2-族算法简介"><a href="#SHA-2-族算法简介" class="headerlink" title="SHA-2 族算法简介"></a>SHA-2 族算法简介</h1><p>一个<code>n</code>位的哈希函数就是一个从任意长的消息到<code>n</code>位哈希值的映射，一个<code>n</code>位的加密哈希函数就是一个单向的、避免碰撞的<code>n</code>位哈希函数。这样的函数是目前在数字签名和密码保护当中极为重要的手段。</p><p>当前比较流行的哈希函数主要有128位的MD4和MD5和160位的SHA-1，今天介绍的SHA-2族有着更多位的输出哈希值，破解难度更大，能够提高更高的安全性。</p><p>SHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8" target="_blank" rel="noopener">密码散列函数</a>算法标准，由<a href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%AE%89%E5%85%A8%E5%B1%80" target="_blank" rel="noopener">美国国家安全局</a>研发，由<a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E5%AE%B6%E6%A8%99%E6%BA%96%E6%8A%80%E8%A1%93%E7%A0%94%E7%A9%B6%E6%89%80" target="_blank" rel="noopener">美国国家标准与技术研究院</a>（NIST）在2001年发布。属于<a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F" target="_blank" rel="noopener">SHA算法</a>之一，是SHA-1的后继者。其下又可再分为六个不同的算法标准，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。</p><p>这些变体除了生成摘要的长度、循环运行的次数等一些细微差异之外，基本结构是一致的。本文主要讲一讲SHA256。</p><h1 id="SHA256原理详解"><a href="#SHA256原理详解" class="headerlink" title="SHA256原理详解"></a>SHA256原理详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于任意长度的消息，SHA256都会产生一个256位的哈希值，称作消息摘要。这个摘要相当于四个长度为32个字节的数组，通常有一个长度为64的十六进制字符串来表示，其中1个字节=8位，一个十六进制的字符的长度为4位。</p><p>来看一个具体的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockChain</span><br></pre></td></tr></table></figure><p>这句话经过哈希函数SHA256后得到的哈希值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3a6fed5fc11392b3ee9f81caf017b48640d7458766a8eb0382899a605b41f2b9</span><br></pre></td></tr></table></figure><p>总体上，HSA256与MD4、MD5以及HSA-1等哈希函数的操作流程类似，待哈希的消息在继续哈希计算之前首先要进行以下两个步骤：</p><ul><li>对消息进行补位处理，是的最终的长度是512位的倍数，然后</li><li>以512位为单位对消息进行分块为$M^{(1)},\,M^{(2)},…,M^{(N)}$</li></ul><p>消息区块将进行逐个处理：从一个固定的初始哈希$H^{(0)}$开始，进行以下序列的计算：</p><p>$$H^{(i)}=H^{(i-1)}+C_{M^{(i)} }(H^{(i-1)})$$</p><p>其中$C$是SHA256的压缩函数，$+$是mod$2^{32}$加法，即将两个数字加在一起，如果对$2^{32}$取余, $H^{(N)}$是消息区块的哈希值. </p><h2 id="算法详细描述"><a href="#算法详细描述" class="headerlink" title="算法详细描述"></a>算法详细描述</h2><p>SHA256的压缩函数主要对512位的消息区块和256位的中间哈希值进行操作，本质上，它是一个通过将消息区块为密钥对中间哈希值进行加密的256位加密算法。<br>因此，为了描述SHA256算法，有以下两方面的组件需要描述：</p><ul><li>SHA256压缩函数</li><li>SHA256消息处理流程</li></ul><p>以下的描述当中所使用到的标记如下：</p><ul><li>$\oplus$: 按位异或</li><li>$\wedge$: 按位与</li><li>$\vee$: 按位或</li><li>$\lnot$: 补位</li><li>$+$: 相加以后对$2^{32}$求余</li><li>$R^n$: 右移n位</li><li>$S^n$: 循环右移n位</li></ul><p>以上所有的操作都是针对32位字节. </p><h3 id="常量初始化"><a href="#常量初始化" class="headerlink" title="常量初始化"></a>常量初始化</h3><p>初始哈希值$H^{(0)}$取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分, 并且取前面的32位. 下面举个例子:<br>$\sqrt{2}$小数部分约为0.414213562373095048, 而其中<br>$$0.414213562373095048 \approx 6<em>16^{-1}+a</em>16^{-2}+0*16^{-3}+…$$<br>于是, 质数2的平方根的小数部分取前32位就对应<code>0x6a09e667</code>. </p><p>如此类推, 初始哈希值$H^{(0)}$由以下8个32位的哈希初值构成:</p><p>$$<br>\begin{align}<br>H^{(0)}_1&amp;=6a09e667\\<br>H^{(0)}_2&amp;=bb67ae85\\<br>H^{(0)}_3&amp;=3c6ef372\\<br>H^{(0)}_4&amp;=a54ff53a\\<br>H^{(0)}_5&amp;=510e527f\\<br>H^{(0)}_6&amp;=9b05688c\\<br>H^{(0)}_7&amp;=1f83d9ab\\<br>H^{(0)}_8&amp;=5be0cd19<br>\end{align}<br>$$</p><p>SHA256算法当中还使用到64个常数, 取自自然数中前面64个素数的立方根的小数部分的前32位, 如果用16进制表示, 则相应的常数序列如下: </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">428</span>a2f98 <span class="number">71374491</span> b5c0fbcf e9b5dba5</span><br><span class="line"><span class="number">3956</span>c25b <span class="number">59f</span>111f1 <span class="number">923f</span>82a4 ab1c5ed5</span><br><span class="line">d807aa98 <span class="number">12835</span>b01 <span class="number">243185</span>be <span class="number">550</span>c7dc3</span><br><span class="line"><span class="number">72</span>be5d74 <span class="number">80d</span>eb1fe <span class="number">9</span>bdc06a7 c19bf174</span><br><span class="line">e49b69c1 efbe4786 <span class="number">0f</span>c19dc6 <span class="number">240</span>ca1cc</span><br><span class="line"><span class="number">2d</span>e92c6f <span class="number">4</span>a7484aa <span class="number">5</span>cb0a9dc <span class="number">76f</span>988da</span><br><span class="line"><span class="number">983e5152</span> a831c66d b00327c8 bf597fc7</span><br><span class="line">c6e00bf3 d5a79147 <span class="number">06</span>ca6351 <span class="number">14292967</span></span><br><span class="line"><span class="number">27</span>b70a85 <span class="number">2e1</span>b2138 <span class="number">4d</span>2c6dfc <span class="number">53380d</span>13</span><br><span class="line"><span class="number">650</span>a7354 <span class="number">766</span>a0abb <span class="number">81</span>c2c92e <span class="number">92722</span>c85</span><br><span class="line">a2bfe8a1 a81a664b c24b8b70 c76c51a3</span><br><span class="line">d192e819 d6990624 f40e3585 <span class="number">106</span>aa070</span><br><span class="line"><span class="number">19</span>a4c116 <span class="number">1e376</span>c08 <span class="number">2748774</span>c <span class="number">34</span>b0bcb5</span><br><span class="line"><span class="number">391</span>c0cb3 <span class="number">4</span>ed8aa4a <span class="number">5</span>b9cca4f <span class="number">682e6f</span>f3</span><br><span class="line"><span class="number">748f</span>82ee <span class="number">78</span>a5636f <span class="number">84</span>c87814 <span class="number">8</span>cc70208</span><br><span class="line"><span class="number">90</span>befffa a4506ceb bef9a3f7 c67178f2</span><br></pre></td></tr></table></figure><h3 id="消息预处理"><a href="#消息预处理" class="headerlink" title="消息预处理"></a>消息预处理</h3><p>在计算消息的哈希摘要之前需要对消息进行预处理:</p><ul><li>对消息进行补码处理: 假设消息$M$的二进制编码长度为$l$位. 首先在消息末尾补上一位”1”, 然后再补上$k$个”0”, 其中$k$为下列方程的最小非负整数<br>$$l+1+k\equiv448 \mod 512$$</li></ul><p>举个例子, 以消息”abc”为例显示补位的过程. </p><p>a,b,c对应的<a href="http://ascii.911cha.com/" target="_blank" rel="noopener">ASCII码</a>和二进制编码分别如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始字符    ASCII码    二进制编码</span><br><span class="line">a          <span class="number">97</span>         <span class="number">01100001</span></span><br><span class="line">b          <span class="number">98</span>         <span class="number">01100010</span></span><br><span class="line">c          <span class="number">99</span>         <span class="number">01100011</span></span><br></pre></td></tr></table></figure><p>因此, 原始信息”abc”的二进制编码为:<code>01100001 01100010 01100011</code>, 第一步补位, 首先在消息末尾补上一位”1”, 结果为: <code>01100001 01100010 01100011 1</code>;<br>然后进行第二步的补位, 因为$l=24$, 可以得到$k=423$, 在第一步补位后的消息后面再补423个”0”, 结果如下:</p><p>$$01100001 \, 01100010 \, 01100011 \,1\, \underbrace{00…0}_{423}$$ </p><p>最后还需要在上述字节串后面继续进行补码, 这个时候补的是原消息”abc”的二进制长度$l=24$的64位二进制表示形式, 补完以后的结果如下:</p><p>$$01100001 \, 01100010 \, 01100011 \,1\, \underbrace{00…0}_{423}\,\underbrace{00…011000}_{64}$$ </p><p>最终补完以后的消息二进制位数长度是512的倍数. </p><p>这里需要注意的两点是不管原来的消息长度是多少, 即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512位. 另外, 考虑到最后要将消息长度$l$转换为64位二进制编码, 因此, 长度的必须小于$2^{64}$, 绝大多数情况, 这个足够大了. </p><ul><li>将补码处理后的消息以512位为单位分块为: $M^{(1)},\,M^{(2)},…,M^{(N)}$, 其中第$i$个消息块的前32位表示为: $M^{(i)}_0$, 后面32位为: $M^{(i)}_1$, 以此类推, 最后32位的消息块可表示为: $M^{(i)}_15$. 我们采用Big endian约定对数据进行编码, 即认为第一个字节是最高位字节, 因此, 对于每一个32位字节, 最最左边的比特是最大的比特位. </li></ul><h3 id="摘要计算主循环"><a href="#摘要计算主循环" class="headerlink" title="摘要计算主循环"></a>摘要计算主循环</h3><p>哈希计算算法如下:</p><ul><li><p>$For\, i = 1 \to N$ ($N$ = 补码后消息块个数)</p><ul><li><p>用第$ (i - 1)$个中间哈希值来对 $a,b,c,d,e,f,g,h$进行初始化, 当$i=1$时, 就使用初始化哈希, 即:<br>$$<br>\begin{align}<br>a&amp;\gets H^{(i-1)}_1\\<br>b&amp;\gets H^{(i-1)}_2\\<br>&amp;\vdots\\<br>h&amp;\gets H^{(i-1)}_8<br>\end{align}<br>$$</p></li><li><p>应用SHA256压缩函数来更新$a,b,…,h$</p><ul><li>$For\, j = 0 \to 63$<ul><li>计算$Ch(e,f,g), M_{aj}(a,b,c), \Sigma_0(a), \Sigma_1(e), W_j$(具体定义如下)<br>$$<br>\begin{align}<br>T_1 &amp;\gets h+\Sigma_1(e)+Ch(e,f,g)+K_j+W_j\\<br>T_2&amp;\gets \Sigma_0(a)+M_{aj}(a,b,c)\\<br>h&amp;\gets g\\<br>g&amp;\gets f\\<br>f&amp;\gets e\\<br>e&amp;\gets d+T_1\\<br>d&amp;\gets c\\<br>c&amp;\gets b\\<br>b&amp;\gets a\\<br>a&amp;\gets T_1+T_2<br>\end{align}<br>$$</li></ul></li></ul></li><li>计算第$i$个中间哈希值$H^{(i)}$<br>$$<br>\begin{align}<br>H^{(i)}_1 &amp;\gets a + H^{(i-1)}_1\\<br>H^{(i)}_2 &amp;\gets b+ H^{(i-1)}_2\\<br>&amp;\vdots\\<br>H^{(i)}_8 &amp;\gets h+H^{(i-1)}_8<br>\end{align}<br>$$</li></ul></li><li><p>$H^{(N)}=(H^{(N)}_1,H^{(N)}_2,…,H^{(N)}_8)$为最终需要的哈希$M$。</p></li></ul><h3 id="逻辑函数定义"><a href="#逻辑函数定义" class="headerlink" title="逻辑函数定义"></a>逻辑函数定义</h3><p>SHA256算法当中所使用到的6个逻辑函数如下：每个函数都对32位字节进行操纵，并输出32位字节。</p><p>$$<br>\begin{align}<br>Ch(x,y,z)&amp;=(x\wedge y)\oplus(\lnot x \wedge z)\\<br>M_{aj}(x,y,z)&amp;=(x\wedge y)\oplus(x\wedge z)\oplus(y\wedge z)\\<br>\Sigma_0(x)&amp;=S^2(x)\oplus S^{13}(x)\oplus S^{22}(x)\\<br>\Sigma_1(x)&amp;=S^6(x)\oplus S^{11}(x) \oplus S^{25}(x)\\<br>\sigma_0(x)&amp;=S^7(x)\oplus S^{18}(x) \oplus R^3(x)\\<br>\sigma_1(x)&amp;=S^{17}(x)\oplus S^{19}(x) \oplus R^{10}(x)<br>\end{align}<br>$$</p><p>扩展消息块$W_0, W_1, …, W_{63}$通过以下方式进行计算：</p><ul><li>$W_j=M^{(i)}_j \,for\,j=0,1,…,15$</li><li>$For \,j= 16\to 63$ <ul><li>$W_j\gets \sigma_1(W_{j-2})+W_{j-7}+\sigma_0(W_{j-15})+W_{j-16}$</li></ul></li></ul><h3 id="图形表示"><a href="#图形表示" class="headerlink" title="图形表示"></a>图形表示</h3><p>SHA256压缩函数的图形表示如下：</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/SHA/yarbrelease.dvi%202019-12-01%2017-50-06.png" alt=""></p><p>扩展消息块$W$的求解算法可以表示如下：</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/SHA/yarbrelease.dvi%202019-12-01%2017-50-41.png" alt=""></p><h1 id="SHA伪代码"><a href="#SHA伪代码" class="headerlink" title="SHA伪代码"></a>SHA伪代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">Note <span class="number">1</span>: All variables are <span class="number">32</span> bit <span class="keyword">unsigned</span> integers <span class="keyword">and</span> addition is calculated modulo <span class="number">232</span></span><br><span class="line">Note <span class="number">2</span>: For each round, there is one round constant k[i] <span class="keyword">and</span> one entry in the message schedule <span class="built_in">array</span> w[i], <span class="number">0</span> ≤ i ≤ <span class="number">63</span></span><br><span class="line">Note <span class="number">3</span>: The compression function uses <span class="number">8</span> working variables, a through h</span><br><span class="line">Note <span class="number">4</span>: Big-endian convention is used when expressing the constants in <span class="keyword">this</span> pseudocode,</span><br><span class="line">    <span class="keyword">and</span> when parsing message block data from bytes to words, <span class="keyword">for</span> example,</span><br><span class="line">    the first word of the input message <span class="string">"abc"</span> after padding is <span class="number">0x61626380</span></span><br><span class="line"></span><br><span class="line">Initialize hash values:</span><br><span class="line">(first <span class="number">32</span> bits of the fractional parts of the square roots of the first <span class="number">8</span> primes <span class="number">2.</span><span class="number">.19</span>):</span><br><span class="line">h0 := <span class="number">0x6a09e667</span></span><br><span class="line">h1 := <span class="number">0xbb67ae85</span></span><br><span class="line">h2 := <span class="number">0x3c6ef372</span></span><br><span class="line">h3 := <span class="number">0xa54ff53a</span></span><br><span class="line">h4 := <span class="number">0x510e527f</span></span><br><span class="line">h5 := <span class="number">0x9b05688c</span></span><br><span class="line">h6 := <span class="number">0x1f83d9ab</span></span><br><span class="line">h7 := <span class="number">0x5be0cd19</span></span><br><span class="line"></span><br><span class="line">Initialize <span class="built_in">array</span> of round constants:</span><br><span class="line">(first <span class="number">32</span> bits of the fractional parts of the cube roots of the first <span class="number">64</span> primes <span class="number">2.</span><span class="number">.311</span>):</span><br><span class="line">k[<span class="number">0.</span><span class="number">.63</span>] :=</span><br><span class="line">   <span class="number">0x428a2f98</span>, <span class="number">0x71374491</span>, <span class="number">0xb5c0fbcf</span>, <span class="number">0xe9b5dba5</span>, <span class="number">0x3956c25b</span>, <span class="number">0x59f111f1</span>, <span class="number">0x923f82a4</span>, <span class="number">0xab1c5ed5</span>,</span><br><span class="line">   <span class="number">0xd807aa98</span>, <span class="number">0x12835b01</span>, <span class="number">0x243185be</span>, <span class="number">0x550c7dc3</span>, <span class="number">0x72be5d74</span>, <span class="number">0x80deb1fe</span>, <span class="number">0x9bdc06a7</span>, <span class="number">0xc19bf174</span>,</span><br><span class="line">   <span class="number">0xe49b69c1</span>, <span class="number">0xefbe4786</span>, <span class="number">0x0fc19dc6</span>, <span class="number">0x240ca1cc</span>, <span class="number">0x2de92c6f</span>, <span class="number">0x4a7484aa</span>, <span class="number">0x5cb0a9dc</span>, <span class="number">0x76f988da</span>,</span><br><span class="line">   <span class="number">0x983e5152</span>, <span class="number">0xa831c66d</span>, <span class="number">0xb00327c8</span>, <span class="number">0xbf597fc7</span>, <span class="number">0xc6e00bf3</span>, <span class="number">0xd5a79147</span>, <span class="number">0x06ca6351</span>, <span class="number">0x14292967</span>,</span><br><span class="line">   <span class="number">0x27b70a85</span>, <span class="number">0x2e1b2138</span>, <span class="number">0x4d2c6dfc</span>, <span class="number">0x53380d13</span>, <span class="number">0x650a7354</span>, <span class="number">0x766a0abb</span>, <span class="number">0x81c2c92e</span>, <span class="number">0x92722c85</span>,</span><br><span class="line">   <span class="number">0xa2bfe8a1</span>, <span class="number">0xa81a664b</span>, <span class="number">0xc24b8b70</span>, <span class="number">0xc76c51a3</span>, <span class="number">0xd192e819</span>, <span class="number">0xd6990624</span>, <span class="number">0xf40e3585</span>, <span class="number">0x106aa070</span>,</span><br><span class="line">   <span class="number">0x19a4c116</span>, <span class="number">0x1e376c08</span>, <span class="number">0x2748774c</span>, <span class="number">0x34b0bcb5</span>, <span class="number">0x391c0cb3</span>, <span class="number">0x4ed8aa4a</span>, <span class="number">0x5b9cca4f</span>, <span class="number">0x682e6ff3</span>,</span><br><span class="line">   <span class="number">0x748f82ee</span>, <span class="number">0x78a5636f</span>, <span class="number">0x84c87814</span>, <span class="number">0x8cc70208</span>, <span class="number">0x90befffa</span>, <span class="number">0xa4506ceb</span>, <span class="number">0xbef9a3f7</span>, <span class="number">0xc67178f2</span></span><br><span class="line"></span><br><span class="line">Pre-processing (Padding):</span><br><span class="line">begin with the original message of length L bits</span><br><span class="line">append a single <span class="string">'1'</span> bit</span><br><span class="line">append K <span class="string">'0'</span> bits, where K is the minimum number &gt;= <span class="number">0</span> such that L + <span class="number">1</span> + K + <span class="number">64</span> is a multiple of <span class="number">512</span></span><br><span class="line">append L as a <span class="number">64</span>-bit big-endian integer, making the total post-processed length a multiple of <span class="number">512</span> bits</span><br><span class="line"></span><br><span class="line">Process the message in successive <span class="number">512</span>-bit chunks:</span><br><span class="line"><span class="keyword">break</span> message into <span class="number">512</span>-bit chunks</span><br><span class="line"><span class="keyword">for</span> each chunk</span><br><span class="line">    create a <span class="number">64</span>-entry message schedule <span class="built_in">array</span> w[<span class="number">0.</span><span class="number">.63</span>] of <span class="number">32</span>-bit words</span><br><span class="line">    (The initial values in w[<span class="number">0.</span><span class="number">.63</span>] don't matter, so many implementations zero them here)</span><br><span class="line">    copy chunk into first <span class="number">16</span> words w[<span class="number">0.</span><span class="number">.15</span>] of the message schedule <span class="built_in">array</span></span><br><span class="line"></span><br><span class="line">    Extend the first <span class="number">16</span> words into the remaining <span class="number">48</span> words w[<span class="number">16.</span><span class="number">.63</span>] of the message schedule <span class="built_in">array</span>:</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">16</span> to <span class="number">63</span></span><br><span class="line">        s0 := (w[i<span class="number">-15</span>] rightrotate  <span class="number">7</span>) xor (w[i<span class="number">-15</span>] rightrotate <span class="number">18</span>) xor (w[i<span class="number">-15</span>] rightshift  <span class="number">3</span>)</span><br><span class="line">        s1 := (w[i- <span class="number">2</span>] rightrotate <span class="number">17</span>) xor (w[i- <span class="number">2</span>] rightrotate <span class="number">19</span>) xor (w[i- <span class="number">2</span>] rightshift <span class="number">10</span>)</span><br><span class="line">        w[i] := w[i<span class="number">-16</span>] + s0 + w[i<span class="number">-7</span>] + s1</span><br><span class="line"></span><br><span class="line">    Initialize working variables to current hash value:</span><br><span class="line">    a := h0</span><br><span class="line">    b := h1</span><br><span class="line">    c := h2</span><br><span class="line">    d := h3</span><br><span class="line">    e := h4</span><br><span class="line">    f := h5</span><br><span class="line">    g := h6</span><br><span class="line">    h := h7</span><br><span class="line"></span><br><span class="line">    Compression function main loop:</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">0</span> to <span class="number">63</span></span><br><span class="line">        S1 := (e rightrotate <span class="number">6</span>) xor (e rightrotate <span class="number">11</span>) xor (e rightrotate <span class="number">25</span>)</span><br><span class="line">        ch := (e <span class="keyword">and</span> f) xor ((<span class="keyword">not</span> e) <span class="keyword">and</span> g)</span><br><span class="line">        temp1 := h + S1 + ch + k[i] + w[i]</span><br><span class="line">        S0 := (a rightrotate <span class="number">2</span>) xor (a rightrotate <span class="number">13</span>) xor (a rightrotate <span class="number">22</span>)</span><br><span class="line">        maj := (a <span class="keyword">and</span> b) xor (a <span class="keyword">and</span> c) xor (b <span class="keyword">and</span> c)</span><br><span class="line">        temp2 := S0 + maj</span><br><span class="line"> </span><br><span class="line">        h := g</span><br><span class="line">        g := f</span><br><span class="line">        f := e</span><br><span class="line">        e := d + temp1</span><br><span class="line">        d := c</span><br><span class="line">        c := b</span><br><span class="line">        b := a</span><br><span class="line">        a := temp1 + temp2</span><br><span class="line"></span><br><span class="line">    Add the compressed chunk to the current hash value:</span><br><span class="line">    h0 := h0 + a</span><br><span class="line">    h1 := h1 + b</span><br><span class="line">    h2 := h2 + c</span><br><span class="line">    h3 := h3 + d</span><br><span class="line">    h4 := h4 + e</span><br><span class="line">    h5 := h5 + f</span><br><span class="line">    h6 := h6 + g</span><br><span class="line">    h7 := h7 + h</span><br><span class="line"></span><br><span class="line">Produce the final hash value (big-endian):</span><br><span class="line">digest := hash := h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7</span><br></pre></td></tr></table></figure><h1 id="SHA256代码实现"><a href="#SHA256代码实现" class="headerlink" title="SHA256代码实现"></a>SHA256代码实现</h1><p>下面是基于上述伪代码用<code>go</code>语言对SHA256进行的实现. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/binary"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wikiSha256</span><span class="params">(message []<span class="keyword">byte</span>)</span> [32]<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始哈希值</span></span><br><span class="line">h0 := <span class="keyword">uint32</span>(<span class="number">0x6a09e667</span>)</span><br><span class="line">h1 := <span class="keyword">uint32</span>(<span class="number">0xbb67ae85</span>)</span><br><span class="line">h2 := <span class="keyword">uint32</span>(<span class="number">0x3c6ef</span>372)</span><br><span class="line">h3 := <span class="keyword">uint32</span>(<span class="number">0xa54ff</span>53a)</span><br><span class="line">h4 := <span class="keyword">uint32</span>(<span class="number">0x510e527f</span>)</span><br><span class="line">h5 := <span class="keyword">uint32</span>(<span class="number">0x9b05688c</span>)</span><br><span class="line">h6 := <span class="keyword">uint32</span>(<span class="number">0x1f83d</span>9ab)</span><br><span class="line">h7 := <span class="keyword">uint32</span>(<span class="number">0x5be0cd</span>19)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算过程当中用到的常数</span></span><br><span class="line">k := [<span class="number">64</span>]<span class="keyword">uint32</span>&#123;</span><br><span class="line">                <span class="number">0x428a2f</span>98, <span class="number">0x71374491</span>, <span class="number">0xb5c0fbcf</span>, <span class="number">0xe9b5d</span>ba5, <span class="number">0x3956c25b</span>, <span class="number">0x59f111f</span>1, <span class="number">0x923f</span>82a4, <span class="number">0xab1c5ed</span>5,</span><br><span class="line"><span class="number">0xd807aa98</span>, <span class="number">0x12835b01</span>, <span class="number">0x243185be</span>, <span class="number">0x550c7d</span>c3, <span class="number">0x72be5d</span>74, <span class="number">0x80deb1f</span>e, <span class="number">0x9bd</span>c06a7, <span class="number">0xc19bf</span>174,</span><br><span class="line"><span class="number">0xe49b69c1</span>, <span class="number">0xef</span>be4786, <span class="number">0x0fc19d</span>c6, <span class="number">0x240ca1cc</span>, <span class="number">0x2de92c6f</span>, <span class="number">0x4a7484aa</span>, <span class="number">0x5cb0a9d</span>c, <span class="number">0x76f988d</span>a,</span><br><span class="line"><span class="number">0x983e5152</span>, <span class="number">0xa831c66d</span>, <span class="number">0xb00327c8</span>, <span class="number">0xbf597f</span>c7, <span class="number">0xc6e00bf</span>3, <span class="number">0xd5a79147</span>, <span class="number">0x06ca6351</span>, <span class="number">0x14292967</span>,</span><br><span class="line"><span class="number">0x27b70a85</span>, <span class="number">0x2e1b2138</span>, <span class="number">0x4d2c6df</span>c, <span class="number">0x53380d</span>13, <span class="number">0x650a7354</span>, <span class="number">0x766a0abb</span>, <span class="number">0x81c2c92e</span>, <span class="number">0x92722c85</span>,</span><br><span class="line"><span class="number">0xa2bf</span>e8a1, <span class="number">0xa81a664b</span>, <span class="number">0xc24b8b70</span>, <span class="number">0xc76c51a3</span>, <span class="number">0xd192e819</span>, <span class="number">0xd6990624</span>, <span class="number">0xf40e3585</span>, <span class="number">0x106aa070</span>,</span><br><span class="line"><span class="number">0x19a4c116</span>, <span class="number">0x1e376c08</span>, <span class="number">0x2748774c</span>, <span class="number">0x34b0bcb5</span>, <span class="number">0x391c0cb3</span>, <span class="number">0x4ed</span>8aa4a, <span class="number">0x5b9cca4f</span>, <span class="number">0x682e6ff</span>3,</span><br><span class="line"><span class="number">0x748f</span>82ee, <span class="number">0x78a5636f</span>, <span class="number">0x84c87814</span>, <span class="number">0x8cc70208</span>, <span class="number">0x90befff</span>a, <span class="number">0xa4506ceb</span>, <span class="number">0xbef9a3f</span>7, <span class="number">0xc67178f</span>2&#125;</span><br><span class="line">    </span><br><span class="line">padded := <span class="built_in">append</span>(message, <span class="number">0x80</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(padded) % <span class="number">64</span> &lt; <span class="number">56</span> &#123;</span><br><span class="line">suffix := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">56</span> - (<span class="built_in">len</span>(padded) % <span class="number">64</span>))</span><br><span class="line">padded = <span class="built_in">append</span>(padded, suffix...)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">suffix := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">64</span> + <span class="number">56</span> - (<span class="built_in">len</span>(padded) % <span class="number">64</span>))</span><br><span class="line">padded = <span class="built_in">append</span>(padded, suffix...)</span><br><span class="line">&#125;</span><br><span class="line">msgLen := <span class="built_in">len</span>(message) * <span class="number">8</span></span><br><span class="line">bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">binary.BigEndian.PutUint64(bs, <span class="keyword">uint64</span>(msgLen))</span><br><span class="line">padded = <span class="built_in">append</span>(padded, bs...)</span><br><span class="line"></span><br><span class="line">broken := [][]<span class="keyword">byte</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(padded) / <span class="number">64</span>; i++ &#123;</span><br><span class="line">broken = <span class="built_in">append</span>(broken, padded[i * <span class="number">64</span>: i * <span class="number">64</span> + <span class="number">63</span>])</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主循环</span></span><br><span class="line"><span class="keyword">for</span> _, chunk := <span class="keyword">range</span> broken &#123;</span><br><span class="line">w := []<span class="keyword">uint32</span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">w = <span class="built_in">append</span>(w, binary.BigEndian.Uint32(chunk[i * <span class="number">4</span>:i * <span class="number">4</span> + <span class="number">4</span>]))</span><br><span class="line">&#125;</span><br><span class="line">w = <span class="built_in">append</span>(w, <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="number">48</span>)...)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//W消息区块处理</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">16</span>; i &lt; <span class="number">64</span>; i++ &#123;</span><br><span class="line">s0 := rightRotate(w[i - <span class="number">15</span>], <span class="number">7</span>) ^ rightRotate(w[i - <span class="number">15</span>], <span class="number">18</span>) ^ (w[i - <span class="number">15</span>] &gt;&gt; <span class="number">3</span>)</span><br><span class="line">s1 := rightRotate(w[i - <span class="number">2</span>], <span class="number">17</span>) ^ rightRotate(w[i - <span class="number">2</span>], <span class="number">19</span>) ^ (w[i - <span class="number">2</span>] &gt;&gt; <span class="number">10</span>)</span><br><span class="line">w[i] = w[i - <span class="number">16</span>] + s0 + w[i - <span class="number">7</span>] + s1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := h0</span><br><span class="line">b := h1</span><br><span class="line">c := h2</span><br><span class="line">d := h3</span><br><span class="line">e := h4</span><br><span class="line">f := h5</span><br><span class="line">g := h6</span><br><span class="line">h := h7</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//应用SHA256压缩函数更新a,b,...,h</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">64</span>; i++ &#123;</span><br><span class="line">S1 := rightRotate(e, <span class="number">6</span>) ^ rightRotate(e, <span class="number">11</span>) ^ rightRotate(e, <span class="number">25</span>)</span><br><span class="line">ch := (e &amp; f) ^ ((^e) &amp; g)</span><br><span class="line">temp1 := h + S1 + ch + k[i] + w[i]</span><br><span class="line">S0 := rightRotate(a, <span class="number">2</span>) ^ rightRotate(a, <span class="number">13</span>) ^ rightRotate(a, <span class="number">22</span>)</span><br><span class="line">maj := (a &amp; b) ^ (a &amp; c) ^ (b &amp; c)</span><br><span class="line">temp2 := S0 + maj</span><br><span class="line"></span><br><span class="line">h = g</span><br><span class="line">g = f</span><br><span class="line">f = e</span><br><span class="line">e = d + temp1</span><br><span class="line">d = c</span><br><span class="line">c = b</span><br><span class="line">b = a</span><br><span class="line">a = temp1 + temp2</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">h0 = h0 + a</span><br><span class="line">h1 = h1 + b</span><br><span class="line">h2 = h2 + c</span><br><span class="line">h3 = h3 + d</span><br><span class="line">h4 = h4 + e</span><br><span class="line">h5 = h5 + f</span><br><span class="line">h6 = h6 + g</span><br><span class="line">h7 = h7 + h</span><br><span class="line">&#125;</span><br><span class="line">hashBytes := [][]<span class="keyword">byte</span>&#123;iToB(h0), iToB(h1), iToB(h2), iToB(h3), iToB(h4), iToB(h5), iToB(h6), iToB(h7)&#125;</span><br><span class="line">hash := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">hashArray := [<span class="number">32</span>]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ &#123;</span><br><span class="line">hash = <span class="built_in">append</span>(hash, hashBytes[i]...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(hashArray[:], hash[<span class="number">0</span>:<span class="number">32</span>])</span><br><span class="line"><span class="keyword">return</span> hashArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">iToB</span><span class="params">(i <span class="keyword">uint32</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">binary.BigEndian.PutUint32(bs, i)</span><br><span class="line"><span class="keyword">return</span> bs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环右移函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightRotate</span><span class="params">(n <span class="keyword">uint32</span>, d <span class="keyword">uint</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (n &gt;&gt; d) | (n &lt;&lt; (<span class="number">32</span> - d))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zh.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener">SHA-2中文</a></li><li><a href="http://www.iwar.org.uk/comsec/resources/cipher/sha256-384-512.pdf" target="_blank" rel="noopener">Descriptions of SHA-256, SHA-384, and SHA-512</a></li><li><a href="https://en.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener">SHA-2英文</a></li></ul>]]></content>
    
    <summary type="html">
    
      学习区块链，总是无法避开各种加密算法，因为各种加密算法在实现区块链当中的各个环节都有着不可替代的作用。这里介绍一下在比特币挖矿以及merkle树当中被大量使用的鼎鼎大名的SHA256算法。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="加密算法" scheme="http://datacruiser.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="比特币" scheme="http://datacruiser.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="go语言" scheme="http://datacruiser.io/tags/go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>72. 编辑距离</title>
    <link href="http://datacruiser.io/2019/11/21/72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://datacruiser.io/2019/11/21/72-编辑距离/</id>
    <published>2019-11-21T16:48:35.000Z</published>
    <updated>2020-01-31T14:37:28.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定两个单词 $word1$ 和 $word2$，计算出将 $word1$ 转换成 $word2$ 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 <span class="string">'h'</span> 替换为 <span class="string">'r'</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">'r'</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: word1 = <span class="string">"intention"</span>, word2 = <span class="string">"execution"</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: </span><br><span class="line">intention -&gt; inention (删除 <span class="string">'t'</span>)</span><br><span class="line">inention -&gt; enention (将 <span class="string">'i'</span> 替换为 <span class="string">'e'</span>)</span><br><span class="line">enention -&gt; exention (将 <span class="string">'n'</span> 替换为 <span class="string">'x'</span>)</span><br><span class="line">exention -&gt; exection (将 <span class="string">'n'</span> 替换为 <span class="string">'c'</span>)</span><br><span class="line">exection -&gt; execution (插入 <span class="string">'u'</span>)</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">72. edit distance</a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>编辑距离问题就是给我们两个字符串<code>word1</code>和<code>word2</code>，只能用三种操作，让我们把<code>word1</code>变成<code>word2</code>，求最少的操作数。需要明确的是，不管是把<code>word1</code>变成<code>word2</code>，还是反过来，结果都是一样的。</p><p>我们用<code>i,j</code>分别指针表示两个字符串中字符的位置，对于当前比较的两个字符 <code>word1[i]</code> 和 <code>word2[j]</code>，若二者相同，一切好说，直接跳到下一个位置，这其实也是一种处理的方式。若不相同，有三种处理方法，首先是直接插入一个<code>word2[j]</code>，那么<code>word2[j]</code> 位置的字符就跳过了，接着比较<code>word1[i]</code> 和 <code>word2[j+1]</code> 即可。第二个种方法是删除，即将<code>word1[i]</code> 字符直接删掉，接着比较<code>word1[i+1]</code> 和 <code>word2[j]</code> 即可。第三种则是将<code>word1[i]</code> 修改为 <code>word2[j]</code>，接着比较 <code>word1[i+1]</code> 和<code>word[j+1]</code> 即可。</p><p>这样可以写出递归的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">( <span class="keyword">int</span> num )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">char</span>* word1, <span class="keyword">char</span>* word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(word1) == <span class="number">0</span> || <span class="built_in">strlen</span>(word2) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>((<span class="keyword">int</span>)<span class="built_in">strlen</span>(word1) - (<span class="keyword">int</span>)<span class="built_in">strlen</span>(word2));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(word1[<span class="number">0</span>] == word2[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> minDistance(word1 + <span class="number">1</span>, word2 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> insertCnt = minDistance(word1, word2 + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> deleteCnt = minDistance(word1 + <span class="number">1</span>, word2) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> replaceCnt = minDistance(word1 + <span class="number">1</span>, word2 + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min(min(insertCnt,deleteCnt),replaceCnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是很可惜，这个代码会超时，所以必须要优化时间复杂度，需要去掉大量的重复计算，根据之前的套路，可以采用记忆数组<code>memo</code>来保存计算过的状态，可以考虑声明一个全局变量，并将其值都初始化为-1，具体解法见解法一。</p><p>根据以往的经验，对于字符串相关的题目且求极值的问题，十有八九都是用动态规划<code>Dynamic Programming</code> 来解，这道题也不例外。其实解法一的递归加记忆数组的方法也可以看作是<code>DP</code>的递归写法。这里需要维护一个二维的数组<code>dp</code>，其大小为<code>m \times n</code>，<code>m</code>和<code>n</code>分别为<code>word1</code> 和<code>word2</code> 的长度。<code>dp[i][j]</code> 表示从<code>word1</code>的前<code>i</code>个字符转换到<code>word2</code> 的前<code>j</code>个字符所需要的步骤。先给这个二维数组<code>dp</code> 的第一行第一列赋值，这个很简单，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤完全是另一个字符串的长度。跟以往的<code>DP</code> 题目类似，难点还是在于找出状态转移方程，可以举个例子来看，比如<code>word1</code> 是 “bbc”，<code>word2</code> 是 “abcd”，可以得到<code>dp</code> 数组如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  Ø a b c d</span><br><span class="line">Ø <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">b <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">b <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">c <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>通过观察可以发现，当 <code>word1[i] == word2[j]</code> 时，<code>dp[i][j] = dp[i - 1][j - 1]</code>，其他情况时，<code>dp[i][j]</code> 是其左，左上，上的三个值中的最小值加1，其实这里的左，上，和左上，分别对应的增加，删除，修改操作，具体可以参见解法一种的讲解部分，那么可以得到状态转移方程为：</p><p>$$<br>dp[i][j]=\left\{<br>\begin{array}{rcl}<br>dp[i-1][j-1] &amp; &amp; if \,\, word1[i-1] == word2[j - 1]\\<br>min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1 &amp; &amp; else<br>\end{array} \right.<br>$$</p><p>具体代码见解法二。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="解法一：递归-记忆数组"><a href="#解法一：递归-记忆数组" class="headerlink" title="解法一：递归+记忆数组"></a>解法一：递归+记忆数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明memo为全局变量</span></span><br><span class="line"><span class="keyword">int</span>** memo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span> *word1, <span class="keyword">char</span> *word2, <span class="keyword">int</span> len1, <span class="keyword">int</span> len2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> target1 = <span class="built_in">strlen</span>(word1);</span><br><span class="line">    <span class="keyword">int</span> target2 = <span class="built_in">strlen</span>(word2);</span><br><span class="line">    <span class="keyword">int</span> minmum = MAXNUM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">0</span> &amp;&amp; len2 == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(word1, word2, len1, len2 - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(len1 &gt; <span class="number">0</span> &amp;&amp; len2 == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(word1, word2, len1 - <span class="number">1</span>, len2) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(memo[len1][len2] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[len1][len2];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(word1[target1 - len1] ==  word2[target2 - len2]) </span><br><span class="line">    &#123;</span><br><span class="line">        minmum = helper(word1, word2, len1 - <span class="number">1</span>, len2 - <span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        minmum =  min(minmum, helper(word1, word2, len1, len2 - <span class="number">1</span>) + <span class="number">1</span>);      <span class="comment">//insert</span></span><br><span class="line">        minmum =  min(minmum, helper(word1, word2, len1 - <span class="number">1</span>, len2 - <span class="number">1</span>) + <span class="number">1</span>);  <span class="comment">//replace</span></span><br><span class="line">        minmum = min(minmum, helper(word1, word2, len1 - <span class="number">1</span>, len2) + <span class="number">1</span>);      <span class="comment">//delete</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> memo[len1][len2] = minmum;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">char</span> * word1, <span class="keyword">char</span> * word2)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    memo = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>((<span class="built_in">strlen</span>(word1) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(word1) + <span class="number">1</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        memo[i] = <span class="built_in">malloc</span>((<span class="built_in">strlen</span>(word2) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(word1) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(word2) + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            memo[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(word1, word2, <span class="built_in">strlen</span>(word1), <span class="built_in">strlen</span>(word2));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">char</span> * word1, <span class="keyword">char</span> * word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(word1);</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(word2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> **dp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * (len1 + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (len2 + <span class="number">1</span>));</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len2; j++) </span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> len2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len2 == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> len1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/" target="_blank" rel="noopener">编辑距离面试题详解</a></li><li><a href="https://www.cnblogs.com/grandyang/p/4344107.html" target="_blank" rel="noopener">[LeetCode] 72. Edit Distance 编辑距离</a></li></ul>]]></content>
    
    <summary type="html">
    
      LeetCode刷题系列。
    
    </summary>
    
      <category term="Leetcode" scheme="http://datacruiser.io/categories/Leetcode/"/>
    
      <category term="Leetcode TOP 100" scheme="http://datacruiser.io/categories/Leetcode-TOP-100/"/>
    
    
      <category term="数据结构" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://datacruiser.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C语言" scheme="http://datacruiser.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="字符串" scheme="http://datacruiser.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="动态规划" scheme="http://datacruiser.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>区块链核心技术及应用场景简介</title>
    <link href="http://datacruiser.io/2019/11/12/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%AE%80%E4%BB%8B/"/>
    <id>http://datacruiser.io/2019/11/12/区块链核心技术及应用场景简介/</id>
    <published>2019-11-12T21:20:25.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链发展历史"><a href="#区块链发展历史" class="headerlink" title="区块链发展历史"></a>区块链发展历史</h1><h2 id="Gartner历年新兴科技技术成熟度曲线"><a href="#Gartner历年新兴科技技术成熟度曲线" class="headerlink" title="Gartner历年新兴科技技术成熟度曲线"></a>Gartner历年新兴科技技术成熟度曲线</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%203%2011%3A12%3A2019.png" alt=""><br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%204%2011%3A12%3A2019.png" alt=""><br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%205%2011%3A12%3A2019.png" alt=""><br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%206%2011%3A12%3A2019.png" alt=""></p><h2 id="区块链发展大事记"><a href="#区块链发展大事记" class="headerlink" title="区块链发展大事记"></a>区块链发展大事记</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%207%2011%3A12%3A2019.png" alt=""></p><h1 id="区块链技术概述"><a href="#区块链技术概述" class="headerlink" title="区块链技术概述"></a>区块链技术概述</h1><h2 id="区块链定义"><a href="#区块链定义" class="headerlink" title="区块链定义"></a>区块链定义</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%208%2011%3A12%3A2019.png" alt=""></p><h2 id="区块链分代"><a href="#区块链分代" class="headerlink" title="区块链分代"></a>区块链分代</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%209%2011%3A12%3A2019.png" alt=""></p><h2 id="区块链分类"><a href="#区块链分类" class="headerlink" title="区块链分类"></a>区块链分类</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2010%2011%3A12%3A2019.png" alt=""></p><h2 id="记账流程"><a href="#记账流程" class="headerlink" title="记账流程"></a>记账流程</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2011%2011%3A12%3A2019.png" alt=""><br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2012%2011%3A12%3A2019.png" alt=""></p><h2 id="“双花”及51-攻击"><a href="#“双花”及51-攻击" class="headerlink" title="“双花”及51%攻击"></a>“双花”及51%攻击</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2013%2011%3A12%3A2019.png" alt=""></p><h1 id="区块链核心技术"><a href="#区块链核心技术" class="headerlink" title="区块链核心技术"></a>区块链核心技术</h1><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2014%2011%3A12%3A2019.png" alt=""></p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2015%2011%3A12%3A2019.png" alt=""><br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2016%2011%3A12%3A2019.png" alt=""></p><h2 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2017%2011%3A12%3A2019.png" alt=""></p><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2018%2011%3A12%3A2019.png" alt=""></p><h2 id="区块链式结构"><a href="#区块链式结构" class="headerlink" title="区块链式结构"></a>区块链式结构</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2019%2011%3A12%3A2019.png" alt=""></p><h2 id="比特币区块举例"><a href="#比特币区块举例" class="headerlink" title="比特币区块举例"></a>比特币区块举例</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2020%2011%3A12%3A2019.png" alt=""><br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2021%2011%3A12%3A2019.png" alt=""></p><h2 id="节点共识算法"><a href="#节点共识算法" class="headerlink" title="节点共识算法"></a>节点共识算法</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2022%2011%3A12%3A2019.png" alt=""><br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2023%2011%3A12%3A2019.png" alt=""><br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2024%2011%3A12%3A2019.png" alt=""><br><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2025%2011%3A12%3A2019.png" alt=""></p><h2 id="共识算法对比"><a href="#共识算法对比" class="headerlink" title="共识算法对比"></a>共识算法对比</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2026%2011%3A12%3A2019.png" alt=""></p><h1 id="区块链架构分析"><a href="#区块链架构分析" class="headerlink" title="区块链架构分析"></a>区块链架构分析</h1><h2 id="基础架构模型"><a href="#基础架构模型" class="headerlink" title="基础架构模型"></a>基础架构模型</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2027%2011%3A12%3A2019.png" alt=""></p><h2 id="1-0比特币架构"><a href="#1-0比特币架构" class="headerlink" title="1.0比特币架构"></a>1.0比特币架构</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2028%2011%3A12%3A2019.png" alt=""></p><h2 id="2-0以太坊架构"><a href="#2-0以太坊架构" class="headerlink" title="2.0以太坊架构"></a>2.0以太坊架构</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2029%2011%3A12%3A2019.png" alt=""></p><h2 id="3-0跨行业架构"><a href="#3-0跨行业架构" class="headerlink" title="3.0跨行业架构"></a>3.0跨行业架构</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2030%2011%3A12%3A2019.png" alt=""></p><h2 id="京东区块链架构"><a href="#京东区块链架构" class="headerlink" title="京东区块链架构"></a>京东区块链架构</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2031%2011%3A12%3A2019.png" alt=""></p><h2 id="腾讯区块链架构"><a href="#腾讯区块链架构" class="headerlink" title="腾讯区块链架构"></a>腾讯区块链架构</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2032%2011%3A12%3A2019.png" alt=""></p><h1 id="区块链应用场景"><a href="#区块链应用场景" class="headerlink" title="区块链应用场景"></a>区块链应用场景</h1><h2 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2033%2011%3A12%3A2019.png" alt=""></p><h2 id="“区块链-”产业图景"><a href="#“区块链-”产业图景" class="headerlink" title="“区块链+”产业图景"></a>“区块链+”产业图景</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2034%2011%3A12%3A2019.png" alt=""></p><h2 id="能源区块链-碳排放权认证"><a href="#能源区块链-碳排放权认证" class="headerlink" title="能源区块链-碳排放权认证"></a>能源区块链-碳排放权认证</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2035%2011%3A12%3A2019.png" alt=""></p><h2 id="能源区块链-虚拟发电资源交易系统"><a href="#能源区块链-虚拟发电资源交易系统" class="headerlink" title="能源区块链-虚拟发电资源交易系统"></a>能源区块链-虚拟发电资源交易系统</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2036%2011%3A12%3A2019.png" alt=""></p><h2 id="中国人民银行DECP"><a href="#中国人民银行DECP" class="headerlink" title="中国人民银行DECP"></a>中国人民银行DECP</h2><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2037%2011%3A12%3A2019.png" alt=""></p><h1 id="区块链产业政策"><a href="#区块链产业政策" class="headerlink" title="区块链产业政策"></a>区块链产业政策</h1><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2038%2011%3A12%3A2019.png" alt=""></p><h1 id="区块链总结展望"><a href="#区块链总结展望" class="headerlink" title="区块链总结展望"></a>区块链总结展望</h1><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain_introduction/BlockChain%20Presentation%2039%2011%3A12%3A2019.png" alt=""></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.gartner.com/en" target="_blank" rel="noopener">Gartner 历年新兴科技趋势图</a></li><li><a href="https://blockexplorer.com/" target="_blank" rel="noopener">blockexplorer</a></li><li><a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">比特币白皮书</a></li><li><a href="https://github.com/ethereum/wiki/wiki/White-Paper" target="_blank" rel="noopener">以太坊白皮书</a></li><li><a href="https://trustsql.qq.com/chain_oss/TrustSQL_WhitePaper.html" target="_blank" rel="noopener">2019 腾讯区块链白皮书</a></li><li><a href="http://www.cbdio.com/image/site2/20190411/f4285315404f1e19523705.pdf" target="_blank" rel="noopener">京东区块链技术实践白皮书（2019）</a></li><li><a href="http://www.aas.net.cn/CN/article/downloadArticleFile.do?attachType=PDF&amp;id=18837" target="_blank" rel="noopener">袁勇, 王飞跃. 区块链技术发展现状与展望[J]. 自动化学报, 2016, 42(4): 481-494</a></li><li>张亮, 刘百祥, 张如意等. 区块链技术综述[J]. 计算机工程, 2019, 45(5): 1-12</li><li>张宁, 王毅, 康重庆等. 能源互联网中的区块链技术：研究框架与典型应用初探[J]. 中国电机工程学报, 2016, 36(15): 4011-4022</li><li><a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf" target="_blank" rel="noopener">Blockchain Technology Overview. NIST. 2018</a></li><li><a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Blockchain</a></li><li><a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merkle_tree</a></li><li><a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hashcash</a></li><li><a href="https://nvlpubs.nist.gov/nistpubs/ir/2018/NIST.IR.8202.pdf" target="_blank" rel="noopener">2018 年中国区块链产业白皮书</a></li><li><a href="https://www.amazon.cn/dp/B071K7FCD4/ref=sr_1_1?keywords=Mastering+Bitcoin&amp;qid=1572521851&amp;sr=8-1" target="_blank" rel="noopener">Andreas M. Antonopoulos, Mastering Bitcoin, 2nd Edition, O•REILLY®, 2017</a></li><li><a href="https://www.searchain.net/news/264496.html" target="_blank" rel="noopener">研报 | 初探中国央行数字货币：目标、定位、机制与影响</a></li></ul>]]></content>
    
    <summary type="html">
    
      最近公司内部组织了一场知识分享，在轮到本人进行分享的前夕正好区块链技术又一次被推到了风口，而且是官选的那种，并不是之前各种投机炒客言语当中的风口。因为两年前决定转行的时候也曾经将区块链作为潜在的转行方向，当时花了一些时间和精力对区块链的底层技术进行了一些研究，于是心想可以将区块链作为一个知识分享的主题。重新将之前研究过的内容进行整理和更新，并且做了几张片子，分享的效果还不错，很多同学终于搞明白了“挖矿”是怎么一会儿，工作量证明是怎么一回事，比特币和区块链到底是什么关系等等。因为演讲是一个现场发挥的过程，当时也没有录音，这里文字内部就暂时不放了，直接将片子放出来，大家如果有什么问题或者疑问需要探讨的欢迎邮件联系。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="比特币" scheme="http://datacruiser.io/categories/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    
      <category term="区块链" scheme="http://datacruiser.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="非对称加密" scheme="http://datacruiser.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="比特币" scheme="http://datacruiser.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="共识算法" scheme="http://datacruiser.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
      <category term="DoW" scheme="http://datacruiser.io/tags/DoW/"/>
    
      <category term="DoS" scheme="http://datacruiser.io/tags/DoS/"/>
    
      <category term="能源区块链" scheme="http://datacruiser.io/tags/%E8%83%BD%E6%BA%90%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>什么是闪电网络及如何试用-翻译</title>
    <link href="http://datacruiser.io/2019/11/09/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%A6%82%E4%BD%95%E8%AF%95%E7%94%A8-%E7%BF%BB%E8%AF%91/"/>
    <id>http://datacruiser.io/2019/11/09/什么是闪电网络及如何试用-翻译/</id>
    <published>2019-11-09T15:46:33.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍-Introduction"><a href="#介绍-Introduction" class="headerlink" title="介绍 Introduction"></a>介绍 Introduction</h1><p>当比特币网络开始处理越来越多的交易的时候，网络的不可扩展性变得越来越凸显起来：区块的大小限制为1Mb，随着交易数量的不断增长，总有一天会打破这个限制，然后交易池中的待打包的交易会增长然后导致大量交易被延后处理。关于扩展性，人们基于原来比特币的实现，克隆了很多不同的解决方案，致力于构建切实可扩展的一个区块链。其中一种是Bitcoin Cash，通过将区块大小提高到8Mb来解决扩展性问题，并且后续根据需要继续提高区块的大小。</p><p>比特币核心开发者也知道这一问题的存在并且不停地寻找一个合适的解决方案。简单地增加区块大小可能不是一个很好的解决方案，因为这样会增加个人运行节点的难度，可能只有大公司才能够负担得起。并且，更大的区块也只能是一个临时的解决方案：在以后，当比特币被更加广泛地采用地时候，区块大小需要再次增加。这会造成区块链越来越中心化。</p><p>2017年8月24日，隔离见证（Segregated Witness）在比特币主网中被激活。虽然它的主要目的不是提升扩展性，而是<a href="https://en.bitcoin.it/wiki/Transaction_malleability" target="_blank" rel="noopener">交易的便捷性</a>，但是隔离见证也确确实实提升了扩展性。隔离见证通过将发送者和接收者信息移到交易当中不需要验证的一个隔离域（见证）而对交易数据进行了重构（可以访问<a href="https://techtake.info/2017/08/22/segwit-bitcoincash-technical-details-explained/" target="_blank" rel="noopener">这里</a>查看更加详细的解释），也对区块大小的计算进行了修改：隔离见证域的数据不计入区块大小当中。于是，这个变相地对交易进行了减负，现在一个区块可以存放更多的交易记录了。</p><blockquote><p>这样的副作用是，所有通过隔离见证地址发出去的交易需要更小的交易费用，因为交易费用的大小和交易大小相关</p></blockquote><p>不管是隔离见证还是更大的区块容量，都需要对区块链进行修改，可以称之为“on-chain”。与其相反的方法，不需要对区块链进行修改，可以称为“off-chain”。需要创建一个依附于区块链并提高其性能而不对它进行修改的系统。本文的主要话题，闪电网络（Lightning Network），就是一个off-chain比特币扩容解决方案。</p><h1 id="闪电网络如何工作-How-does-Lightning-Network-work"><a href="#闪电网络如何工作-How-does-Lightning-Network-work" class="headerlink" title="闪电网络如何工作 How does Lightning Network work?"></a>闪电网络如何工作 How does Lightning Network work?</h1><p>闪电网络（LN）的目的是在不修改区块链且不进行分叉的前提下提高比特币网络的吞吐量。主要思路是创建一个“second layer”进行交易的转移。关键在于在second layer上面进行的交易不需要支付交易费用，并且不需要等到新的区块被挖到以后才能够进行记录。在闪电网络上面可以：</p><ul><li>建立与其它个人、公司或者服务机构的支付通道</li><li>通过这些支付通道<strong>免费且及时</strong>完成交易，这是彻底解决扩展性的关键</li></ul><p>下面让我们详细看看这些点。</p><p>作为一个软件，闪电网络是一个节点，就像普通的比特币节点一样。为了运行闪电网络，需要一个完全同步的比特币节点，因为闪电网络需要依附于比特币网络和区块链。支付通道的建立整合到了比特币网络当中：当一个通道建立时，一个特殊类型的交易将会创建并且被发送到比特币网络当中。这个交易将会<strong>锁定打开该通道的一方特定数量的比特币</strong>, 然后关键的事情来了: 当你打开一个通道, 你需要锁定你可能要花费的比特币的最大值. 你不必将这些比特币都花掉, 但是最好提前预估你需要花费的比特币, 因为开通建立通道并不是免费的. 在通道中锁定一定的资金可以确保消费者立马就有资金可以消费.</p><blockquote><p>正如名字所展示的, 闪电网络是一个网络: 所有的节点可以互相连接形成一个网络. 与其它节点相连意味着打开了一个新的通道. </p></blockquote><p>当一个通道打开建立的时候, 意味着已经没有必要再通过比特币网络进行交易的发送和处理, 因为现在可以通过second layer, 即闪电网络进行交易的发送和处理. 通过闪电网络发送和处理交易是免费且即时的, 如果不考虑通道本身开通的费用的话. </p><p>当你有对其它节点打开的通道, 你可以通过以下两种方式发送BTC: </p><ul><li>直接向特定节点发送</li><li>间接向与特定节点连接的其它节点先发送</li></ul><p>第二种场景可能更为普通和基础. 想象一下, 一个支付中心: 一个与大量其它服务和产品提供商有通道连接的节点. 你不必与每一个服务和产品提供商建立通道连接, 你只要与那个中心点建立连接然后进行间接支付就可以了. </p><p><img src="https://jeiwan.net/images/ln-topology-hubs2.png" alt=""></p><p>这种使用方式也是最容易引起争议的: 当有这样的节点存在的时候也就意味着网络出现了中心化; 大量的用户节点将依存于少量提供支付服务的中心节点. 从这个角度看, 这是闪电网络遭受批评的所在. </p><p>下面让我们来试一下闪电网络. </p><h1 id="运行闪电网络节点-Running-Lightning-Network-node"><a href="#运行闪电网络节点-Running-Lightning-Network-node" class="headerlink" title="运行闪电网络节点 Running Lightning Network node"></a>运行闪电网络节点 Running Lightning Network node</h1><p>2018年2月份, 闪电网络在比特币测试网络成功部署和测试. 闪电网络也一并在主网完成了部署, 但是严重不推荐现在在主网使用闪电网络, 因为它依然不够稳定. 丢失比特币的风险非常高。由于我们不希望遇到那样的情况，我们仅在测试网络上面进行使用。</p><ul><li>首先，我们需要一个与比特币测试网连接并全量同步的节点，我们使用比特币核心节点，可以从<a href="https://bitcoin.org/en/wallets/desktop/windows/bitcoincore/" target="_blank" rel="noopener">https://bitcoin.org/en/wallets/desktop/windows/bitcoincore/</a>下载</li><li>然后，在未进行人工干预的情况下，比特币核心节点会连接到主网并进行同步，然后这并不是我们想要的</li><li>不要傻傻等待同步完成，直接打开Settings，然后点击Open Configuration File 按钮</li><li>一个有着比特币默认配置的文本编辑器会被打开。然后用以下文本进行更新：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">testnet=<span class="number">1</span></span><br><span class="line">server=<span class="number">1</span></span><br><span class="line">rpcuser=foo</span><br><span class="line">rpcpassword=bar</span><br><span class="line">txindex=<span class="number">1</span></span><br><span class="line">zmqpubrawblock=tcp:<span class="comment">//127.0.0.1:29000</span></span><br><span class="line">zmqpubrawtx=tcp:<span class="comment">//127.0.0.1:29000</span></span><br></pre></td></tr></table></figure><ul><li>这些设置会将比特币核心节点切换到测试网并对一些基本所需的设置进行配置。保存配置文件并重启节点。在重启以后，比特币核心节点的窗口会包含<code>[testnet]</code>，这意味着此时它已经连接到测试网。这个时候就可以等待数据同步完成。</li><li>同时，到<a href="https://github.com/ACINQ/eclair/releases" target="_blank" rel="noopener">https://github.com/ACINQ/eclair/releases</a>下载<code>Eclair</code>，一个由<code>ACINQ</code>开发的闪电网络客户端，在我们后面的实验当中会有用到。如果你想现在就使用<code>Eclair</code>，它会无法工作，因为比特币节点没有完全同步。因此，在同步完成以后再继续阅读。</li></ul><blockquote><p>在同步进行过程当中，你可以访问<a href="https://explorer.acinq.co/" target="_blank" rel="noopener">https://explorer.acinq.co/</a>，一个闪电网络拓扑关系可视化服务。它也会在世界地图当中展示节点位置，看起来非常有趣。</p></blockquote><ul><li>在节点同步完成以后，运行<code>Eclair</code>。它看起来是这样的（但是在你那里可能打开的通道可能还没有）</li></ul><p><img src="https://jeiwan.net/images/ln-eclair.png" alt=""></p><ul><li>左下角是你的节点标示（也一并注意右下角：TEST，意味着闪电网络的节点是附在比特币测试网络）。表格（所有的节点、通道）应该会有计数。如果没有出现计数，等几分钟直到当前节点获得节点和通道信息 </li><li>然后这就是了，现在可以有一个与比特币测试网络相连接且全量同步的准备就绪的比特币闪电网络节点</li></ul><h1 id="存入一些比特币-Depositing-some-BTC"><a href="#存入一些比特币-Depositing-some-BTC" class="headerlink" title="存入一些比特币 Depositing some BTC"></a>存入一些比特币 Depositing some BTC</h1><p>为了要转移一些比特币，显然，我们首先需要一些比特币，但是通过挖矿获得太不高效了。为了解决这个问题，有一个叫做<code>faucet</code>的服务，可以让你获得一些免费的币（这样的服务也在一些其它的区块链当中存在，不单单是比特币）。为了获得一些比特币，访问<a href="https://testnet.coinfaucet.eu/en/" target="_blank" rel="noopener">https://testnet.coinfaucet.eu/en/</a>然后输入你从比特币核心节点获得的地址。比特币会在下一个被挖到的区块当中进行发放，是的，在测试网当中也会有挖矿的存在，你可以通过<a href="https://live.blockcypher.com/btc-testnet/" target="_blank" rel="noopener">区块链浏览器</a>进行查看。</p><p>现在我们准备使用闪电网络。</p><h1 id="打开闪电网络通道-Opening-LN-channel"><a href="#打开闪电网络通道-Opening-LN-channel" class="headerlink" title="打开闪电网络通道 Opening LN channel"></a>打开闪电网络通道 Opening LN channel</h1><p>让我们从打开一个单一的闪电网络通道开始。</p><ul><li>访问我之前提到过的<a href="https://explorer.acinq.co/" target="_blank" rel="noopener">闪电网络浏览器</a>。在搜索栏里面输入<code>endurance</code>找到我们要去连接的节点。在节点信息窗，找到<code>Copy URI</code>链接然后点击，我们可以用这个URI连接到这个节点。</li><li>回到<code>Eclair</code>，点击<code>Channels</code>菜单，然后选择<code>Open</code>通道。粘贴节点<code>URI</code>到目标节点<code>URI</code>。在<code>Capacity</code>域里面，输入你想要在通道当中锁定的的币值数量（比如，你计划花费的币值的最大金额）。对我们的目的来说，100 millinBTC足够了。单击<code>Connect</code>来打开通道。</li><li>在本地的通道列表当中，会出现一个新的通道：</li></ul><p><img src="https://jeiwan.net/images/ln-eclair-channel.png" alt=""></p><ul><li>新通道的状态会很快改为<code>WAIT_FOR_FUNDING_CONFIRMED</code>，这意味着一个通过通道的交易已经创建且正在向比特币网络进行发送。现在你需要等待两个新的区块：一个包含当前交易然后另外一个对这笔交易进行确认。你也可以在之前提到的<a href="https://live.blockcypher.com/btc-testnet/" target="_blank" rel="noopener">区块链浏览器</a>对新区块进行跟踪。</li><li>一旦交易被挖到且确认，通道的状态会变更为<code>NORMAL</code>，这意味着通道已经创建完毕准备好接收闪电网络交易。</li></ul><h1 id="为比特币购买咖啡-Buying-coffee-for-Bitcoin"><a href="#为比特币购买咖啡-Buying-coffee-for-Bitcoin" class="headerlink" title="为比特币购买咖啡 Buying coffee for Bitcoin"></a>为比特币购买咖啡 Buying coffee for Bitcoin</h1><p>创建<code>Eclair</code>的公司，也创建了一个可以使用比特币的在线咖啡商店：<a href="https://starblocks.acinq.co/" target="_blank" rel="noopener">https://starblocks.acinq.co/</a>，然后我们会从这家商店通过闪电网络支付比特币购买咖啡。</p><p>闪电网络不允许在未取得地址所有者允许的情况下对任何地址进行随机的发送，这一点和比特币主网有所不同。愿意接收支付的一方需要创建一个<strong>收款需求</strong>，类似于发票的东西。然后接收方方将收款需求通过二维码、链接或者原始的方式传送给支付方，然后支付方通过一个能够读取需求的应用对需求进行读取和支付。</p><p>因此，为了购买一杯咖啡，我们需要：</p><ul><li>访问在线商城示例:<a href="https://starblocks.acinq.co/" target="_blank" rel="noopener">https://starblocks.acinq.co/</a></li><li>在购物车当中添加任何的咖啡然后进行结账。然后页面会展示一个二维码让你进行扫描，但是我们使用的是桌面版的闪电网络客户端，我们无法使用二维码。因此，我们需要原始的收款需求——在同一个页面以<strong>lnt</strong>开头的字符串——拷贝到缓冲区。大概看起来是这样的：</li></ul><p><img src="https://jeiwan.net/images/ln-payment-request.png" alt=""></p><ul><li>然后切换到<code>Eclair</code>，回到<code>Channel</code>菜单，选择<code>Send Payment</code>，然后将收款需求粘贴进去。<code>Eclair</code>会对需求进行解析然后抽取出一些有用信息（比如节点ID、支付hash、产品的名字以及价格等）。</li><li>不要急着点击<code>Send</code>！让我们先确认一些东西。在<code>Eclair</code>当中，找到我们所连接节点的ID，然后将它与你即将进行支付的节点ID进行比对。你会发现他们并不匹配！这是因为我们还未与要进行支付的节点之间建立起支付通道。</li><li>点击<code>Send</code>。。。然后支付成功。在通道中锁定的金额会减去咖啡的价格，然后在线商店的demo会显示一条支付成功的消息。在你和在线商城之间的通道还未建立起来的时候，这是怎么做到的呢？这就借助了一些中间节点，你连接了中间节点并与中间节点有通道，然后中间节点与商店之间也有通道打开。</li><li>然后回到闪电网络浏览器找到两个节点。感谢通道可视化，现在你可以看到两个节点之间目前已经有通道相连。</li></ul><p>今天的内容就到这里！希望你们能够继续对其它的一些闪电网络客户端和其它的案例进行探索，反正在测试网当中，是无痛，你也不会损失任何东西。</p><h1 id="那么主网的情况呢？What-about-the-mainnet"><a href="#那么主网的情况呢？What-about-the-mainnet" class="headerlink" title="那么主网的情况呢？What about the mainnet"></a>那么主网的情况呢？What about the mainnet</h1><p>2018年2月份，对于实际的支付闪电网络并没有准备好。确实，它在主网上面进行了部署，在主网上面也确实有闪电网络节点。但是很多东西还在开发当中，如果在真实的支付场景当中使用闪电网络还是有非常高的风险。</p><p>但是，你依然可以对它保持关注，感谢这个服务：<a href="https://lnmainnet.gaben.win/" target="_blank" rel="noopener">https://lnmainnet.gaben.win/</a></p><h1 id="链接和资源-Links-and-resources"><a href="#链接和资源-Links-and-resources" class="headerlink" title="链接和资源 Links and resources"></a>链接和资源 Links and resources</h1><ul><li><a href="https://coincenter.org/entry/what-is-the-lightning-network" target="_blank" rel="noopener">What is the Lightning Network and how can it help Bitcoin scale?</a></li><li><a href="https://www.youtube.com/watch?v=wIhAmTqXhZQ" target="_blank" rel="noopener">Lightning Network Tech Talk at Coinbase</a></li><li><a href="https://rusty.ozlabs.org/?p=450" target="_blank" rel="noopener">Lightning Networks Part I: Revocable Transactions – technical - explanation of LN</a></li><li><a href="https://dev.lightning.community/overview/" target="_blank" rel="noopener">LND Overview and Developer Guide – just enough information about - Lightning Network Daemon to build applications</a></li><li><a href="https://play.google.com/store/apps/details?id=fr.acinq.eclair.wallet&amp;hl=en" target="_blank" rel="noopener">Mobile (Android) Ecalir wallet for the testnet</a></li><li><a href="https://github.com/LN-Zap/zap-desktop" target="_blank" rel="noopener">Zap – another desktop application</a></li><li><a href="https://github.com/ElementsProject/lightning-charge" target="_blank" rel="noopener">Lightning Charge – a simple drop-in solution for accepting lightning payments</a></li><li><a href="https://techtake.info/2017/08/22/segwit-bitcoincash-technical-details-explained/" target="_blank" rel="noopener">SegWit, BitcoinCash: Technical details explained</a></li><li><a href="https://www.reddit.com/r/Bitcoin/comments/5dt8tz/confused_is_segwit_needed_for_lightning_network/" target="_blank" rel="noopener">Is Segwit needed for Lightning Network?</a></li></ul>]]></content>
    
    <summary type="html">
    
      比特币的交易容量一直被人所诟病，按照当前的设定，只能提供7笔/秒的处理能力，远远不能满足日常支付的需求。对此，人们也提出来了很多解决方案，其中就有闪电网络。这篇文章依然翻译自我们的老朋友[Ivan Kuznetsov](https://jeiwan.net/)，想看原文的朋友可以通过链接过去自行查看。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="比特币" scheme="http://datacruiser.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="闪电网络" scheme="http://datacruiser.io/tags/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
      <category term="扩容" scheme="http://datacruiser.io/tags/%E6%89%A9%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>如何用Go打造区块链（7）—网络</title>
    <link href="http://datacruiser.io/2019/11/07/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%887%EF%BC%89%E2%80%94%E7%BD%91%E7%BB%9C/"/>
    <id>http://datacruiser.io/2019/11/07/如何用Go打造区块链（7）—网络/</id>
    <published>2019-11-07T20:06:24.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍-Introduction"><a href="#介绍-Introduction" class="headerlink" title="介绍 Introduction"></a>介绍 Introduction</h1><p>到目前为止，我们构建了一个含有以下特征的区块链：匿名、安全、以及随机产生地址；区块链数据存储；PoW系统；可靠的交易记录存储方式。这些特征都非常关键，但是这还不够。能够让这些特征升华的，并且让加密货币变得可能的，是网络（network）。这样的区块链实现如果只能在单一的电脑上面运行有什么用？这些基础加密特性有什么有，如果仅有一个用户？网络让这些机制工作并发挥作用。</p><p>你可以将这些区块链的特征视为基本准则，你会发现与人类希望共同生活和成长的准则类似。一种社会性的安排。区块链网络是遵从同样准则的程序社区，也正是遵从这些准则让这个网络变得活力四射。同样的，当人们分享共同的想法，他们将变得更强，然后可以一起构建更美好的生活。如果其中有人遵从不一样的准则，他们将在一个隔离的社会（国家、社区等）里生活。同样的，如果有一个区块链节点执行不一样的规则，它们将形成一个单独的网络。</p><p>这个非常重要：没有一个有共识的网络或者大部分节点有共识的网络，这些规则就毫无用处。</p><blockquote><p>免责声明：不幸的是，我没有足够的时间去实现一个真正的P2P网络原型。在这篇文章当中，我会证明一个最平常的情景，会涉及不同类型的节点。提高这个场景然后将它实现为一个真正的P2P 网络会是各位读者一个绝好的挑战和实践！我也不能保证除了本文所实现的情景以外的其它情景能够解决问题。对不起！<br>这部分介绍了关键的代码变化，因此在这里解释所有的代码不是特别有意义。可以参看<a href="https://github.com/Jeiwan/blockchain_go/compare/part_6...part_7#files_bucket" target="_blank" rel="noopener">这个页面</a>看与上一部分文章之间的代码变动。</p></blockquote><h1 id="区块链网络-Blockchain-Network"><a href="#区块链网络-Blockchain-Network" class="headerlink" title="区块链网络 Blockchain Network"></a>区块链网络 Blockchain Network</h1><p>区块链网络是去中心化的，这意味着没有服务器提供服务，然后客户端通过服务区获取或处理数据。在区块链网络当中分布着不同的节点（nodes），每一个节点都是网络上完整（full-fledged）的节点。一个节点就是所有：即是节点也是服务器。这个非常重要，必须牢牢记住，因为这与普通的 web 应用完全不同。</p><p>区块链网络是一个 P2P （Peer-to-Peer）网络，这意味着各个节点与其它节点之间直接连接。它的拓扑结构是平的，在节点规则当中没有层级关系。下面是它的示意图：</p><p><img src="https://jeiwan.net/images/p2p-network.png" alt=""></p><p><a href="https://www.freepik.com/dooder" target="_blank" rel="noopener">(Business vector created by Dooder - Freepik.com)</a></p><p>这样的网络当中的节点更难以实现，因为它们需要执行很多的操作。每一个节点都要与其它不同的节点之间互动，它需要获得其它节点的状态，并与自己的状态对比，如果发现自己的状态不是最新的还需要更新自己的状态。</p><h1 id="节点角色-Node-Roles"><a href="#节点角色-Node-Roles" class="headerlink" title="节点角色 Node Roles"></a>节点角色 Node Roles</h1><p>除了要全能以外，区块链节点可以在网络中扮演不同的角色。如下所示：</p><ul><li>矿机。</li></ul><p>这样的节点运行在超强性能或者专门的硬件（比如ASIC）上，它们的唯一目标就是尽快挖到新的区块。矿机仅在采用PoW机制的区块链上能够工作，因为挖矿本身实际上就是求解PoW谜题。打个比方，在采用PoS（Proof-of-Stake）机制的区块链上，并没有挖矿。</p><ul><li>全能节点。</li></ul><p>这些节点验证由矿机挖到的区块并确认交易记录。为了做这件事情，它们必须要有区块链的整个网站拷贝。这样的节点也履行一些日常的操作，比如帮助其它节点去发现彼此。一个网络必须要有很多全能节点，这个非常重要，因为是这些节点在做这样的决定：它们决定着一个区块或者交易记录是否合法有效。</p><ul><li>简单支付验证 SPV.</li></ul><p>简单支付验证（Simplified Payment Verification）。承担简单支付验证的节点并不保存区块链的完整拷贝，但是它们依然可以验证交易记录（并不是所有的，是一个子集，举个例子，比如发往特定地址的的）。一个SPV 节点依赖于一个全能节点获取数据，一个全能节点会有很多个SPV节点连接。SPV节点让钱包应用变得可能：你不用下载整个区块链，但是依然可以验证你的交易记录。</p><h1 id="网络简化-Network-simplification"><a href="#网络简化-Network-simplification" class="headerlink" title="网络简化 Network simplification"></a>网络简化 Network simplification</h1><p>为了在我们的区块链中实现网络，我们需要简化一些东西。问题在于我们并没有很多台电脑用来模拟一个拥有很多节点的网络。我们原本可以使用虚拟机或者 Docker 来解决这个问题，但是这会让事情变得更加复杂：我们的目的原本关注于区块链的实现，但是你必须又要提供虚拟机或者 Docker的应对措施。因此，我们要在单机上同时运行多个拥有不同地址的节点。为了取得这样的效果，我们将不同的端口视为不同的节点，以代替IP 地址。举了例子，会有以下不同地址的节点：127.0.0.1:3000, 127.0.0.1:3001, 127.0.0.1:3002等。我们将调用端口节点ID 并用<code>NODE_IDenvironment</code> 变量来设置它们。这样，你可以打开多个命令行窗口，设置不同的<code>NODE_IDs</code> 就有不同的节点运行。</p><p>这个方法也要求不同的区块链和钱包文件。它们现在依赖于节点 ID并被命名为 blockchain_3000.db, blockchain_30001.db and wallet_3000.db, wallet_30001.db等。</p><h1 id="实现-Implementation"><a href="#实现-Implementation" class="headerlink" title="实现 Implementation"></a>实现 Implementation</h1><p>那么问题来了，当我们下载比特币内核并首次运行会发生什么？它必须连接到一些节点去下载区块链的最先状态。假如你的电脑不被有些比特币识别，那么这个让你下载区块链的节点又在哪里呢？</p><p>在比特币内核中硬编码一个节点地址会是一个错误：节点会被攻击或者关机，导致新的节点无法加入网络。相应的，在比特币内核当中，有硬编码的 DNS seeds 。它们不是节点，是知道一些节点IP地址的DNS 服务器。当你开始一个全新的比特币内核是，它会连接到其中的一个 种子（seed）然后获得一份全能节点的列表，然后从它们那里下载区块链。</p><p>在我们的实现当中，目前也是集中式的。我们会有以下三个节点：</p><ul><li>中央节点。这是其它所有节点都会连接的，也是与其它节点交互数据的节点。</li><li>一个挖矿节点。这个节点会在内存池保存新的交易记录，并且当有足够的交易记录时，会挖一个新的区块。</li><li>一个钱包节点。这个节点用于在钱包之前转移币。不像SPV节点，它保存一份完整的区块链拷贝。</li></ul><h1 id="情景-The-Scenario"><a href="#情景-The-Scenario" class="headerlink" title="情景 The Scenario"></a>情景 The Scenario</h1><p>这篇文章的目的是实现以下场景：</p><ul><li>中央节点创建一个区块链。</li><li>其它节点（钱包节点）连接到中央节点并下载区块链。</li><li>还有一个挖矿节点将连到中央节点并从中央节点下载区块链。</li><li>钱包节点创建交易记录。</li><li>挖矿节点接收交易记录并将它保存在自己的内存池当中。</li><li>当内存池中的交易记录足够多时，矿工便开始挖新的区块。</li><li>当一个新的区块被挖出来，它将会被发送到中央节点。</li><li>钱包节点会与中央节点同步。</li><li>钱包节点的用户会检查它们的支付是否成功。</li><li>这就是比特币看起来的样子。即便我们没有准备构建一个实际的P2P网络，但是我们所实现的也是一个实际的、主要以及最重要的比特币案例。</li></ul><h1 id="版本-version"><a href="#版本-version" class="headerlink" title="版本 version"></a>版本 version</h1><p>节点之间都过消息的方式进行沟通交流。当一个新节点运行，它会从一个DNS种子获得一些已有节点的地址，便向它们发送版本消息，在我们的实现中看起来像下面的样子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> version <span class="keyword">struct</span> &#123;</span><br><span class="line">    Version    <span class="keyword">int</span></span><br><span class="line">    BestHeight <span class="keyword">int</span></span><br><span class="line">    AddrFrom   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只有一个区块链版本，所以在 <code>Version</code> 结构体的字段中并没有保存任何重要信息。<code>BestHeight</code> 字段保存节点的区块链的长度。<code>AddFrom</code>保存发送者的地址。</p><p>当一个节点收到一个版本信息时它应该干什么？它将以自己的版本信息进行回应。某种意义上，这就像握手：双方之间没有一方的主动示意互动便不可能。但这又不仅仅是礼貌：版本用于寻找一个更长的区块。当一个节点收到一个版本信息它将检查节点的区块链是否比BestHeigh 字段中的值长。假如不是，节点会要求与下载缺失的区块。</p><p>为了收到消息，我们需要一个服务器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeAddress <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> knownNodes = []<span class="keyword">string</span>&#123;<span class="string">"localhost:3000"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartServer</span><span class="params">(nodeID, minerAddress <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    nodeAddress = fmt.Sprintf(<span class="string">"localhost:%s"</span>, nodeID)</span><br><span class="line">    miningAddress = minerAddress</span><br><span class="line">    ln, err := net.Listen(protocol, nodeAddress)</span><br><span class="line">    <span class="keyword">defer</span> ln.Close()</span><br><span class="line"></span><br><span class="line">    bc := NewBlockchain(nodeID)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nodeAddress != knownNodes[<span class="number">0</span>] &#123;</span><br><span class="line">        sendVersion(knownNodes[<span class="number">0</span>], bc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := ln.Accept()</span><br><span class="line">        <span class="keyword">go</span> handleConnection(conn, bc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们硬解码中央节点的地址：一开始，每一个节点都必须知道要连接到哪里。<code>minerAddress</code> 参数指定了挖矿奖励的接收地址。下面这段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nodeAddress != knownNodes[<span class="number">0</span>] &#123;</span><br><span class="line">    sendVersion(knownNodes[<span class="number">0</span>], bc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意味着假如目前的节点不是中央节点，它必须向中央节点发送版本信息并确认它的区块链是否过时了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendVersion</span><span class="params">(addr <span class="keyword">string</span>, bc *Blockchain)</span></span> &#123;</span><br><span class="line">    bestHeight := bc.GetBestHeight()</span><br><span class="line">    payload := gobEncode(version&#123;nodeVersion, bestHeight, nodeAddress&#125;)</span><br><span class="line"></span><br><span class="line">    request := <span class="built_in">append</span>(commandToBytes(<span class="string">"version"</span>), payload...)</span><br><span class="line"></span><br><span class="line">    sendData(addr, request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的消息，在底层的角度看，是字节序列。前面12个字节指定了命令名字（“version”，在这个案例中），后面的字节包含 <code>gob-encoded</code> 信息结构体。<code>commandToBytes</code> 看起来是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">commandToBytes</span><span class="params">(command <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bytes [commandLength]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> command &#123;</span><br><span class="line">        bytes[i] = <span class="keyword">byte</span>(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bytes[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它创建了一个 12-byte 的缓冲，并用命令名去覆盖它，让剩下的字节留空。相应的逆函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytesToCommand</span><span class="params">(bytes []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> command []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> bytes &#123;</span><br><span class="line">        <span class="keyword">if</span> b != <span class="number">0x0</span> &#123;</span><br><span class="line">            command = <span class="built_in">append</span>(command, b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s"</span>, command)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个节点收到一个命令，它调用<code>bytesToCommand</code>获取命令名字并以正确的操作执行命令体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn, bc *Blockchain)</span></span> &#123;</span><br><span class="line">    request, err := ioutil.ReadAll(conn)</span><br><span class="line">    command := bytesToCommand(request[:commandLength])</span><br><span class="line">    fmt.Printf(<span class="string">"Received %s command\n"</span>, command)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> command &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"version"</span>:</span><br><span class="line">        handleVersion(request, bc)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Unknown command!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，版本命令的处理内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleVersion</span><span class="params">(request []<span class="keyword">byte</span>, bc *Blockchain)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buff bytes.Buffer</span><br><span class="line">    <span class="keyword">var</span> payload verzion</span><br><span class="line"></span><br><span class="line">    buff.Write(request[commandLength:])</span><br><span class="line">    dec := gob.NewDecoder(&amp;buff)</span><br><span class="line">    err := dec.Decode(&amp;payload)</span><br><span class="line"></span><br><span class="line">    myBestHeight := bc.GetBestHeight()</span><br><span class="line">    foreignerBestHeight := payload.BestHeight</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> myBestHeight &lt; foreignerBestHeight &#123;</span><br><span class="line">        sendGetBlocks(payload.AddrFrom)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> myBestHeight &gt; foreignerBestHeight &#123;</span><br><span class="line">        sendVersion(payload.AddrFrom, bc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !nodeIsKnown(payload.AddrFrom) &#123;</span><br><span class="line">        knownNodes = <span class="built_in">append</span>(knownNodes, payload.AddrFrom)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们需要解码 <code>request</code>然后获取 <code>payload</code>。这与其它所有的操作函数类似，所以在后面的片段当中我将省略这部分代码。</p><p>然后一个节点比较它的 <code>BestHeight</code>与从信息中得到的大小。假如节点的区块链更长，它将回应自己的版本信息；否则，它会发送 <code>getblocks</code>消息。</p><h1 id="获得区块-getblocks"><a href="#获得区块-getblocks" class="headerlink" title="获得区块 getblocks"></a>获得区块 getblocks</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> getblocks <span class="keyword">struct</span> &#123;</span><br><span class="line">    AddrFrom <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getblocks</code>意味着“给我看看你有什么区块”（在比特币当中，要比这个要复杂得多）。需要注意的是，这并不是说“给我你所有的区块”，而是给我一个区块哈希值的列表。这样有助于降低网络负荷，因为区块可以从不同的节点下载，而且我们也不愿意从一个节点下载Gb级别以上的数据。</p><p>处理命令简单如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleGetBlocks</span><span class="params">(request []<span class="keyword">byte</span>, bc *Blockchain)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    blocks := bc.GetBlockHashes()</span><br><span class="line">    sendInv(payload.AddrFrom, <span class="string">"block"</span>, blocks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的简单实现当中，<code>handleGetBlocks</code>会返回所有的区块哈希值。</p><h1 id="inv"><a href="#inv" class="headerlink" title="inv"></a>inv</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> inv <span class="keyword">struct</span> &#123;</span><br><span class="line">    AddrFrom <span class="keyword">string</span></span><br><span class="line">    Type     <span class="keyword">string</span></span><br><span class="line">    Items    [][]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比特币使用 <code>inv</code>来告诉其它节点当前节点有什么区块和交易记录。同样的，它不包含所有的区块和交易记录，只是它们的哈希值。<code>Type</code>字段表明它们是区块还是交易记录。</p><p><code>inv</code>命令的处理要稍微难一些：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleInv</span><span class="params">(request []<span class="keyword">byte</span>, bc *Blockchain)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    fmt.Printf(<span class="string">"Recevied inventory with %d %s\n"</span>, <span class="built_in">len</span>(payload.Items), payload.Type)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> payload.Type == <span class="string">"block"</span> &#123;</span><br><span class="line">        blocksInTransit = payload.Items</span><br><span class="line"></span><br><span class="line">        blockHash := payload.Items[<span class="number">0</span>]</span><br><span class="line">        sendGetData(payload.AddrFrom, <span class="string">"block"</span>, blockHash)</span><br><span class="line"></span><br><span class="line">        newInTransit := [][]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, b := <span class="keyword">range</span> blocksInTransit &#123;</span><br><span class="line">            <span class="keyword">if</span> bytes.Compare(b, blockHash) != <span class="number">0</span> &#123;</span><br><span class="line">                newInTransit = <span class="built_in">append</span>(newInTransit, b)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        blocksInTransit = newInTransit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> payload.Type == <span class="string">"tx"</span> &#123;</span><br><span class="line">        txID := payload.Items[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mempool[hex.EncodeToString(txID)].ID == <span class="literal">nil</span> &#123;</span><br><span class="line">            sendGetData(payload.AddrFrom, <span class="string">"tx"</span>, txID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果区块哈希被转移了，我们要将它们保存在 <code>blockInTransit</code>变量当中以便跟踪下载的区块。这允许我们从不同的节点下载区块。当我们将区块放到传输状态以后，我向 <code>inv</code>信息的发送者下达 <code>getdata</code>命令然后更新 <code>blockInTransit</code>。在一个实际的<code>P2P</code>网络当中，我们需要在不同的节点之间传送区块。</p><p>在我们的实现当中，我们从不用 <code>inv</code>多个哈希值。这是为什么当 <code>payload.Type == &quot;tx&quot;</code>只是获取了第一个哈希值。然后我们检查我们的内存池中是否已经有这个哈希，如果没有，下达 <code>getdata</code>命令。</p><h1 id="getdata"><a href="#getdata" class="headerlink" title="getdata"></a>getdata</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> getdata <span class="keyword">struct</span> &#123;</span><br><span class="line">    AddrFrom <span class="keyword">string</span></span><br><span class="line">    Type     <span class="keyword">string</span></span><br><span class="line">    ID       []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getdata</code>是针对特定区块或者交易记录的请求，它可以只包含一个区块／交易记录 ID。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleGetData</span><span class="params">(request []<span class="keyword">byte</span>, bc *Blockchain)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> payload.Type == <span class="string">"block"</span> &#123;</span><br><span class="line">        block, err := bc.GetBlock([]<span class="keyword">byte</span>(payload.ID))</span><br><span class="line"></span><br><span class="line">        sendBlock(payload.AddrFrom, &amp;block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> payload.Type == <span class="string">"tx"</span> &#123;</span><br><span class="line">        txID := hex.EncodeToString(payload.ID)</span><br><span class="line">        tx := mempool[txID]</span><br><span class="line"></span><br><span class="line">        sendTx(payload.AddrFrom, &amp;tx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的处理方式非常简单：如果它们需要一个区块，返回一个区块；如果它们需要一个交易记录，返回交易记录。注意，我们并不检查实际上我们是否有这样的区块或者交易记录。这是一个瑕疵：）</p><h1 id="block-and-tx"><a href="#block-and-tx" class="headerlink" title="block and tx"></a>block and tx</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> block <span class="keyword">struct</span> &#123;</span><br><span class="line">    AddrFrom <span class="keyword">string</span></span><br><span class="line">    Block    []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tx <span class="keyword">struct</span> &#123;</span><br><span class="line">    AddFrom     <span class="keyword">string</span></span><br><span class="line">    Transaction []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正是这些消息实际上在做着数据传送的事情。</p><p>处理<code>block</code>消息非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleBlock</span><span class="params">(request []<span class="keyword">byte</span>, bc *Blockchain)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    blockData := payload.Block</span><br><span class="line">    block := DeserializeBlock(blockData)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Recevied a new block!"</span>)</span><br><span class="line">    bc.AddBlock(block)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Added block %x\n"</span>, block.Hash)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(blocksInTransit) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockHash := blocksInTransit[<span class="number">0</span>]</span><br><span class="line">        sendGetData(payload.AddrFrom, <span class="string">"block"</span>, blockHash)</span><br><span class="line"></span><br><span class="line">        blocksInTransit = blocksInTransit[<span class="number">1</span>:]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        UTXOSet := UTXOSet&#123;bc&#125;</span><br><span class="line">        UTXOSet.Reindex()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们收到一个新的区块，我们将它放到我们的区块链。假如还有更多的区块需要下载，我们将从已下载其之前区块的节点下载。当我们最终下载完全部区块，<code>UTXO set</code>会重新索引。</p><blockquote><p>TODO：在将它加入到区块链之前，我们需要验证每一个进来的区块，而不是无条件地信任。<br>TODO：如果区块链很大的话，这会花很多时间去重新索引整个 UTXO set，因此采用UTXOSet.Update(block)，而不是运行UTXOSet.Reindex()。</p></blockquote><p>处理 <code>tx</code>消息是最复杂的部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleTx</span><span class="params">(request []<span class="keyword">byte</span>, bc *Blockchain)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    txData := payload.Transaction</span><br><span class="line">    tx := DeserializeTransaction(txData)</span><br><span class="line">    mempool[hex.EncodeToString(tx.ID)] = tx</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nodeAddress == knownNodes[<span class="number">0</span>] &#123;</span><br><span class="line">        <span class="keyword">for</span> _, node := <span class="keyword">range</span> knownNodes &#123;</span><br><span class="line">            <span class="keyword">if</span> node != nodeAddress &amp;&amp; node != payload.AddFrom &#123;</span><br><span class="line">                sendInv(node, <span class="string">"tx"</span>, [][]<span class="keyword">byte</span>&#123;tx.ID&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(mempool) &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">len</span>(miningAddress) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        MineTransactions:</span><br><span class="line">            <span class="keyword">var</span> txs []*Transaction</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> id := <span class="keyword">range</span> mempool &#123;</span><br><span class="line">                tx := mempool[id]</span><br><span class="line">                <span class="keyword">if</span> bc.VerifyTransaction(&amp;tx) &#123;</span><br><span class="line">                    txs = <span class="built_in">append</span>(txs, &amp;tx)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(txs) == <span class="number">0</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"All transactions are invalid! Waiting for new ones..."</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cbTx := NewCoinbaseTX(miningAddress, <span class="string">""</span>)</span><br><span class="line">            txs = <span class="built_in">append</span>(txs, cbTx)</span><br><span class="line"></span><br><span class="line">            newBlock := bc.MineBlock(txs)</span><br><span class="line">            UTXOSet := UTXOSet&#123;bc&#125;</span><br><span class="line">            UTXOSet.Reindex()</span><br><span class="line"></span><br><span class="line">            fmt.Println(<span class="string">"New block is mined!"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _, tx := <span class="keyword">range</span> txs &#123;</span><br><span class="line">                txID := hex.EncodeToString(tx.ID)</span><br><span class="line">                <span class="built_in">delete</span>(mempool, txID)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _, node := <span class="keyword">range</span> knownNodes &#123;</span><br><span class="line">                <span class="keyword">if</span> node != nodeAddress &#123;</span><br><span class="line">                    sendInv(node, <span class="string">"block"</span>, [][]<span class="keyword">byte</span>&#123;newBlock.Hash&#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(mempool) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">goto</span> MineTransactions</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最先要做的事情就是将新的交易记录放到内存池当中（再强调一遍，将交易记录放入内存池之前必须进行验证）。下一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nodeAddress == knownNodes[<span class="number">0</span>] &#123;</span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> knownNodes &#123;</span><br><span class="line">        <span class="keyword">if</span> node != nodeAddress &amp;&amp; node != payload.AddFrom &#123;</span><br><span class="line">            sendInv(node, <span class="string">"tx"</span>, [][]<span class="keyword">byte</span>&#123;tx.ID&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查当前节点是否就是中央节点。在我们的实现当中，中央节点不进行挖矿作业。而是在网络当中转发新的交易记录给其它的节点。</p><p>下一大段代码只针对挖矿节点。让我们将它分成几部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(mempool) &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">len</span>(miningAddress) &gt; <span class="number">0</span> &#123;</span><br></pre></td></tr></table></figure><p><code>miningAddress</code>只是在挖矿节点中设置。当有2个或2个以上的交易记录在当前挖矿节点的内存池当中的时候，挖矿便开始了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> id := <span class="keyword">range</span> mempool &#123;</span><br><span class="line">    tx := mempool[id]</span><br><span class="line">    <span class="keyword">if</span> bc.VerifyTransaction(&amp;tx) &#123;</span><br><span class="line">        txs = <span class="built_in">append</span>(txs, &amp;tx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(txs) == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"All transactions are invalid! Waiting for new ones..."</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，所有在内存池中的交易记录得到验证。非法的交易记录会被忽略，如果没有合法的交易记录，挖矿会被中断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cbTx := NewCoinbaseTX(miningAddress, <span class="string">""</span>)</span><br><span class="line">txs = <span class="built_in">append</span>(txs, cbTx)</span><br><span class="line"></span><br><span class="line">newBlock := bc.MineBlock(txs)</span><br><span class="line">UTXOSet := UTXOSet&#123;bc&#125;</span><br><span class="line">UTXOSet.Reindex()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"New block is mined!"</span>)</span><br></pre></td></tr></table></figure><p>验证过的交易记录会放入到区块当中，包括含有奖励的币基交易记录。在挖矿区块以后，<code>UTXO set</code>将重新索引。</p><blockquote><p>TODO：再一次强调，UTXOSet.Update 应该代替UTXOSet.Reindex使用。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> txs &#123;</span><br><span class="line">    txID := hex.EncodeToString(tx.ID)</span><br><span class="line">    <span class="built_in">delete</span>(mempool, txID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> knownNodes &#123;</span><br><span class="line">    <span class="keyword">if</span> node != nodeAddress &#123;</span><br><span class="line">        sendInv(node, <span class="string">"block"</span>, [][]<span class="keyword">byte</span>&#123;newBlock.Hash&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(mempool) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">goto</span> MineTransactions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个交易记录被挖出以后，它将从内存池中移除。任何知道当前节点的其它节点，收到含有新区块哈希值的 <code>inv</code>消息。在处理了这些消息以后它可以对这个区块提出要求。</p><h1 id="结果-Result"><a href="#结果-Result" class="headerlink" title="结果 Result"></a>结果 Result</h1><p>让我们试一下我们之前定义的场景。</p><p>首先，在第一个终端窗口设置<code>NODE_ID</code>为3000（export NODE_ID=3000）。为了不混淆哪个节点所对应的命令行，我将在在下一个段落之前在每段代码前面设置像NODE 3000 或者 NODE 3001的标签。</p><ul><li>NODE 3000</li></ul><p>新建一个钱包和一个区块链：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go createblockchain -address CENTREAL_NODE</span><br></pre></td></tr></table></figure><p>(为了简洁和清晰，我将使用假地址)</p><p>在这之后，区块链包含了单一的创世区块。我需要保存这个区块并在其它节点中使用。创世区块用来区分不同的区块链。（在比特币内核当中，创世区块是硬编码的）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp blockchain_3000.db blockchain_genesis.db</span><br></pre></td></tr></table></figure><ul><li>NODE 3001</li></ul><p>下一步，打开一个新的终端窗口并将节点ID设置为3001。这将是一个钱包节点。用<code>blockchain_go createwallet</code>新建一些地址，我们将它们命名为 <code>WALLET_1, WALLET_2, WALLET_3</code>。</p><ul><li>NODE 3000</li></ul><p>发一些币给钱包地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go send -from CENTREAL_NODE -to WALLET_1 -amount <span class="number">10</span> -mine</span><br><span class="line">$ blockchain_go send -from CENTREAL_NODE -to WALLET_2 -amount <span class="number">10</span> -mine</span><br></pre></td></tr></table></figure><p>-mine 标签意味着区块会马上被同一个节点挖到。我们必须得有这个标签，因为开始的时候在网络当中并没有挖矿节点。</p><p>开始节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go startnode</span><br></pre></td></tr></table></figure><p>节点必须运行直到节点的最后。</p><ul><li>NODE 3001</li></ul><p>用之前保存的创世区块开始节点的区块链</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp blockchain_genesis.db blockchain_3001.db</span><br></pre></td></tr></table></figure><p>运行这个节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go startnode</span><br></pre></td></tr></table></figure><p>这会从中央节点下载所有的区块。为了检验一些正常，停止这个节点然后查询余额：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go getbalance -address WALLET_1</span><br><span class="line">Balance of <span class="string">'WALLET_1'</span>: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address WALLET_2</span><br><span class="line">Balance of <span class="string">'WALLET_2'</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>同样，你也可以检查<code>CENTRAL_NODE</code>地址的余额，因为节点3001现在已经有它的区块链了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go getbalance -address CENTRAL_NODE</span><br><span class="line">Balance of <span class="string">'CENTRAL_NODE'</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>NODE 3002</li></ul><p>打开一个新的终端并将ID设置为3002，然后产生一个钱包。这将是一个挖矿节点。对区块链进行初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp blockchain_genesis.db blockchain_3002.db</span><br></pre></td></tr></table></figure><p>然后开始节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go startnode -miner MINER_WALLET</span><br></pre></td></tr></table></figure><ul><li>NODE 3001</li></ul><p>发一些币：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go send -from WALLET_1 -to WALLET_3 -amount <span class="number">1</span></span><br><span class="line">$ blockchain_go send -from WALLET_2 -to WALLET_4 -amount <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>NODE 3002</li></ul><p>非常快！切换到挖矿节点然后可以看到它挖了一个新的区块！也可以检查中央节点的输出。</p><ul><li>NODE 3001</li></ul><p>切换到钱包节点然后开始这个节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go startnode</span><br></pre></td></tr></table></figure><p>它会下载新挖的区块！</p><p>停止它，然后检查余额：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go getbalance -address WALLET_1</span><br><span class="line">Balance of <span class="string">'WALLET_1'</span>: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address WALLET_2</span><br><span class="line">Balance of <span class="string">'WALLET_2'</span>: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address WALLET_3</span><br><span class="line">Balance of <span class="string">'WALLET_3'</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address WALLET_4</span><br><span class="line">Balance of <span class="string">'WALLET_4'</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address MINER_WALLET</span><br><span class="line">Balance of <span class="string">'MINER_WALLET'</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>嗯，就这样！</p><h1 id="结论-Conclusion"><a href="#结论-Conclusion" class="headerlink" title="结论 Conclusion"></a>结论 Conclusion</h1><p>这是系列文章的最后一部分。我原本可以发表更多的文章来实现一个P2P网络的现实原型，但是实在没有时间做这件事情。我希望这篇文章能够回答你们关于比特币技术的问题并提出一些新的问题，然后你们可以自己寻找答案。比特币技术当中还有很多更有趣的事情隐藏着！祝各位好运！</p><p>P.S. 你可以开始通过实现<code>addr</code>消息来提高网络的性能，正如比特币网络协议当中所描述的，链接如下。这是非常重要的消息，因为它允许节点去发现彼此。我开始实现它，但是还没有完成。</p><h1 id="Links"><a href="#Links" class="headerlink" title="Links:"></a>Links:</h1><ul><li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_7" target="_blank" rel="noopener">Source codes</a></li><li><a href="https://en.bitcoin.it/wiki/Protocol_documentation" target="_blank" rel="noopener">Bitcoin protocol documentation</a></li><li><a href="https://en.bitcoin.it/wiki/Network" target="_blank" rel="noopener">Bitcoin network</a></li></ul>]]></content>
    
    <summary type="html">
    
      由于众所周知的原因，最近区块链又一次被推到了风口，下面转发几篇两年前翻译的首发于知乎关于如何用Go语言打造区块链的文章。Go语言是由google开发并于2009年发布的一种静态、强类型、编译型、并发型，并具有垃圾回收（GC）功能的编程语言，特别适用于分布式网络系统开发，而区块链（blockchain）本质上是一本在网络上分布存储的账本，这两者具有天然的匹配性，目前火热的[Ethereum Project](https://ethereum.org/)就是用go原生实现的。这一系列的文章是由[Ivan Kuznetsov](https://jeiwan.net/)所写，本人觉得是一个结合Go语言学习区块链技术的好资料，后面将用自己的语言翻译一遍，从第一篇开始，顺便对Go语言以及区块链有一个初步的认识。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="分布式" scheme="http://datacruiser.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据库" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="go" scheme="http://datacruiser.io/tags/go/"/>
    
      <category term="hash" scheme="http://datacruiser.io/tags/hash/"/>
    
      <category term="工作证明" scheme="http://datacruiser.io/tags/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/"/>
    
      <category term="交易" scheme="http://datacruiser.io/tags/%E4%BA%A4%E6%98%93/"/>
    
      <category term="命令行" scheme="http://datacruiser.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何用Go打造区块链（6）—交易记录（二）</title>
    <link href="http://datacruiser.io/2019/11/07/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%886%EF%BC%89%E2%80%94%E4%BA%A4%E6%98%93%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://datacruiser.io/2019/11/07/如何用Go打造区块链（6）—交易记录（二）/</id>
    <published>2019-11-07T17:46:52.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍-Introduction"><a href="#介绍-Introduction" class="headerlink" title="介绍 Introduction"></a>介绍 Introduction</h1><p>在本系列文章的前面部分我说过区块链是一个分布式数据库。但那时候，我们决定暂时跳过“分布式”的部分我先专注于“数据库”部分。到目前为止，我们已经基本实现区块链作为一个数据库的所有部分。我们会覆盖一些前面部分跳过的一些机制，然后在下一部分我们会在区块链的分布式特性方面进行工作。</p><p>前面的部分：</p><ul><li><a href="http://datacruiser.io/2019/10/28/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%881%EF%BC%89%E2%80%94%E5%9F%BA%E7%A1%80%E5%8E%9F%E5%9E%8B/">如何用Go打造区块链（1）—基础原型</a></li><li><a href="http://datacruiser.io/2019/10/28/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%882%EF%BC%89%E2%80%94%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E%E6%9C%BA%E5%88%B6%EF%BC%88PoW%EF%BC%89/">如何用Go打造区块链（2）—工作证明机制（PoW）</a></li><li><a href="http://datacruiser.io/2019/10/29/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%883%EF%BC%89%E2%80%94%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88CLI%EF%BC%89/">如何用Go打造区块链（3）—数据存储及命令行（CLI）</a></li><li><a href="http://datacruiser.io/2019/11/06/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%884%EF%BC%89%E2%80%94%E4%BA%A4%E6%98%93%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/">如何用Go打造区块链（4）—交易记录（一）</a></li><li><a href="http://datacruiser.io/2019/11/06/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%885%EF%BC%89%E2%80%94%E5%9C%B0%E5%9D%80/">如何用Go打造区块链（5）—地址</a></li></ul><blockquote><p>这部分主要介绍关键代码变动，因此这里解释所有的代码不是特别有意义。可以参考<a href="https://github.com/Jeiwan/blockchain_go/compare/part_5...part_6#files_bucket" target="_blank" rel="noopener">这个页面</a>看与上一部分文章之间的代码变动。</p></blockquote><h1 id="奖励-Reward"><a href="#奖励-Reward" class="headerlink" title="奖励 Reward"></a>奖励 Reward</h1><p>在前面的文章当中跳过的一个小事情是挖矿的奖励。为了实现它的所有元素我们已经准备好了。</p><p>奖励（reward）只是一个币基交易记录（coinbase transaction）。当以挖矿节点开始挖一个新的区块，从队列中取得交易记录并给区块预留一个币基交易记录。币基交易记录的唯一输出包含矿工（miner）的公钥哈希值。</p><p>实现奖励只要通过更新一下 <code>send</code> 命令就可以：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">send</span><span class="params">(from, to <span class="keyword">string</span>, amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    bc := NewBlockchain()</span><br><span class="line">    UTXOSet := UTXOSet&#123;bc&#125;</span><br><span class="line">    <span class="keyword">defer</span> bc.db.Close()</span><br><span class="line"></span><br><span class="line">    tx := NewUTXOTransaction(from, to, amount, &amp;UTXOSet)</span><br><span class="line">    cbTx := NewCoinbaseTX(from, <span class="string">""</span>)</span><br><span class="line">    txs := []*Transaction&#123;cbTx, tx&#125;</span><br><span class="line"></span><br><span class="line">    newBlock := bc.MineBlock(txs)</span><br><span class="line">    fmt.Println(<span class="string">"Success!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的实现当中，创建交易记录的人去挖新的区块，然后得到一个奖励。</p><h1 id="未花费交易记录输出集-The-UTXO-Set"><a href="#未花费交易记录输出集-The-UTXO-Set" class="headerlink" title="未花费交易记录输出集 The UTXO Set"></a>未花费交易记录输出集 The UTXO Set</h1><p>在<a href="http://datacruiser.io/2019/10/29/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%883%EF%BC%89%E2%80%94%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88CLI%EF%BC%89/">如何用Go打造区块链（3）—数据存储及命令行（CLI）</a>当中，我们研究了比特币内核将区块存储在数据库中的方式。区块存储在 <code>blocks</code>（区块）数据库当中，交易记录输出存储在 <code>chainstate</code>（链状态）数据库当中。让我再回顾一下 <code>chainstate</code>的结构：</p><ul><li>‘c’ + 32-byte transaction hash -&gt; unspent transaction output record for that transaction</li><li>‘B’ -&gt; 32-byte block hash: the block hash up to which the database represents the unspent transaction outputs</li></ul><p>在那篇文章当中，我们已经实现了交易记录，但是我们并没有 <code>chainstate</code>来存储输出。这是我们即将打算要去做的。</p><p><code>chainstate</code>不存储交易记录。反而，它存储叫做<code>UTXO set</code>的东西，或者叫未花费交易记录输出的集合。除此之外，它还存储“到代表未消费输出的数据库的区块哈希值”，因为我们不使用区块高度，我们暂时忽略它（但是我们将在下一篇文章中实现）。</p><p>那么，为什么我们要有 <code>UTXO set</code>呢？</p><p>看一下我们早先实现的 <code>Blockchain.FindUnspentTransactions</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">FindUnspentTransactions</span><span class="params">(pubKeyHash []<span class="keyword">byte</span>)</span> []<span class="title">Transaction</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    bci := bc.Iterator()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        block := bci.Next()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数寻找有未消费输出的交易记录。因为交易记录存储在区块当中，它遍历每一个区块然后检查其中的每一个交易记录。截止2017年9月18日，在比特币当中一共有485, 860个区块，所有的数据库大约占用140+Gb的容量。这意味着你必须运行一个完整的节点来验证交易记录。同时，验证交易记录需要遍历很多区块。</p><p>这个问题的解决方案是引入一个只存储未消费输出的索引值，这就是<code>UTXO set</code>所做的事情：这是一个从所有区块链交易记录（通过遍历区块，是的，但是只做一次）构建的快速缓存，随后会被用于计算余额和验证新的交易记录。截止2017年9月份，<code>UTXO set</code>差不多2.7Gb。</p><p>好了，让我们想想我们需要做什么来实现<code>UTXO set</code>。目前，下面的方法用于寻找交易记录：</p><ul><li><code>Blockchain.FindUnspentTransactions</code> – 寻找含未消费输出的交易记录的主函数。在这个函数当中我们遍历所有的区块。</li><li><code>Blockchain.FindSpendableOutputs</code> – 当一个新的交易记录被创建时，这个函数会被使用。如果要找到足够数量的持有满足需求的足额输出的话。会用到<code>Blockchain.FindUnspentTransactions</code>.</li><li><code>Blockchain.FindUTXO</code> – 为一个特定的公钥哈希寻找未花费输出，用于获取余额。会用到 <code>Blockchain.FindUnspentTransactions</code>.</li><li><code>Blockchain.FindTransaction</code>– 通过ID 在区块链中找到一个交易记录。它会遍历所有的区块，直到找到满足要求的交易记录。</li></ul><p>正如你所看到的，所有的方法都需要遍历数据库中的区块。但是目前我们还不能对全部进行优化，但是<code>UTXO set</code>并不存储所有的交易记录，而只是那些有未消费输出的。这样，在 <code>Blockchain.FindTransaction</code>中无法使用。</p><p>这样，我们想要下列方法：</p><ul><li><code>Blockchain.FindUTXO</code> – 通过遍历区块寻找所有的未消费输出</li><li><code>UTXOSet.Reindex</code> — 用 <code>FindUTXO</code> 来寻找未消费输出，然后将他们存储在一个数据库当中，这是缓存发生的地方</li><li><code>UTXOSet.FindSpendableOutputs</code> – 与 <code>Blockchain.FindSpendableOutputs</code> 类似, 不过使用 <code>UTXO set</code></li><li><code>UTXOSet.FindUTXO</code> – 与 <code>Blockchain.FindUTXO</code> 类似, 不过使用 <code>UTXO set</code></li><li><code>Blockchain.FindTransaction</code>保持不变</li></ul><p>这样，两个最频繁使用的函数将会从现在开始使用缓存！让我们开始编码吧！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UTXOSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    Blockchain *Blockchain</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将使用同一个数据库，不过将<code>UTXO set</code>存储在另外一个不同的 <code>bucket</code>当中。<code>UTXOSet</code>将与 <code>Blockchain</code>相结合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UTXOSet)</span> <span class="title">Reindex</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := u.Blockchain.db</span><br><span class="line">    bucketName := []<span class="keyword">byte</span>(utxoBucket)</span><br><span class="line"></span><br><span class="line">    err := db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        err := tx.DeleteBucket(bucketName)</span><br><span class="line">        _, err = tx.CreateBucket(bucketName)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    UTXO := u.Blockchain.FindUTXO()</span><br><span class="line"></span><br><span class="line">    err = db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        b := tx.Bucket(bucketName)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> txID, outs := <span class="keyword">range</span> UTXO &#123;</span><br><span class="line">            key, err := hex.DecodeString(txID)</span><br><span class="line">            err = b.Put(key, outs.Serialize())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法将创建并初始化 <code>UTXO set</code>。首先，移除已经存在的 <code>bucket</code>，然后从区块链当中获得所有的未消费输出，最后将输出保存到 <code>bucket</code>当中。</p><p><code>Blockchain.FindUTXO</code>和 <code>Blockchain.FindUnspentTransactions</code>几乎完全一样, 但是现在它返回一个含 <code>TransactionID → TransactionOutputs</code>对的图（map）。</p><p>现在，<code>UTXO set</code>可以用来发送比特币了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UTXOSet)</span> <span class="title">FindSpendableOutputs</span><span class="params">(pubkeyHash []<span class="keyword">byte</span>, amount <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    unspentOutputs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>)</span><br><span class="line">    accumulated := <span class="number">0</span></span><br><span class="line">    db := u.Blockchain.db</span><br><span class="line"></span><br><span class="line">    err := db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        b := tx.Bucket([]<span class="keyword">byte</span>(utxoBucket))</span><br><span class="line">        c := b.Cursor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k, v := c.First(); k != <span class="literal">nil</span>; k, v = c.Next() &#123;</span><br><span class="line">            txID := hex.EncodeToString(k)</span><br><span class="line">            outs := DeserializeOutputs(v)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> outIdx, out := <span class="keyword">range</span> outs.Outputs &#123;</span><br><span class="line">                <span class="keyword">if</span> out.IsLockedWithKey(pubkeyHash) &amp;&amp; accumulated &lt; amount &#123;</span><br><span class="line">                    accumulated += out.Value</span><br><span class="line">                    unspentOutputs[txID] = <span class="built_in">append</span>(unspentOutputs[txID], outIdx)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accumulated, unspentOutputs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者检查余额：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UTXOSet)</span> <span class="title">FindUTXO</span><span class="params">(pubKeyHash []<span class="keyword">byte</span>)</span> []<span class="title">TXOutput</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> UTXOs []TXOutput</span><br><span class="line">    db := u.Blockchain.db</span><br><span class="line"></span><br><span class="line">    err := db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        b := tx.Bucket([]<span class="keyword">byte</span>(utxoBucket))</span><br><span class="line">        c := b.Cursor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k, v := c.First(); k != <span class="literal">nil</span>; k, v = c.Next() &#123;</span><br><span class="line">            outs := DeserializeOutputs(v)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _, out := <span class="keyword">range</span> outs.Outputs &#123;</span><br><span class="line">                <span class="keyword">if</span> out.IsLockedWithKey(pubKeyHash) &#123;</span><br><span class="line">                    UTXOs = <span class="built_in">append</span>(UTXOs, out)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UTXOs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些都是与<code>Blockchain</code>相关的略微修改过的版本。原先的那些 <code>Blockchain</code>方法已经不需要了。</p><p>有了<code>UTXO set</code>以后意味着我们的数据（交易记录）现在分块存储：实际的交易记录存储在区块链中，未消费输出存储在 <code>UTXO set</code>中。这样的分离需要有可靠的同步机制，因为我们要<code>UTXO set</code>能够一直更新并存储最新交易记录的输出。但是我们也不愿意每次一个新的区块被挖出来就重新建立一次索引，因为我们要避免频繁的区块链扫描。所以，我们还需要一个更新 <code>UTXO set</code>的机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UTXOSet)</span> <span class="title">Update</span><span class="params">(block *Block)</span></span> &#123;</span><br><span class="line">    db := u.Blockchain.db</span><br><span class="line"></span><br><span class="line">    err := db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        b := tx.Bucket([]<span class="keyword">byte</span>(utxoBucket))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">            <span class="keyword">if</span> tx.IsCoinbase() == <span class="literal">false</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> _, vin := <span class="keyword">range</span> tx.Vin &#123;</span><br><span class="line">                    updatedOuts := TXOutputs&#123;&#125;</span><br><span class="line">                    outsBytes := b.Get(vin.Txid)</span><br><span class="line">                    outs := DeserializeOutputs(outsBytes)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> outIdx, out := <span class="keyword">range</span> outs.Outputs &#123;</span><br><span class="line">                        <span class="keyword">if</span> outIdx != vin.Vout &#123;</span><br><span class="line">                            updatedOuts.Outputs = <span class="built_in">append</span>(updatedOuts.Outputs, out)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(updatedOuts.Outputs) == <span class="number">0</span> &#123;</span><br><span class="line">                        err := b.Delete(vin.Txid)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err := b.Put(vin.Txid, updatedOuts.Serialize())</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            newOutputs := TXOutputs&#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> _, out := <span class="keyword">range</span> tx.Vout &#123;</span><br><span class="line">                newOutputs.Outputs = <span class="built_in">append</span>(newOutputs.Outputs, out)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            err := b.Put(tx.ID, newOutputs.Serialize())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法看起来非常复杂，但是它所干的事情却非常简单。当挖出一个新的区块，<code>UTXO set</code>应该相应地更新。更新意味着将已经花出去的移除，然后将新挖区块的未消费的加进去。加入一个交易记录的输出被移除的，不含任何输出，它本身也将会被移除。非常简单！</p><p>现在让我们把 <code>UTXO set</code>用在需要的地方：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">createBlockchain</span><span class="params">(address <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    bc := CreateBlockchain(address)</span><br><span class="line">    <span class="keyword">defer</span> bc.db.Close()</span><br><span class="line"></span><br><span class="line">    UTXOSet := UTXOSet&#123;bc&#125;</span><br><span class="line">    UTXOSet.Reindex()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个新的区块链产生的时候对<code>UTXO set</code>重新索引（Reindex）。到目前为止，这是唯一要重新索引的地方，即便在这里看起来有些过分，因为在一个区块链刚刚被创建的时候，只有一个区块，一个交易记录，<code>Update</code>方法可以来代替 <code>Reindex()</code>。但是在不久的将来，我们需要重新索引机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">send</span><span class="params">(from, to <span class="keyword">string</span>, amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    newBlock := bc.MineBlock(txs)</span><br><span class="line">    UTXOSet.Update(newBlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个新的区块被挖出来以后更新了 <code>UTXO set</code>。</p><p>让我们来检查它的工作情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go createblockchain -address <span class="number">1</span>JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1</span><br><span class="line"><span class="number">00000086</span>a725e18ed7e9e06f1051651a4fc46a315a9d298e59e57aeacbe0bf73</span><br><span class="line"></span><br><span class="line">Done!</span><br><span class="line"></span><br><span class="line">$ blockchain_go send -from <span class="number">1</span>JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1 -to <span class="number">12</span>DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5 -amount <span class="number">6</span></span><br><span class="line"><span class="number">0000001f</span>75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b</span><br><span class="line"></span><br><span class="line">Success!</span><br><span class="line"></span><br><span class="line">$ blockchain_go send -from <span class="number">1</span>JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1 -to <span class="number">12</span>ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL -amount <span class="number">4</span></span><br><span class="line"><span class="number">000000</span>cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433</span><br><span class="line"></span><br><span class="line">Success!</span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address <span class="number">1</span>JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1</span><br><span class="line">Balance of <span class="string">'1F4MbuqjcuJGymjcuYQMUVYB37AWKkSLif'</span>: <span class="number">20</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address <span class="number">12</span>DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5</span><br><span class="line">Balance of <span class="string">'1XWu6nitBWe6J6v6MXmd5rhdP7dZsExbx'</span>: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address <span class="number">12</span>ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL</span><br><span class="line">Balance of <span class="string">'13UASQpCR8Nr41PojH8Bz4K6cmTCqweskL'</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>非常好！<code>1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1</code>地址3次收到奖励：</p><ul><li>第一次来自对创始区块（genesis blocks）的挖矿</li><li>第二次来自对以下区块的挖矿：<code>0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b</code>.</li><li>第三次来自对以下区块的挖矿：<code>000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433</code>.</li></ul><h1 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h1><p>在这篇文章当中还有一个优化选项我还想要讨论以下的。</p><p>正如前面所言，完整的比特币数据库（区块链）大约占140Gb 的磁盘空间。因为比特币的分布式存储的特性，网络中的每一个节点都要独立且要自我实现，比如每个节点都要存储一份整个区块链的完整拷贝。随着很多人开始使用比特币，这条规则变得越来越难以坚持：每个人都运行一个完整的节点不太可能。并且，因为节点是网络的成熟的参与者，它们有责任：它们必须验证交易记录和区块。更进一步，它们与其它节点交流并下载新的节点也需要一定的带宽需求。</p><p>在中本聪（Satoshi Nakamoto）发布的<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">白皮书</a>当中，有一个对应的解决方案：简单支付验证（Simplified Payment Verification：SPV）。<code>SPV</code>是一个轻量的比特币节点，不下载整个区块链，也不对所有的区块和交易记录进行验证。相应的，它在区块中寻找交易记录（验证支付）然后链接到一个完整节点仅取得需要的数据。这样的机制允许有很多的轻量钱包节点而只运行一个完整的节点。</p><p>为了<code>SPV</code>的可行性，需要一种不需要下载整个区块就能够确认一个区块是否含有交易记录的机制。这也正是 <code>Merkle tree</code>所要扮演的角色。</p><p>比特币用 <code>Merkle trees</code>来获得交易记录哈希值，这个哈希值保存在区块头部数据当中并在PoW 系统当中会被考虑。直到现在，我们只是将每个区块中的每个交易记录的哈希值组合在一起然后再使用 <code>SHA-256</code>，只是取得区块交易记录唯一证明的好方式，但是却没有 <code>Merkle trees</code>的一些好处。</p><p>让我们看一个 <code>Merkle tree</code>：</p><p><img src="https://jeiwan.net/images/merkle-tree-diagram.png" alt=""></p><p>每一个区块构建一个 <code>Merkle tree</code>，它从叶子（tree的底部）开始，每一个叶子就是一个交易记录的哈希（比特币采用 双 SHA-256 计算哈希值）。叶子的数量必须是偶数，但是并不是每一个区块都包含偶数个的交易记录。在奇数个交易记录的情况下，最后一个交易记录会被复制（只是在 Merkle tree中复制，并不是在区块当中！）。</p><p>从下往上走，叶子一对一对地分组，它们的哈希值被组合到一起，并产生一个新的哈希值来代替组合后的哈希。新的哈希组成新的树的节点。这个过程不断重复直到剩下仅有的一个节点，称之为树的根。树根的哈希就被用来作为所有交易记录的唯一表征，保存在区块头部数据当中，并在PoW 系统当中使用。</p><p><code>Merkle trees</code> 的好处是一个节点可以在不下载整个区块的情况下验证特定交易记录的身份。一个交易记录哈希，一个 <code>Merkle</code>树根哈希，然后一个<code>Merkle</code>的路径就够了。</p><p>最后，让我们来写代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MerkleTree <span class="keyword">struct</span> &#123;</span><br><span class="line">    RootNode *MerkleNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MerkleNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Left  *MerkleNode</span><br><span class="line">    Right *MerkleNode</span><br><span class="line">    Data  []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从一个结构体开始。每一个<code>MerkleNode</code> 保存着数据还到其分支的链接。</p><p><code>MerkleTree</code> 实际上是链接到下一个节点的根节点，它们就这样依次与更多的节点相连。</p><p>让我们先创建一个新的节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMerkleNode</span><span class="params">(left, right *MerkleNode, data []<span class="keyword">byte</span>)</span> *<span class="title">MerkleNode</span></span> &#123;</span><br><span class="line">    mNode := MerkleNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">        hash := sha256.Sum256(data)</span><br><span class="line">        mNode.Data = hash[:]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prevHashes := <span class="built_in">append</span>(left.Data, right.Data...)</span><br><span class="line">        hash := sha256.Sum256(prevHashes)</span><br><span class="line">        mNode.Data = hash[:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNode.Left = left</span><br><span class="line">    mNode.Right = right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;mNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个节点包含一些数据。当一个节点是一片叶子，数据将从外面传入（在我们的案例中是一个序列化的交易记录）。当一个节点链接到其它节点时，它将获取它们的数据然后组合组合并对数据进行哈希计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMerkleTree</span><span class="params">(data [][]<span class="keyword">byte</span>)</span> *<span class="title">MerkleTree</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nodes []MerkleNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data)%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        data = <span class="built_in">append</span>(data, data[<span class="built_in">len</span>(data)<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, datum := <span class="keyword">range</span> data &#123;</span><br><span class="line">        node := NewMerkleNode(<span class="literal">nil</span>, <span class="literal">nil</span>, datum)</span><br><span class="line">        nodes = <span class="built_in">append</span>(nodes, *node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> newLevel []MerkleNode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nodes); j += <span class="number">2</span> &#123;</span><br><span class="line">            node := NewMerkleNode(&amp;nodes[j], &amp;nodes[j+<span class="number">1</span>], <span class="literal">nil</span>)</span><br><span class="line">            newLevel = <span class="built_in">append</span>(newLevel, *node)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nodes = newLevel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTree := MerkleTree&#123;&amp;nodes[<span class="number">0</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;mTree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个新的树被创建出来以后，首先要确保的是它有偶数片树叶。在这之后，数据（序列化交易记录的数组）将被转化为树叶，然后树从这些树叶开始生长。</p><p>现在，让我们修改 <code>Block.HashTransactions</code>，它被用在PoW 系统当中获取交易记录哈希值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">HashTransactions</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> transactions [][]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tx := <span class="keyword">range</span> b.Transactions &#123;</span><br><span class="line">        transactions = <span class="built_in">append</span>(transactions, tx.Serialize())</span><br><span class="line">    &#125;</span><br><span class="line">    mTree := NewMerkleTree(transactions)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mTree.RootNode.Data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，交易记录被序列化（采用 <code>encoding/gob</code>包），然后让他们来构建一个 <code>Merkle tree</code>。树根会用来作为区块的交易记录的唯一识别特征。</p><h1 id="P2PKH"><a href="#P2PKH" class="headerlink" title="P2PKH"></a>P2PKH</h1><p>还有一个事情我想要再详细讨论一下。</p><p>你还记得，在比特币当中有一个 脚本（Script）编程语言，用于交易记录输出的锁定；然后交易记录输入提供数据来对它进行解锁。这个语言本身非常简单，在这个语言当中编程知识一个数据和操作符的序列。看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">2</span> OP_ADD <span class="number">7</span> OP_EQUAL</span><br></pre></td></tr></table></figure><p>5，2，和7是数据。<code>OP_ADD</code> 和<code>OP_EQUAL</code> 是操作符。 <code>Script</code> 代码从左往右执行：每一段数据放入栈中（stack），后面的操作符作用于栈顶的数据。<code>Script</code> 的✅知识一个简单的FILO （先进后出）内存存储器：栈中的第一个数据最后被取用，后面来的的元素放到前面数据之前。</p><p>让我们分步执行前面的脚本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack: empty. Script: <span class="number">5</span> <span class="number">2</span> OP_ADD <span class="number">7</span> OP_EQUAL.</span><br><span class="line">Stack: <span class="number">5.</span> Script: <span class="number">2</span> OP_ADD <span class="number">7</span> OP_EQUAL.</span><br><span class="line">Stack: <span class="number">5</span> <span class="number">2.</span> Script: OP_ADD <span class="number">7</span> OP_EQUAL.</span><br><span class="line">Stack: <span class="number">7.</span> Script: <span class="number">7</span> OP_EQUAL.</span><br><span class="line">Stack: <span class="number">7</span> <span class="number">7.</span> Script: OP_EQUAL.</span><br><span class="line">Stack: <span class="literal">true</span>. Script: empty.</span><br></pre></td></tr></table></figure><p><code>OP_ADD</code> 从堆中取得两个元素，将他们相加，然后将结果放入堆中。<code>OP_EQUAL</code> 从堆中取得两个数据然后进行比较：假如它们相等就将<code>true</code>放入堆中；否则放入<code>false</code>. 一段脚本的执行结果是堆顶元素的值：在我们的案例中，它是真值（true），这意味着脚本成功的执行完成了。</p><p>现在让我们看看在比特币中执行支付的脚本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;signature&gt; &lt;pubKey&gt; OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br></pre></td></tr></table></figure><p>这段脚本叫做 <code>Pay to Public Key Hash (P2PKH)</code>，在比特币中这是最常用的一段脚本。它按照指令向一个公钥哈希进行支付，并用一个特定的公钥锁定比特币。这是比特币支付的核心：没有账户，没有账户之间的资金转移；只有一段检查输入的签名和公钥是匹配的脚本。</p><p>脚本分两部分进行存储：</p><ul><li>第一部分,<code>&lt;signature&gt; &lt;pubKey&gt;</code>, 存储在输入的<code>ScriptSig</code> 字段</li><li>第二部分, <code>OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</code> 存储在输出的 <code>ScriptPubKey</code> 字段<br>这样，它的输出定义了解锁逻辑，输入提供用于解锁输出的数据，让我们的执行这段脚本：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stack: empty</span><br><span class="line">Script: &lt;signature&gt; &lt;pubKey&gt; OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br><span class="line">Stack: &lt;signature&gt;</span><br><span class="line">Script: &lt;pubKey&gt; OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br><span class="line">Stack: &lt;signature&gt; &lt;pubKey&gt;</span><br><span class="line">Script: OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br><span class="line">Stack: &lt;signature&gt; &lt;pubKey&gt; &lt;pubKey&gt;</span><br><span class="line">Script: OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br><span class="line">Stack: &lt;signature&gt; &lt;pubKey&gt; &lt;pubKeyHash&gt;</span><br><span class="line">Script: &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br><span class="line">Stack: &lt;signature&gt; &lt;pubKey&gt; &lt;pubKeyHash&gt; &lt;pubKeyHash&gt;</span><br><span class="line">Script: OP_EQUALVERIFY OP_CHECKSIG</span><br><span class="line">Stack: &lt;signature&gt; &lt;pubKey&gt;</span><br><span class="line">Script: OP_CHECKSIG</span><br><span class="line">Stack: <span class="literal">true</span> or <span class="literal">false</span>. Script: empty.</span><br></pre></td></tr></table></figure><p><code>OP_DUP</code>复制栈顶的元素。<code>OP_HASH160</code>获得栈顶的元素用<code>RIPEMD160</code>算法对它进行哈希运算；结算结果重新放回栈中。</p><p><code>OP_EQUALVERIFY</code>比较连个堆顶的元素，如果两者不相等，结束脚本。<code>OP_CHECKSIG</code>通过对交易记录进行哈希计算以及<code>&lt;signature&gt;</code>和 <code>&lt;pubKey&gt;</code>数据验证一个交易记录的签名。后面的操作符非常复杂：首先不完整复制一份交易记录，求取哈希值（因为它是一个签名过的交易记录的哈希），然后用输入的<code>&lt;signature&gt;</code>和 <code>&lt;pubKey&gt;</code>验证签名是正确的。</p><p>有这样的脚本语言给比特币成为一个智能合约平台也创造了条件：脚本语言让其它的支付方案变得可能，不再是单一的比特币。</p><h1 id="结论-Conclusion"><a href="#结论-Conclusion" class="headerlink" title="结论 Conclusion"></a>结论 Conclusion</h1><p>然后就这样！我们已经基本实现了基于区块链的数字货币的所有特性。我们有区块链、地址、挖矿、还有交易记录。但是还有一个给这些机制以生命并让比特币成为一个全球系统：共识机制（consensus）。在下一篇文章当中，我们将开始开始实现区块链的“分布式”（decengtralized）部分。</p><p>敬请继续关注！</p><h1 id="链接-Links"><a href="#链接-Links" class="headerlink" title="链接 Links:"></a>链接 Links:</h1><ul><li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_6" target="_blank" rel="noopener">Full source codes</a></li><li><a href="https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2" target="_blank" rel="noopener">The UTXO Set</a>:_Data_Storage#The_UTXO_set_.28chainstate_leveldb.29)</li><li><a href="https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees" target="_blank" rel="noopener">Merkle Tree</a></li><li><a href="https://en.bitcoin.it/wiki/Script" target="_blank" rel="noopener">Script</a></li><li><a href="https://github.com/sipa/bitcoin/commit/450cbb0944cd20a06ce806e6679a1f4c83c50db2" target="_blank" rel="noopener">“Ultraprune” Bitcoin Core commit</a></li><li><a href="https://statoshi.info/dashboard/db/unspent-transaction-output-set" target="_blank" rel="noopener">UTXO set statistics</a></li><li><a href="https://medium.com/@maraoz/smart-contracts-and-bitcoin-a5d61011d9b1" target="_blank" rel="noopener">Smart contracts and Bitcoin</a></li><li><a href="https://medium.com/@jonaldfyookball/why-every-bitcoin-user-should-understand-spv-security-520d1d45e0b9" target="_blank" rel="noopener">Why every Bitcoin user should understand “SPV security”</a></li></ul>]]></content>
    
    <summary type="html">
    
      由于众所周知的原因，最近区块链又一次被推到了风口，下面转发几篇两年前翻译的首发于知乎关于如何用Go语言打造区块链的文章。Go语言是由google开发并于2009年发布的一种静态、强类型、编译型、并发型，并具有垃圾回收（GC）功能的编程语言，特别适用于分布式网络系统开发，而区块链（blockchain）本质上是一本在网络上分布存储的账本，这两者具有天然的匹配性，目前火热的[Ethereum Project](https://ethereum.org/)就是用go原生实现的。这一系列的文章是由[Ivan Kuznetsov](https://jeiwan.net/)所写，本人觉得是一个结合Go语言学习区块链技术的好资料，后面将用自己的语言翻译一遍，从第一篇开始，顺便对Go语言以及区块链有一个初步的认识。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="分布式" scheme="http://datacruiser.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据库" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="go" scheme="http://datacruiser.io/tags/go/"/>
    
      <category term="hash" scheme="http://datacruiser.io/tags/hash/"/>
    
      <category term="工作证明" scheme="http://datacruiser.io/tags/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/"/>
    
      <category term="交易" scheme="http://datacruiser.io/tags/%E4%BA%A4%E6%98%93/"/>
    
      <category term="命令行" scheme="http://datacruiser.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何用Go打造区块链（5）—地址</title>
    <link href="http://datacruiser.io/2019/11/06/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%885%EF%BC%89%E2%80%94%E5%9C%B0%E5%9D%80/"/>
    <id>http://datacruiser.io/2019/11/06/如何用Go打造区块链（5）—地址/</id>
    <published>2019-11-06T19:33:42.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍（Introduction）"><a href="#介绍（Introduction）" class="headerlink" title="介绍（Introduction）"></a>介绍（Introduction）</h1><p>在 <a href="http://datacruiser.io/2019/11/06/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%884%EF%BC%89%E2%80%94%E4%BA%A4%E6%98%93%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/">上一篇文章</a>中，我们开始实现了交易记录。大家也了解到了交易记录的内在本质：没有用户账户数据，不需要你的个人信息（比如姓名、护照号、身份证号码等）存储在比特币系统当中。但是依然需要一些东西能够证明你是交易记录输出的所有者（输出当中锁定着输出拥有者的币值）。这是需要有比特币地址（Bitcoin addresses）的原因。到目前为止我使用用户随机定义IDE字符串为地址，现在是时候实现实际的地址了，就像它在比特币中所实现的那样。</p><blockquote><p>这部分的代码改动很大，依然没有意义去解释所有的变动。可以到<a href="https://github.com/Jeiwan/blockchain_go/compare/part_4...part_5#files_bucket" target="_blank" rel="noopener">这个页面</a>去查看与上一篇文章之间的代码变动。</p></blockquote><h1 id="比特币地址（Bitcoin-Address）"><a href="#比特币地址（Bitcoin-Address）" class="headerlink" title="比特币地址（Bitcoin Address）"></a>比特币地址（Bitcoin Address）</h1><p>这是一个比特币地址的例子：<a href="https://www.blockchain.com/btc/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa" target="_blank" rel="noopener">1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</a>。这是第一个比特币地址，传闻属于中本聪本人。比特币地址是公开的。假如你想要向某人发送一些比特币，你需要知道他们的地址。但是地址（尽管是独一无二的）并不能证明你就是某一个“钱包”的主人。事实上，这样的地址只是一种公钥（public keys）大众可读的映射（human readable representation）。在比特币当中，通过一对存储在你的电脑或者其它你有权限进入的电脑的秘钥，公钥（public keys）和私钥来证明你对比特币的所有权。比特币依靠 一些列的加密算法来产生这些秘钥，确保在这个世界上没有人可以在没有物理得到你的秘钥的情况下进入你的比特币，让我们来讨论这些算法先。</p><h1 id="公钥加密（Public-ley-Cryptography）"><a href="#公钥加密（Public-ley-Cryptography）" class="headerlink" title="公钥加密（Public-ley Cryptography）"></a>公钥加密（Public-ley Cryptography）</h1><p>公钥加密算法需要一对秘钥：公钥和私钥。公钥并不敏感，可以透露给别人。相应的，私钥不能透露：因为私钥是所有者的身份证明，只有所有者才有权限查看。你就是你的私钥（在加密货币的世界里，必然的）。</p><p>本质上，一个比特币钱包就是一对这样的密钥（公钥和私钥）。当你安装钱包应用或者用一个比特币客户端来产生一个新的地址，一对密钥就这样的为了产生了。控制私钥的人掌握着所有发到这个地址的比特币。</p><p>私钥和公钥在表现上只是随机字节序列，因此无法直接阅读或者在屏幕上面打印。这也是为什么比特币采用一种将公钥转换为可读字符串算法的原因。</p><blockquote><p>如果你曾经使用过一个比特币钱包应用，它就像一个专门为你产生的助记口诀。这样的字段将代替私钥来使用并且能够通过它们产生私钥。这个机制在<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank" rel="noopener">BIP-039</a>中实现。</p></blockquote><p>好了，现在我们知道在比特币系统中用什么来标识用户。但是如何检查交易记录输出的所有权关系以及存储在里面的比特币？</p><h1 id="数字签名（Digital-Signatures）"><a href="#数字签名（Digital-Signatures）" class="headerlink" title="数字签名（Digital Signatures）"></a>数字签名（Digital Signatures）</h1><p>在数学以及密码学上，有一个数字签名的概念—能够保证以下几点的算法：</p><ul><li>从发送者到接收者的数据传递不会改变数据</li><li>数据由一个确定的发送者创建</li><li>发送者不能否认发送数据</li></ul><p>通过对数据应用签名算法（对数据进行签名），用户可以取得一个签名，随着这个签名可以得到验证。数字签名发生在私钥的使用上，然后需要一个公钥才能够得到验证。</p><p>为了对数据进行数字签名，我们需要以下东西：</p><ul><li>待签名的数据</li><li>私钥</li></ul><p>签名过程中所产生的签名将存储在交易记录输入当中。为了验证签名，需要具备以下条件：</p><ul><li>被签过名的数据</li><li>签名</li><li>公钥</li></ul><p>简单地说，验证过程可以描述如下：确认这个签名就是用一个私钥从这个数据中获得并用于产生相应的公钥。</p><blockquote><p>数据签名不是加密，你无法从一个签名当中重构出数据。它与哈希过程类似：你用对数据跑一遍哈希算法然后取得一个代表数据的独一无二的哈希值。签名与哈希之前的区别在于密钥对：这让签名的验证变得可能。<br>但是密钥对也可用于数据加密：私钥用于加密，公钥用于解密。虽然比特币并没有采用加密算法。</p></blockquote><p>比特币中每一个交易记录输入都被创建这个交易记录的人签过名。每一个交易记录在存入区块之前都必须得到验证。验证（除了其它程序）意味着：</p><ul><li>确认输入有权限使用来自上一个交易记录的输出</li><li>确认交易记录的签名是正确的</li></ul><p><img src="https://jeiwan.net/images/signing-scheme.png" alt=""></p><p>签名及验证过程示意图</p><p>现在让我们来看看一个交易记录的生命周期：</p><ul><li>开始的时候，只有创始区块包含币基交易记录。币基交易记录当中并没有实际的输入，因此并不需要签名。币基交易记录的输出包含一个哈希计算过的公钥（采用RIPEMD16(SHA256(PubKey))进行计算）</li><li>当一个人发送一个比特币，将创建一个交易记录。这个交易记录的输入将于前面一个交易记录的输出相对应。每一个输入将存储一个未哈希计算过的公钥和整个交易记录的签名</li><li>比特币网络中的其他收到这个交易记录的节点将会对它进行验证。除了其它事情，它们会确认：一个输入公钥的哈希与相对应的输出的哈希相匹配（这个确保发送者只是花了属于他们自己的比特币）；签名是正确的（确保交易记录由实际的比特币拥有者创建）</li><li>当一个挖矿节点准备去挖一个新的区块时，它首先在区块中放一个交易记录然后开始挖矿</li><li>当一个区块被挖出来以后，网络上的其它节点会收到一个信息，表示有一个新的区块产生并在大家验证以后被加入到区块链中</li><li>在区块被加入到区块链当中，交易记录便完成了，它的输出可以被新的交易记录引用</li></ul><h1 id="椭圆曲线密码学（Elliptic-Curve-Cryptography）"><a href="#椭圆曲线密码学（Elliptic-Curve-Cryptography）" class="headerlink" title="椭圆曲线密码学（Elliptic Curve Cryptography）"></a>椭圆曲线密码学（Elliptic Curve Cryptography）</h1><p>正如之前所描述的，公钥和私钥是随机字节序列。因为私钥会用于比特币拥有者的身份证明，因此需要一个条件：随机数算法必须能够产生真随机字节。我们并不希望产生一个会被多个人拥有的私钥。</p><p>比特币用椭圆曲线来产生私钥。椭圆曲线是一个复杂的数学概念，我们并不打算在这里详细解释（如果你够好奇，可以参考<a href="">椭圆曲线的产生</a>，警告：数学公式！）。我们所要知道的是这些曲线可以用来产生真的大随机数。比特币中所使用的曲线可以随机从$0~2^256$之间取一个数（大约$10^77$，在可见的宇宙范围内大约有$10^78$ 到 $10^82$个原子。）如此大的上限基本确保不太可能产生两次产生同一个私钥。</p><p>此外，比特币（包括我们）采用<code>ECDSA（Elliptic Curve Digital Signature Algorithm）</code>算法来对交易记录进行签名。</p><h1 id="Base58"><a href="#Base58" class="headerlink" title="Base58"></a>Base58</h1><p>现在让我回到前面提到过的比特币地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa.</span><br></pre></td></tr></table></figure><p>现在我们知道它是人类可读的一串公钥。如果我们对它进行解码，下面是公钥看起来的样子（以16进制书写的一串字节码）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0062E907</span>B15CBF27D5425399EBF6F0FB50EBB88F18C29B7D93</span><br></pre></td></tr></table></figure><p>比特币采用 <code>Base58</code>算法将公钥转换为人类可读的格式。这个算法与著名的<code>Base64</code>算法类似，不过采用更短的字母表：一些字符从字母表中删除以避免相似字符攻击。因此，以下字符不再字母表中：0（数字零），O（字母O），I（字母i），l（小写L），因为它们看起来很容易混淆。此外，+和/也没有。</p><p>让我们看一下如何从一个公钥产生地址的示意：</p><p><img src="https://jeiwan.net/images/address-generation-scheme.png" alt=""></p><p>这样，前面所提到的解码后的比特币地址（Bitcoin Address）包含三部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Version  Public key hash                           Checksum</span><br><span class="line"><span class="number">00</span>       <span class="number">62E907</span>B15CBF27D5425399EBF6F0FB50EBB88F18  C29B7D93</span><br></pre></td></tr></table></figure><p>因为哈希函数是单向不可逆的，从哈希值获得公钥是不可能的。但是我们可以通过将公钥代入存储的哈希函数看它所产生的哈希值并进行比较以确认某一个公钥是否对应一个特定的哈希。</p><p>好了，所有的相关概念已经介绍清楚了，让我们来写一些代码吧。在写代码的过程当中有些概念会变得更为清晰。</p><h1 id="地址的实现（Implementing-Addresses）"><a href="#地址的实现（Implementing-Addresses）" class="headerlink" title="地址的实现（Implementing Addresses）"></a>地址的实现（Implementing Addresses）</h1><p>我们将从钱包结构体开始：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Wallet <span class="keyword">struct</span> &#123;</span><br><span class="line">PrivateKey ecdsa.PrivateKey</span><br><span class="line">PublicKey  []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wallets <span class="keyword">struct</span> &#123;</span><br><span class="line">Wallets <span class="keyword">map</span>[<span class="keyword">string</span>]*Wallet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWallet</span><span class="params">()</span> *<span class="title">Wallet</span></span> &#123;</span><br><span class="line">private, public := newKeyPair()</span><br><span class="line">wallet := Wallet&#123;private, public&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;wallet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newKeyPair</span><span class="params">()</span> <span class="params">(ecdsa.PrivateKey, []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">curve := elliptic.P256()</span><br><span class="line">private, err := ecdsa.GenerateKey(curve, rand.Reader)</span><br><span class="line">pubKey := <span class="built_in">append</span>(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *private, pubKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个钱包只是一对密钥。我们同样需要钱包门（Wallets）类型来保存钱包的一个集合，保存到一个文件，并从文件中载入钱包。在钱包的构造函数当中一对新的密钥产生。<code>newKeyPair</code>函数非常清晰明了：<code>ECDSA</code>是基于椭圆曲线算法，所以我们需要一个。下一步，通过曲线产生一个私钥，公钥从私钥产生。有一点需要注意：在基于椭圆曲线的算法当中，公钥是曲线上面的点。这样，一个公钥是一个（X，Y）坐标的组合。在比特币当中，这些坐标被连接起来然后现成一个公钥。</p><p>现在，让我们来产生一个地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Wallet)</span> <span class="title">GetAddress</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">pubKeyHash := HashPubKey(w.PublicKey)</span><br><span class="line"></span><br><span class="line">versionedPayload := <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;version&#125;, pubKeyHash...)</span><br><span class="line">checksum := checksum(versionedPayload)</span><br><span class="line"></span><br><span class="line">fullPayload := <span class="built_in">append</span>(versionedPayload, checksum...)</span><br><span class="line">address := Base58Encode(fullPayload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HashPubKey</span><span class="params">(pubKey []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">publicSHA256 := sha256.Sum256(pubKey)</span><br><span class="line"></span><br><span class="line">RIPEMD160Hasher := ripemd160.New()</span><br><span class="line">_, err := RIPEMD160Hasher.Write(publicSHA256[:])</span><br><span class="line">publicRIPEMD160 := RIPEMD160Hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> publicRIPEMD160</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checksum</span><span class="params">(payload []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">firstSHA := sha256.Sum256(payload)</span><br><span class="line">secondSHA := sha256.Sum256(firstSHA[:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> secondSHA[:addressChecksumLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是将一个公钥转化为一个 <code>Base58</code>地址的步骤：</p><ul><li>取得公钥然后用<code>RIPEMD160(SHA256(PubKey)</code>算法对它进行两次哈希计算</li><li>预先将地址产生算法的版本给哈希</li><li>用<code>SHA256(SHA256(payload))</code> 哈希计算步骤2的结果来获得 <code>checksum</code>。<code>checksum</code> 是所得哈希值的前四个字节</li><li>将<code>checksum</code> 加到<code>version + PubKeyHash</code> 组合后面</li><li>对<code>version + PubKeyHash + checksum</code> 组合进行<code>Base58</code> 编码</li></ul><p>根据以上步骤，我们可以获得一个实际的比特币地址，你甚至可以到 blockchain.info 上去检查它的余额。但是我能够确保不过你尝试多少次所能够查询到的余额都是0。这就是选择合适的公钥加密算法如此重要的原因：考虑到私钥是随机数，产生相同随机数的机会应该尽可能地低。理想的，应该是几乎不可能。</p><p>同时，你并不需要连接到一个比特币节点就能够产生地址。地址产生算法采用了由许多程序语言和库实现的开源算法组合。</p><p>现在我们需要修改输入和输出代码来使用前面产生的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TXInput <span class="keyword">struct</span> &#123;</span><br><span class="line">Txid      []<span class="keyword">byte</span></span><br><span class="line">Vout      <span class="keyword">int</span></span><br><span class="line">Signature []<span class="keyword">byte</span></span><br><span class="line">PubKey    []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *TXInput)</span> <span class="title">UsesKey</span><span class="params">(pubKeyHash []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">lockingHash := HashPubKey(in.PubKey)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bytes.Compare(lockingHash, pubKeyHash) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TXOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">Value      <span class="keyword">int</span></span><br><span class="line">PubKeyHash []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(out *TXOutput)</span> <span class="title">Lock</span><span class="params">(address []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">pubKeyHash := Base58Decode(address)</span><br><span class="line">pubKeyHash = pubKeyHash[<span class="number">1</span> : <span class="built_in">len</span>(pubKeyHash)<span class="number">-4</span>]</span><br><span class="line">out.PubKeyHash = pubKeyHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(out *TXOutput)</span> <span class="title">IsLockedWithKey</span><span class="params">(pubKeyHash []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> bytes.Compare(out.PubKeyHash, pubKeyHash) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们不再使用 <code>ScriptPubKey</code>和 <code>ScriptSig</code>字段，因为我们并不打算实现一个脚本语言。相应的的，<code>ScriptSig</code>分解为签名过的<code>PubKey</code>字段，而 <code>ScriptPubKey</code>被重命名为 <code>PubKeyHash</code>。我们将实现比特币中的输出 锁定/解锁 以及输出签名的逻辑，不过采用了其它的方法。</p><p><code>UsesKey</code> 方法检查一个输入是否可以用一个特定的密钥去解锁一个输出。需要注意的输入存储的是原始的公钥（未哈希计算过的），但是这个函数采用的是哈希过的。 <code>IsLockedWithKey</code>检查提供的公钥哈希是否是用于去锁定输出。这是对<code>UsesKey</code>函数的补充，它们都在 <code>FindUnspendTransactions</code>当中用于构建交易记录之间的连接。</p><p>锁将输出简单地锁定了。当我们向其他人发送比特币，我只知道它们的地址，地址也是函数的唯一参数。然后地址被解码，然后抽取出公钥哈希值存入 PubKeyHash 字段。</p><p>现在，让我检查一下一切工作正常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go createwallet</span><br><span class="line">Your <span class="built_in">new</span> address: <span class="number">13</span>Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt</span><br><span class="line"></span><br><span class="line">$ blockchain_go createwallet</span><br><span class="line">Your <span class="built_in">new</span> address: <span class="number">15</span>pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h</span><br><span class="line"></span><br><span class="line">$ blockchain_go createwallet</span><br><span class="line">Your <span class="built_in">new</span> address: <span class="number">1</span>Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy</span><br><span class="line"></span><br><span class="line">$ blockchain_go createblockchain -address <span class="number">13</span>Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt</span><br><span class="line"><span class="number">0000005420f</span>bfdafa00c093f56e033903ba43599fa7cd9df40458e373eee724d</span><br><span class="line"></span><br><span class="line">Done!</span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address <span class="number">13</span>Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt</span><br><span class="line">Balance of <span class="string">'13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt'</span>: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go send -from <span class="number">15</span>pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -to <span class="number">13</span>Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -amount <span class="number">5</span></span><br><span class="line"><span class="number">2017</span>/<span class="number">09</span>/<span class="number">12</span> <span class="number">13</span>:<span class="number">08</span>:<span class="number">56</span> ERROR: Not enough funds</span><br><span class="line"></span><br><span class="line">$ blockchain_go send -from <span class="number">13</span>Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -to <span class="number">15</span>pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -amount <span class="number">6</span></span><br><span class="line"><span class="number">00000019</span>afa909094193f64ca06e9039849709f5948fbac56cae7b1b8f0ff162</span><br><span class="line"></span><br><span class="line">Success!</span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address <span class="number">13</span>Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt</span><br><span class="line">Balance of <span class="string">'13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt'</span>: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address <span class="number">15</span>pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h</span><br><span class="line">Balance of <span class="string">'15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h'</span>: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address <span class="number">1</span>Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy</span><br><span class="line">Balance of <span class="string">'1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy'</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>非常好！现在让我们来实现交易记录签名。</p><h1 id="实现签名（Implementing-Signatures）"><a href="#实现签名（Implementing-Signatures）" class="headerlink" title="实现签名（Implementing Signatures）"></a>实现签名（Implementing Signatures）</h1><p>交易记录必须签过名，因为在比特币中这是保证一个人无法使用不属于他的比特币的唯一方式。如果一个签名是非法的，交易记录也会被认为是非法的，无法加入到区块链当中。</p><p>我们已经有实现交易记录签名的所有东西，除了一件事情：用来签名的数据。交易记录的哪部分实际上是签过名的？或者一整个交易记录整体的签名？数字签名的选择非常重要。要求是用来签名的数据必须包含能够用唯一的方式识别数据的信息。举个例子，如果 对输出包含的币值进行签名是没有意义的，因为这个签名并不会考虑发送者和接收者。</p><p>考虑到交易记录解锁前一个输出，重新分配它们的币值，然后锁定新的输出，以下数据必须进行数字签名：</p><ul><li>未解锁输出中保存的公钥哈希值。这会识别一个交易记录的“发送者”。</li><li>新的锁定的输出中存储的公钥哈希值。这会识别一个交易的“接收者”。</li><li>新输出所包含的币值。</li></ul><blockquote><p>在比特币当中，锁定/解锁的逻辑存储在脚本当中，分别存储在输入的 ScriptSigand 字段和输出的 ScriptPubKey 字段。因为比特币允许不同类型的脚本，它还会对 ScriptPubKey 的全部内容进行签名。</p></blockquote><p>正如你所看到的，我们并不需要对输入当中存储的公钥进行签名。正因为如此，在比特币当中，这不是一个签过名的交易记录，而是它的带从引用的输出中来输入存储的 ScriptPubKey 字段的截取过的拷贝。</p><blockquote><p>取得整理过的交易记录拷贝的详细过程在这里描述。这个可能有些过期，但是我无法找到一个更可靠的信息来源。</p></blockquote><p>Ok，这看起来有些复杂，那么就让我们开始编程吧。我们从 <code>Sign</code>方法开始：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Sign</span><span class="params">(privKey ecdsa.PrivateKey, prevTXs <span class="keyword">map</span>[<span class="keyword">string</span>]Transaction)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> tx.IsCoinbase() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txCopy := tx.TrimmedCopy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> inID, vin := <span class="keyword">range</span> txCopy.Vin &#123;</span><br><span class="line">prevTx := prevTXs[hex.EncodeToString(vin.Txid)]</span><br><span class="line">txCopy.Vin[inID].Signature = <span class="literal">nil</span></span><br><span class="line">txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash</span><br><span class="line">txCopy.ID = txCopy.Hash()</span><br><span class="line">txCopy.Vin[inID].PubKey = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, txCopy.ID)</span><br><span class="line">signature := <span class="built_in">append</span>(r.Bytes(), s.Bytes()...)</span><br><span class="line"></span><br><span class="line">tx.Vin[inID].Signature = signature</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法以一个私钥和之前的交易记录的<code>map</code>数据为输入。正如之前所言，为了对一个交易记录进行签名，我们需要进入这个交易记录当中的输入所引用的输出，因此我们需要存储这些输出的交易记录。</p><p>让我们一条条过这个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tx.IsCoinbase() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为币基交易记录中没有实际的输入所以不会被签名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txCopy := tx.TrimmedCopy()</span><br></pre></td></tr></table></figure><p>截取过的交易记录拷贝会被签名，并不对整个交易记录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">TrimmedCopy</span><span class="params">()</span> <span class="title">Transaction</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> inputs []TXInput</span><br><span class="line"><span class="keyword">var</span> outputs []TXOutput</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, vin := <span class="keyword">range</span> tx.Vin &#123;</span><br><span class="line">inputs = <span class="built_in">append</span>(inputs, TXInput&#123;vin.Txid, vin.Vout, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, vout := <span class="keyword">range</span> tx.Vout &#123;</span><br><span class="line">outputs = <span class="built_in">append</span>(outputs, TXOutput&#123;vout.Value, vout.PubKeyHash&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txCopy := Transaction&#123;tx.ID, inputs, outputs&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> txCopy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这份拷贝会包含所有的输入和输出，但是 <code>TXInput.Signature</code>和<code>TXInput.PubKey</code>字段会被设为 <code>nil</code>。</p><p>下一步，我们会遍历这份拷贝中的所有输入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> inID, vin := <span class="keyword">range</span> txCopy.Vin &#123;</span><br><span class="line">prevTx := prevTXs[hex.EncodeToString(vin.Txid)]</span><br><span class="line">txCopy.Vin[inID].Signature = <span class="literal">nil</span></span><br><span class="line">txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash</span><br></pre></td></tr></table></figure><p>在每一个输入当中，签名被设置为 <code>nil</code> （只是再次确认），并且 <code>PubKey</code>被设为引用的输出的 <code>PubKeyHash</code>。在这个时候，所有的交易记录，除了当前的交易记录都是“空的”（empty）。它们的 <code>Signature</code>和 <code>PubKey</code>字段被设为 <code>nil</code>。这样，输入会被单独的签名，虽然在我们的程序当中这并不需要，但是比特币允许交易记录包含引用不同地址的输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txCopy.ID = txCopy.Hash()</span><br><span class="line">txCopy.Vin[inID].PubKey = nil</span><br></pre></td></tr></table></figure><p><code>Hash</code>方法将交易记录序列化并用<code>SHA-256</code>算法进行哈希值计算。得到的哈希值是我们要进行签名的数据。得到这个哈希值以后我们应该重新设置 <code>PubKey</code>字段，以让他们对后面的遍历没有影响。</p><p>现在，最关键的代码段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, txCopy.ID)</span><br><span class="line">signature := <span class="built_in">append</span>(r.Bytes(), s.Bytes()...)</span><br><span class="line"></span><br><span class="line">tx.Vin[inID].Signature = signature</span><br></pre></td></tr></table></figure><p>我们用<code>privKey</code>对<code>txCopy.ID</code>进行签名。一个<code>ECDSA</code>签名是一对数字，是我们组合并存储在输入的 <code>Signature</code>字段当中的数字。</p><p>接下来，验证函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Verify</span><span class="params">(prevTXs <span class="keyword">map</span>[<span class="keyword">string</span>]Transaction)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">txCopy := tx.TrimmedCopy()</span><br><span class="line">curve := elliptic.P256()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> inID, vin := <span class="keyword">range</span> tx.Vin &#123;</span><br><span class="line">prevTx := prevTXs[hex.EncodeToString(vin.Txid)]</span><br><span class="line">txCopy.Vin[inID].Signature = <span class="literal">nil</span></span><br><span class="line">txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash</span><br><span class="line">txCopy.ID = txCopy.Hash()</span><br><span class="line">txCopy.Vin[inID].PubKey = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">r := big.Int&#123;&#125;</span><br><span class="line">s := big.Int&#123;&#125;</span><br><span class="line">sigLen := <span class="built_in">len</span>(vin.Signature)</span><br><span class="line">r.SetBytes(vin.Signature[:(sigLen / <span class="number">2</span>)])</span><br><span class="line">s.SetBytes(vin.Signature[(sigLen / <span class="number">2</span>):])</span><br><span class="line"></span><br><span class="line">x := big.Int&#123;&#125;</span><br><span class="line">y := big.Int&#123;&#125;</span><br><span class="line">keyLen := <span class="built_in">len</span>(vin.PubKey)</span><br><span class="line">x.SetBytes(vin.PubKey[:(keyLen / <span class="number">2</span>)])</span><br><span class="line">y.SetBytes(vin.PubKey[(keyLen / <span class="number">2</span>):])</span><br><span class="line"></span><br><span class="line">rawPubKey := ecdsa.PublicKey&#123;curve, &amp;x, &amp;y&#125;</span><br><span class="line"><span class="keyword">if</span> ecdsa.Verify(&amp;rawPubKey, txCopy.ID, &amp;r, &amp;s) == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法非常简单明了。首先，我们需要同样的交易记录拷贝：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txCopy := tx.TrimmedCopy()</span><br></pre></td></tr></table></figure><p>接下来，我们需要与产生密钥对相同的曲线：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curve := elliptic.P256()</span><br></pre></td></tr></table></figure><p>接下来，我们检查每一个输入当中的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> inID, vin := <span class="keyword">range</span> tx.Vin &#123;</span><br><span class="line">prevTx := prevTXs[hex.EncodeToString(vin.Txid)]</span><br><span class="line">txCopy.Vin[inID].Signature = <span class="literal">nil</span></span><br><span class="line">txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash</span><br><span class="line">txCopy.ID = txCopy.Hash()</span><br><span class="line">txCopy.Vin[inID].PubKey = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>这段是与<code>Sign</code> 方法中完全相同的，因为在验证阶段我们需要与签名时完全一样的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r := big.Int&#123;&#125;</span><br><span class="line">s := big.Int&#123;&#125;</span><br><span class="line">sigLen := <span class="built_in">len</span>(vin.Signature)</span><br><span class="line">r.SetBytes(vin.Signature[:(sigLen / <span class="number">2</span>)])</span><br><span class="line">s.SetBytes(vin.Signature[(sigLen / <span class="number">2</span>):])</span><br><span class="line"></span><br><span class="line">x := big.Int&#123;&#125;</span><br><span class="line">y := big.Int&#123;&#125;</span><br><span class="line">keyLen := <span class="built_in">len</span>(vin.PubKey)</span><br><span class="line">x.SetBytes(vin.PubKey[:(keyLen / <span class="number">2</span>)])</span><br><span class="line">y.SetBytes(vin.PubKey[(keyLen / <span class="number">2</span>):])</span><br></pre></td></tr></table></figure><p>这里解压存储在<code>TXInput.Signature</code> 和<code>TXInput.PubKey</code> 中的数据，因为一个签名是一对数字，而一个公钥是一对坐标。早先的时候为了保存，我们将他们组合在一起，现在我们需要将它们解压出来在加密当中使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rawPubKey := ecdsa.PublicKey&#123;curve, &amp;x, &amp;y&#125;</span><br><span class="line"><span class="keyword">if</span> ecdsa.Verify(&amp;rawPubKey, txCopy.ID, &amp;r, &amp;s) == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>现在我们用从输入获取的公钥创建一个 <code>ecdsa.PublicKey</code>，然后将从输入获取的签名传递给<code>ecdsa.Verify</code>并执行验证。加入所有的输入都能够得到验证，返回<code>true</code>；即便只有一个输入验证失败，返回<code>false</code>。</p><p>现在，我们需要一个函数来获得之前的交易记录。因为这需要与区块链交互，我们将它定义成一个 <code>Blockchain</code>的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">FindTransaction</span><span class="params">(ID []<span class="keyword">byte</span>)</span> <span class="params">(Transaction, error)</span></span> &#123;</span><br><span class="line">bci := bc.Iterator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">block := bci.Next()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line"><span class="keyword">if</span> bytes.Compare(tx.ID, ID) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *tx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Transaction&#123;&#125;, errors.New(<span class="string">"Transaction is not found"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">SignTransaction</span><span class="params">(tx *Transaction, privKey ecdsa.PrivateKey)</span></span> &#123;</span><br><span class="line">prevTXs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Transaction)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, vin := <span class="keyword">range</span> tx.Vin &#123;</span><br><span class="line">prevTX, err := bc.FindTransaction(vin.Txid)</span><br><span class="line">prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tx.Sign(privKey, prevTXs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">VerifyTransaction</span><span class="params">(tx *Transaction)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">prevTXs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Transaction)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, vin := <span class="keyword">range</span> tx.Vin &#123;</span><br><span class="line">prevTX, err := bc.FindTransaction(vin.Txid)</span><br><span class="line">prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tx.Verify(prevTXs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些函数非常简单：<code>FindTransaction</code> 函数通过ID（这个需要遍历区块链中的所有区块）来找交易记录；<code>SignTransaction</code> 函数获得一个交易记录，找到它所引用的交易记录然后对它进行签名；<code>VerifyTransaction</code>函数同样，只是对交易记录进行验证。</p><p>现在，我们需要实际签名和验证交易记录。签名在 <code>NewUTXOTransaction</code> 函数当中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUTXOTransaction</span><span class="params">(from, to <span class="keyword">string</span>, amount <span class="keyword">int</span>, bc *Blockchain)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">tx := Transaction&#123;<span class="literal">nil</span>, inputs, outputs&#125;</span><br><span class="line">tx.ID = tx.Hash()</span><br><span class="line">bc.SignTransaction(&amp;tx, wallet.PrivateKey)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证发生在将一个交易记录放入一个区块之前：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">MineBlock</span><span class="params">(transactions []*Transaction)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> lastHash []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> transactions &#123;</span><br><span class="line"><span class="keyword">if</span> bc.VerifyTransaction(tx) != <span class="literal">true</span> &#123;</span><br><span class="line">log.Panic(<span class="string">"ERROR: Invalid transaction"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就这样！让我们再一次确认所有的步骤和流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go createwallet</span><br><span class="line">Your <span class="built_in">new</span> address: <span class="number">1</span>AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR</span><br><span class="line"></span><br><span class="line">$ blockchain_go createwallet</span><br><span class="line">Your <span class="built_in">new</span> address: <span class="number">1</span>NE86r4Esjf53EL7fR86CsfTZpNN42Sfab</span><br><span class="line"></span><br><span class="line">$ blockchain_go createblockchain -address <span class="number">1</span>AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR</span><br><span class="line"><span class="number">000000122348d</span>a06c19e5c513710340f4c307d884385da948a205655c6a9d008</span><br><span class="line"></span><br><span class="line">Done!</span><br><span class="line"></span><br><span class="line">$ blockchain_go send -from <span class="number">1</span>AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to <span class="number">1</span>NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount <span class="number">6</span></span><br><span class="line"><span class="number">0000000f</span>3dbb0ab6d56c4e4b9f7479afe8d5a5dad4d2a8823345a1a16cf3347b</span><br><span class="line"></span><br><span class="line">Success!</span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address <span class="number">1</span>AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR</span><br><span class="line">Balance of <span class="string">'1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR'</span>: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address <span class="number">1</span>NE86r4Esjf53EL7fR86CsfTZpNN42Sfab</span><br><span class="line">Balance of <span class="string">'1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab'</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure><p>非常棒！一切正常！</p><p>让我们将 <code>NewUTXOTransaction</code>函数中的<code>bc.SignTransaction(&amp;tx, wallet.PrivateKey)</code>注释掉来确保不能对未签名的交易记录进行挖矿：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUTXOTransaction</span><span class="params">(from, to <span class="keyword">string</span>, amount <span class="keyword">int</span>, bc *Blockchain)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">tx := Transaction&#123;<span class="literal">nil</span>, inputs, outputs&#125;</span><br><span class="line">tx.ID = tx.Hash()</span><br><span class="line"><span class="comment">// bc.SignTransaction(&amp;tx, wallet.PrivateKey)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> install</span><br><span class="line">$ blockchain_go send -from <span class="number">1</span>AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to <span class="number">1</span>NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount <span class="number">1</span></span><br><span class="line"><span class="number">2017</span>/<span class="number">09</span>/<span class="number">12</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">15</span> ERROR: Invalid transaction</span><br></pre></td></tr></table></figure><h1 id="结论（Conclusion）"><a href="#结论（Conclusion）" class="headerlink" title="结论（Conclusion）"></a>结论（Conclusion）</h1><p>我们能够走得这么远实现这么多比特币的关键特性非常了不起。除了网络部分，我们几乎实现了所有，在下一部分，我们将完成交易记录部分。</p><h1 id="链接（Links-）"><a href="#链接（Links-）" class="headerlink" title="链接（Links:）"></a>链接（Links:）</h1><ul><li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_5" target="_blank" rel="noopener">Full source codes</a></li><li><a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">Public-key cryptography</a></li><li><a href="https://en.wikipedia.org/wiki/Digital_signature" target="_blank" rel="noopener">Digital signatures</a></li><li><a href="https://en.wikipedia.org/wiki/Elliptic_curve" target="_blank" rel="noopener">Elliptic curve</a></li><li><a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography" target="_blank" rel="noopener">Elliptic curve cryptography</a></li><li><a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" rel="noopener">ECDSA</a></li><li><a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses" target="_blank" rel="noopener">Technical background of Bitcoin addresses</a></li><li><a href="https://en.bitcoin.it/wiki/Address" target="_blank" rel="noopener">Address</a></li><li><a href="https://en.bitcoin.it/wiki/Base58Check_encoding" target="_blank" rel="noopener">Base58</a></li><li><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" target="_blank" rel="noopener">A gentle introduction to elliptic curve cryptography</a></li></ul>]]></content>
    
    <summary type="html">
    
      由于众所周知的原因，最近区块链又一次被推到了风口，下面转发几篇两年前翻译的首发于知乎关于如何用Go语言打造区块链的文章。Go语言是由google开发并于2009年发布的一种静态、强类型、编译型、并发型，并具有垃圾回收（GC）功能的编程语言，特别适用于分布式网络系统开发，而区块链（blockchain）本质上是一本在网络上分布存储的账本，这两者具有天然的匹配性，目前火热的[Ethereum Project](https://ethereum.org/)就是用go原生实现的。这一系列的文章是由[Ivan Kuznetsov](https://jeiwan.net/)所写，本人觉得是一个结合Go语言学习区块链技术的好资料，后面将用自己的语言翻译一遍，从第一篇开始，顺便对Go语言以及区块链有一个初步的认识。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="分布式" scheme="http://datacruiser.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据库" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="go" scheme="http://datacruiser.io/tags/go/"/>
    
      <category term="hash" scheme="http://datacruiser.io/tags/hash/"/>
    
      <category term="工作证明" scheme="http://datacruiser.io/tags/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/"/>
    
      <category term="交易" scheme="http://datacruiser.io/tags/%E4%BA%A4%E6%98%93/"/>
    
      <category term="命令行" scheme="http://datacruiser.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何用Go打造区块链（4）—交易记录（一）</title>
    <link href="http://datacruiser.io/2019/11/06/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%884%EF%BC%89%E2%80%94%E4%BA%A4%E6%98%93%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://datacruiser.io/2019/11/06/如何用Go打造区块链（4）—交易记录（一）/</id>
    <published>2019-11-06T17:19:33.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍（Introduction）"><a href="#介绍（Introduction）" class="headerlink" title="介绍（Introduction）"></a>介绍（Introduction）</h1><p>交易记录是比特币的核心，用区块链的目的是想以一种安全和可靠的方式来存储交易记录，使得无人可以在它们被创建以后再修改它们。今天我们将开始实现交易记录。不过这是一个非常大的话题，我将把这部分内容分成两部分：在这部分当中，我们会实现交易记录的通用机制，在第二部分会实现具体细节。</p><p>然后，因为代码改动非常大，对所有代码进行描述变得不太有意义。要查阅所有的代码变得可以点击<a href="https://github.com/Jeiwan/blockchain_go/compare/part_3...part_4#files_bucket" target="_blank" rel="noopener">这里</a>。</p><h1 id="这里没有调羹（There-is-no-spoon）"><a href="#这里没有调羹（There-is-no-spoon）" class="headerlink" title="这里没有调羹（There is no spoon）"></a>这里没有调羹（There is no spoon）</h1><p>假如你曾经开发过web应用，为了实现支付你应该会在数据库中创建这样的一些表：账户（accounts）和交易记录（transactions）。一个账户会存储每个用户的信息，包括他们的个人信息和资产负债表，而一个交易记录会存储货币如何从一个账户转到另外一个账户。在比特币当中，支付是采用完全不同的方式实现的。主要特点如下：</p><ul><li>没有账户</li><li>没有资产负债表</li><li>没有地址</li><li>没有货币</li><li>没有支付方和接收方</li></ul><p>因为区块链是一个公共、开发的数据库，我们不打算存储钱包拥有者的敏感信息。币也不集中在某一个账户。交易记录也把钱从一个账户转移到另一个账户。也没有账户资产负债情况的信息和特性。仅仅只有交易记录（transactions）。然后在交易记录当中究竟有什么呢？</p><h1 id="比特币交易记录（Bitcoin-Transaction）"><a href="#比特币交易记录（Bitcoin-Transaction）" class="headerlink" title="比特币交易记录（Bitcoin Transaction）"></a>比特币交易记录（Bitcoin Transaction）</h1><p>一条交易记录是所有输入（inputs）和输出（outputs）的合并：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">ID   []<span class="keyword">byte</span></span><br><span class="line">Vin  []TXInput</span><br><span class="line">Vout []TXOutput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一条新的交易记录的所有输入与之前交易记录的所有输出相对应（有一个例外，一会儿我们会讨论）。输出是实际存储比特币的地方。下面的示意图展示了交易记录之间的内部关系：</p><p><img src="https://jeiwan.net/images/transactions-diagram.png" alt=""></p><p>注意以下几点：</p><ul><li>有一些输出并不与输入相对应</li><li>在一个交易记录当中，输入可以与来自不同交易记录的输出相对应</li><li>一个输入只能对于一个输出，但是一个输出可以对应多个输入，比如有多个人向同一个人转账</li></ul><p>在这边文章当中，我们将会用到这样的名词：“金钱（money）”，“货币（coins）”，“消费（spend）”，“发送（send）”，“账户（account）”等。但是在比特币当中没有这样对于的概念。交易记录通过一段脚本将价值锁定，并且只能由锁定它们的人来解锁。</p><h1 id="交易记录输出（Transaction-Outputs）"><a href="#交易记录输出（Transaction-Outputs）" class="headerlink" title="交易记录输出（Transaction Outputs）"></a>交易记录输出（Transaction Outputs）</h1><p>让我们从输出开始：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TXOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">Value        <span class="keyword">int</span></span><br><span class="line">ScriptPubKey <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，这里的输出存储着“币值（coins）”（可以参阅上面的 Value 变量）。保存便意味着用一段口令将它锁定， 而这段口令保存在 <code>ScriptPubKey</code>中。在比特币内部使用一个叫做<code>Script</code>的脚本语言，用来定义输出的锁定和解锁逻辑。这个脚本语言非常接近底层（刻意如此设计，是为了避免可能的滥用和攻击），在此我们不对它进行详细讨论。你可以点击<a href="https://en.bitcoin.it/wiki/Script" target="_blank" rel="noopener">这里</a>查看详细的解释。</p><blockquote><p>在比特币中，value 字段用来保存 satoshis （聪）的数量，而不是比特币（BTC1）的数量。一比特币等于1000万个聪，聪目前是比特币系统中最小的货币单位（就像美分在美元系统中的地位一样）。</p></blockquote><p>由于我们没有实现任何地址相关的内容，目前我们就避免讨论。ScriptPubKey 字段会存储一段随机字符串（用户自定义的钱包地址）</p><blockquote><p>顺便提一句，因为有这样的脚本语言的存在意味着比特币也能够用作智能合约平台</p></blockquote><p>输出的一个重要特性是 <strong>不可分割性</strong>，意味着你能够提及其值的一部分。当一个输出在一个新的交易记录当中被提到，它会花掉它的全部。当它的价值比所需要的大，会产生找零然后返回给发出的人。这与现实生活中的场景类似，当你为某价值1元的东西支付5元会得到4元的找零。</p><h1 id="交易记录输入（Transaction-Inputs）"><a href="#交易记录输入（Transaction-Inputs）" class="headerlink" title="交易记录输入（Transaction Inputs）"></a>交易记录输入（Transaction Inputs）</h1><p>然后接下来是输入（inputs）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TXInput <span class="keyword">struct</span> &#123;</span><br><span class="line">Txid      []<span class="keyword">byte</span></span><br><span class="line">Vout      <span class="keyword">int</span></span><br><span class="line">ScriptSig <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前已经提到，一个输入对应前一个输出：<code>Txid</code> 字段存储这样一条交易记录的<code>ID</code>，<code>Vout</code> 字段存储交易记录当中输出的索引。<code>ScriptSig</code> 字段是一段向输出的 <code>ScriptPubKey</code> 字段中提供数据的脚本。如果数据正确的话，输出将会被解锁，然后其含的价值（value）可以用来产生新的输出；如果不正确的话，输出将无法被输入引用，无法建立连接。这个机制是为了保证用户不能花属于别人的比特币。</p><p>再一次的，因为我们没有实现地址，在我们的实现当中 <code>ScriptSig</code> 字段只是一段随机字符串保存用户定义的钱包地址。我们将在下一篇文章当中实现公钥（public keys）和签名（signatures）检查。</p><p>让我见到总结一下。输出是“币”存储的地方。每一个输出会带一段解锁的脚本（字符串），决定了解锁输出的逻辑。每一个新的交易记录只是有一个输入和一个输出。一个输入对应一个从前一个交易记录（transaction）来的输出并提供用于解锁（unlocking）输出的数据以便使用输出中的币值（value）来创建新的输出（outputs）</p><p>但是哪个先出现呢：输入还是输出？</p><h1 id="“先有鸡还是先有蛋”（The-egg）"><a href="#“先有鸡还是先有蛋”（The-egg）" class="headerlink" title="“先有鸡还是先有蛋”（The egg）"></a>“先有鸡还是先有蛋”（The egg）</h1><p>在比特币当中，蛋是在鸡之前出现的。“输入对应输出”的逻辑与“鸡或者蛋”的场景类似：输入产生输出，输出让输入变得可能。在比特币当中，输出在输入之前出现。</p><p>当一个矿工开始挖坑（mining a block），将在区块当中添加币基交易记录（coinbase transaction）。币基交易记录是一种特殊的交易记录，并不需要已经存在的输出就能够产生。它可以从无直接创造出输出。相当于不需要鸡的蛋。这是矿工在挖新区块时获得的奖励。</p><p>正如你所知，在区块链当中有一个创世区块。正是这个创世区块在区块链中产生最新的输出。并不需要已有的输出，因为也没有已存在的交易记录和这样的输出可供使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCoinbaseTX</span><span class="params">(to, data <span class="keyword">string</span>)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> data == <span class="string">""</span> &#123;</span><br><span class="line">data = fmt.Sprintf(<span class="string">"Reward to '%s'"</span>, to)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txin := TXInput&#123;[]<span class="keyword">byte</span>&#123;&#125;, <span class="number">-1</span>, data&#125;</span><br><span class="line">txout := TXOutput&#123;subsidy, to&#125;</span><br><span class="line">tx := Transaction&#123;<span class="literal">nil</span>, []TXInput&#123;txin&#125;, []TXOutput&#123;txout&#125;&#125;</span><br><span class="line">tx.SetID()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个币基交易记录只有一个输入。在我们的实现当中它的<code>Txid</code>字段是空的，<code>Vout</code>字段为-1。而且，币基交易记录的<code>ScriptSig</code>字段并不保存脚本。相应的，存储随机数据。</p><blockquote><p>在比特币当中，最早的币基交易记录包含以下信息：“The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”。你可以点击<a href="https://www.blockchain.com/btc/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b?show_adv=true" target="_blank" rel="noopener">这里</a>自我查阅。</p></blockquote><p><code>subsidy</code> 字段是奖励的数量。在比特币当中，这个数据不在任何地方保存，只是根据总的区块数进行计算：区块数除以210000。挖到创世区块产生50个比特币，然后每 210000 个区块奖励减半。在我们的实现当中，我们将奖励设定为常数（只是目前是这个样子的）。</p><h1 id="在区块链中存储交易记录（Storing-Transactions-in-Blockchain）"><a href="#在区块链中存储交易记录（Storing-Transactions-in-Blockchain）" class="headerlink" title="在区块链中存储交易记录（Storing Transactions in Blockchain）"></a>在区块链中存储交易记录（Storing Transactions in Blockchain）</h1><p>从此以后，每一个区块必须存储至少一条交易记录，并且没有交易记录的挖坑也变得不再可能。这意味着我们将从 <code>Block</code> 结构体中移除<code>Data</code> 字段，添加<code>transactions</code> 代替：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">Timestamp     <span class="keyword">int64</span></span><br><span class="line">Transactions  []*Transaction</span><br><span class="line">PrevBlockHash []<span class="keyword">byte</span></span><br><span class="line">Hash          []<span class="keyword">byte</span></span><br><span class="line">Nonce         <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewBlock</code> 和<code>NewGenesisBlock</code>也必须相应地进行修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(transactions []*Transaction, prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">block := &amp;Block&#123;time.Now().Unix(), transactions, prevBlockHash, []<span class="keyword">byte</span>&#123;&#125;, <span class="number">0</span>&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGenesisBlock</span><span class="params">(coinbase *Transaction)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewBlock([]*Transaction&#123;coinbase&#125;, []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步需要改变的是修改区块链的创建方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockchain</span><span class="params">(address <span class="keyword">string</span>)</span> *<span class="title">Blockchain</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">err = db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cbtx := NewCoinbaseTX(address, genesisCoinbaseData)</span><br><span class="line">genesis := NewGenesisBlock(cbtx)</span><br><span class="line"></span><br><span class="line">b, err := tx.CreateBucket([]<span class="keyword">byte</span>(blocksBucket))</span><br><span class="line">err = b.Put(genesis.Hash, genesis.Serialize())</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，这个函数将接收一个会收到创世区块奖励的地址。</p><h1 id="工作证明（Proof-of-Work）"><a href="#工作证明（Proof-of-Work）" class="headerlink" title="工作证明（Proof-of-Work）"></a>工作证明（Proof-of-Work）</h1><p>工作证明算法（PoW）必须考虑区块链中存储的交易记录，为了确保保存交易记录的区块链的一致性和可靠性。因此，现在我们必须修改 <code>ProofOfWork.prepareData</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span> <span class="title">prepareData</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">data := bytes.Join(</span><br><span class="line">[][]<span class="keyword">byte</span>&#123;</span><br><span class="line">pow.block.PrevBlockHash,</span><br><span class="line">pow.block.HashTransactions(), <span class="comment">// This line was changed</span></span><br><span class="line">IntToHex(pow.block.Timestamp),</span><br><span class="line">IntToHex(<span class="keyword">int64</span>(targetBits)),</span><br><span class="line">IntToHex(<span class="keyword">int64</span>(nonce)),</span><br><span class="line">&#125;,</span><br><span class="line">[]<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在用<code>pow.block.HashTransactions()</code>代替<code>pow.block.Data</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">HashTransactions</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> txHashes [][]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> txHash [<span class="number">32</span>]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> b.Transactions &#123;</span><br><span class="line">txHashes = <span class="built_in">append</span>(txHashes, tx.ID)</span><br><span class="line">&#125;</span><br><span class="line">txHash = sha256.Sum256(bytes.Join(txHashes, []<span class="keyword">byte</span>&#123;&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> txHash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再一次，我们用哈希来作为一种提供数据唯一标示的工具。我们要一个区块中的所有交易记录都让一个唯一的哈希值来标示。为了达到这个目的，我们获取了每一条交易记录的哈希，然后将它们串联起来，最后获得串联后数据的哈希值。</p><blockquote><p>比特币用一个更加复杂的技术：它采用<a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="noopener">Merkle tree</a>来组织一个区块中的所有交易记录，然后用树的根哈希值来确保PoW系统的运行。这种方法能够让我们快速的检验一个区块是否包含确定的交易记录，只要有根哈希值而不需要下载所有的交易记录。<br>让我们检验一下到目前为止一切照常进行：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go createblockchain -address Ivan</span><br><span class="line"><span class="number">00000093450837f</span>8b52b78c25f8163bb6137caf43ff4d9a01d1b731fa8ddcc8a</span><br><span class="line"></span><br><span class="line">Done!</span><br></pre></td></tr></table></figure><p>非常好！我们获得了第一个挖矿奖励。但是我们如何检查余额呢？</p><h1 id="未花费交易记录输出（Unspent-Transaction-Outputs）"><a href="#未花费交易记录输出（Unspent-Transaction-Outputs）" class="headerlink" title="未花费交易记录输出（Unspent Transaction Outputs）"></a>未花费交易记录输出（Unspent Transaction Outputs）</h1><p>我们需要找出所有的未花费交易记录输出（UTXO）。未花费相当于这些输出并有与任何输入有关联。在上面的示意图中，以下为未花费交易记录：</p><p>tx0, output 1;<br>tx1, output 0;<br>tx3, output 0;<br>tx4, output 0.</p><p>当然，当我们检查余额时，我们并不需要全部，值需要那些我们有私钥可以解锁的部分。（目前我们还没有实现私钥，将用用户定义的地址来代替）。首先，让我们在输入和输出上定义锁定-解锁方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *TXInput)</span> <span class="title">CanUnlockOutputWith</span><span class="params">(unlockingData <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> in.ScriptSig == unlockingData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(out *TXOutput)</span> <span class="title">CanBeUnlockedWith</span><span class="params">(unlockingData <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> out.ScriptPubKey == unlockingData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们只是将<code>unlockingData</code>与<code>script</code>字段进行了比较。这部分代码会在后续的文章中所有提升，在我们实现基于私钥的地址以后。</p><p>下一步-寻找含有未花费输出的交易记录-实现起来非常的难：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">FindUnspentTransactions</span><span class="params">(address <span class="keyword">string</span>)</span> []<span class="title">Transaction</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> unspentTXs []Transaction</span><br><span class="line">  spentTXOs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>)</span><br><span class="line">  bci := bc.Iterator()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    block := bci.Next()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">      txID := hex.EncodeToString(tx.ID)</span><br><span class="line"></span><br><span class="line">    Outputs:</span><br><span class="line">      <span class="keyword">for</span> outIdx, out := <span class="keyword">range</span> tx.Vout &#123;</span><br><span class="line">        <span class="comment">// Was the output spent?</span></span><br><span class="line">        <span class="keyword">if</span> spentTXOs[txID] != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> _, spentOut := <span class="keyword">range</span> spentTXOs[txID] &#123;</span><br><span class="line">            <span class="keyword">if</span> spentOut == outIdx &#123;</span><br><span class="line">              <span class="keyword">continue</span> Outputs</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> out.CanBeUnlockedWith(address) &#123;</span><br><span class="line">          unspentTXs = <span class="built_in">append</span>(unspentTXs, *tx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> tx.IsCoinbase() == <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, in := <span class="keyword">range</span> tx.Vin &#123;</span><br><span class="line">          <span class="keyword">if</span> in.CanUnlockOutputWith(address) &#123;</span><br><span class="line">            inTxID := hex.EncodeToString(in.Txid)</span><br><span class="line">            spentTXOs[inTxID] = <span class="built_in">append</span>(spentTXOs[inTxID], in.Vout)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> unspentTXs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于交易记录存在在区块当中，我们必须检查区块链中的每一个区块。我们从输出开始：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> out.CanBeUnlockedWith(address) &#123;</span><br><span class="line">unspentTXs = <span class="built_in">append</span>(unspentTXs, tx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个输出由我们用来选择未花费交易记录的地址上的锁，那么这个输出就是我们想要的。</p><p>但是在我们取得它之前我们需要确认它是否已经与一个输入相关联：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> spentTXOs[txID] != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, spentOut := <span class="keyword">range</span> spentTXOs[txID] &#123;</span><br><span class="line"><span class="keyword">if</span> spentOut == outIdx &#123;</span><br><span class="line"><span class="keyword">continue</span> Outputs</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将忽略哪些已经与输入相关的的输出（它们的价值已经转移到其它的输出，所以不能再统计它们）。检查输出以后，我们手机所有那些可以结果被提供的地址锁上的输出的输入（这对币基交易记录不适用，因为它们不解锁任何输出）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tx.IsCoinbase() == <span class="literal">false</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, in := <span class="keyword">range</span> tx.Vin &#123;</span><br><span class="line">        <span class="keyword">if</span> in.CanUnlockOutputWith(address) &#123;</span><br><span class="line">            inTxID := hex.EncodeToString(in.Txid)</span><br><span class="line">            spentTXOs[inTxID] = <span class="built_in">append</span>(spentTXOs[inTxID], in.Vout)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的函数返回一系列包含未花费输出的交易记录。为了计算余额，我们需要额外的一个以交易记录为参数并只返回输出的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">FindUTXO</span><span class="params">(address <span class="keyword">string</span>)</span> []<span class="title">TXOutput</span></span> &#123;</span><br><span class="line">       <span class="keyword">var</span> UTXOs []TXOutput</span><br><span class="line">       unspentTransactions := bc.FindUnspentTransactions(address)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> _, tx := <span class="keyword">range</span> unspentTransactions &#123;</span><br><span class="line">               <span class="keyword">for</span> _, out := <span class="keyword">range</span> tx.Vout &#123;</span><br><span class="line">                       <span class="keyword">if</span> out.CanBeUnlockedWith(address) &#123;</span><br><span class="line">                               UTXOs = <span class="built_in">append</span>(UTXOs, out)</span><br><span class="line">                       &#125;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> UTXOs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，现在我可以实现 <code>getbalance</code>命令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">getBalance</span><span class="params">(address <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">bc := NewBlockchain(address)</span><br><span class="line"><span class="keyword">defer</span> bc.db.Close()</span><br><span class="line"></span><br><span class="line">balance := <span class="number">0</span></span><br><span class="line">UTXOs := bc.FindUTXO(address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, out := <span class="keyword">range</span> UTXOs &#123;</span><br><span class="line">balance += out.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Balance of '%s': %d\n"</span>, address, balance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>账户余额就是账户地址所锁定的所有交易记录输出价值的总和。</p><p>让我们检查在挖了创世区块的矿以后的余额：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go getbalance -address Ivan</span><br><span class="line">Balance of <span class="string">'Ivan'</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>这是我们的第一份钱！</p><h1 id="发送币（Sending-Coins）"><a href="#发送币（Sending-Coins）" class="headerlink" title="发送币（Sending Coins）"></a>发送币（Sending Coins）</h1><p>现在，我们想要给其他人发一些币过去。为此，我们需要创建一个新的交易记录，把它放到区块当中，然后挖坑。到目前为止，我们只实现了币基交易记录（特殊的一种交易记录），现在我们需要一个普通的交易记录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUTXOTransaction</span><span class="params">(from, to <span class="keyword">string</span>, amount <span class="keyword">int</span>, bc *Blockchain)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> inputs []TXInput</span><br><span class="line"><span class="keyword">var</span> outputs []TXOutput</span><br><span class="line"></span><br><span class="line">acc, validOutputs := bc.FindSpendableOutputs(from, amount)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> acc &lt; amount &#123;</span><br><span class="line">log.Panic(<span class="string">"ERROR: Not enough funds"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build a list of inputs</span></span><br><span class="line"><span class="keyword">for</span> txid, outs := <span class="keyword">range</span> validOutputs &#123;</span><br><span class="line">txID, err := hex.DecodeString(txid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, out := <span class="keyword">range</span> outs &#123;</span><br><span class="line">input := TXInput&#123;txID, out, from&#125;</span><br><span class="line">inputs = <span class="built_in">append</span>(inputs, input)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build a list of outputs</span></span><br><span class="line">outputs = <span class="built_in">append</span>(outputs, TXOutput&#123;amount, to&#125;)</span><br><span class="line"><span class="keyword">if</span> acc &gt; amount &#123;</span><br><span class="line">outputs = <span class="built_in">append</span>(outputs, TXOutput&#123;acc - amount, from&#125;) <span class="comment">// a change</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tx := Transaction&#123;<span class="literal">nil</span>, inputs, outputs&#125;</span><br><span class="line">tx.SetID()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建新的输出之前，我们首先找出所有的未消费输出并且确保它们存有足够的币值。这是<code>FindSpendableOutputs</code>方法的功能。在这之后，每一个找到的输出创建一个与之对应的输入。然后，我们创建两个输出：</p><ul><li>一个用接受者的地址进行锁定。这是实际需要转移到其它地址的币值。</li><li>一个用发送者的地址进行锁定。这是找零。当且仅当剩余未花费输出持有的总币值比新的交易记录所要求的多。记住：输出是不可分割的。</li></ul><p><code>FindSpendableOutput</code>方法是基于我们早先定义的 <code>FindUnspentTransactions</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">FindSpendableOutputs</span><span class="params">(address <span class="keyword">string</span>, amount <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">unspentOutputs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>)</span><br><span class="line">unspentTXs := bc.FindUnspentTransactions(address)</span><br><span class="line">accumulated := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Work:</span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> unspentTXs &#123;</span><br><span class="line">txID := hex.EncodeToString(tx.ID)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> outIdx, out := <span class="keyword">range</span> tx.Vout &#123;</span><br><span class="line"><span class="keyword">if</span> out.CanBeUnlockedWith(address) &amp;&amp; accumulated &lt; amount &#123;</span><br><span class="line">accumulated += out.Value</span><br><span class="line">unspentOutputs[txID] = <span class="built_in">append</span>(unspentOutputs[txID], outIdx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> accumulated &gt;= amount &#123;</span><br><span class="line"><span class="keyword">break</span> Work</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> accumulated, unspentOutputs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法遍历所有的未花费交易记录并累计它们的币值。当累计的币值大于或者等于我们所有转移的量时，它停止工作然后返回累计币值（accumulated value）以及按交易记录ID进行分组的输出索引。我们不打算取比我们打算要花费的多。</p><p>现在我们可以修改 <code>Blockchain.MineBlock</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">MineBlock</span><span class="params">(transactions []*Transaction)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">newBlock := NewBlock(transactions, lastHash)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，让我们实现 <code>send</code>命令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">send</span><span class="params">(from, to <span class="keyword">string</span>, amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">bc := NewBlockchain(from)</span><br><span class="line"><span class="keyword">defer</span> bc.db.Close()</span><br><span class="line"></span><br><span class="line">tx := NewUTXOTransaction(from, to, amount, bc)</span><br><span class="line">bc.MineBlock([]*Transaction&#123;tx&#125;)</span><br><span class="line">fmt.Println(<span class="string">"Success!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送币意味着创建一个交易记录然后以对一个区块以挖矿的形式将它加入到区块链当中。但是比特币并不立即执行，正如我们所实现的。反而将所有新交易记录放到内存池，当一个矿工准备去挖矿时，它将从内存池中拿走所有的交易记录并创建一个候选区块。当且仅当包含它们的区块被挖出被加入到区块链时所有的交易记录才会被确认。</p><p>让我们确认下发送币的功能是否工作正常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go send -from Ivan -to Pedro -amount <span class="number">6</span></span><br><span class="line"><span class="number">00000001</span>b56d60f86f72ab2a59fadb197d767b97d4873732be505e0a65cc1e37</span><br><span class="line"></span><br><span class="line">Success!</span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address Ivan</span><br><span class="line">Balance of <span class="string">'Ivan'</span>: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address Pedro</span><br><span class="line">Balance of <span class="string">'Pedro'</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure><p>非常好！现在，让我们创建更多的交易记录然后确保从不同的输出发出币也通用工作正常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go send -from Pedro -to Helen -amount <span class="number">2</span></span><br><span class="line"><span class="number">00000099938725</span>eb2c7730844b3cd40209d46bce2c2af9d87c2b7611fe9d5bdf</span><br><span class="line"></span><br><span class="line">Success!</span><br><span class="line"></span><br><span class="line">$ blockchain_go send -from Ivan -to Helen -amount <span class="number">2</span></span><br><span class="line"><span class="number">000000</span>a2edf94334b1d94f98d22d7e4c973261660397dc7340464f7959a7a9aa</span><br><span class="line"></span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><p>现在 Helen的币被锁定在两个输出当中：一个来自Pedro，另外一个来之Ivan。让我们将它们转移到其它人：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go send -from Helen -to Rachel -amount <span class="number">3</span></span><br><span class="line"><span class="number">000000</span>c58136cffa669e767b8f881d16e2ede3974d71df43058baaf8c069f1a0</span><br><span class="line"></span><br><span class="line">Success!</span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address Ivan</span><br><span class="line">Balance of <span class="string">'Ivan'</span>: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address Pedro</span><br><span class="line">Balance of <span class="string">'Pedro'</span>: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address Helen</span><br><span class="line">Balance of <span class="string">'Helen'</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address Rachel</span><br><span class="line">Balance of <span class="string">'Rachel'</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>看起来非常棒！让我们测试一个失败案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go send -from Pedro -to Ivan -amount <span class="number">5</span></span><br><span class="line"><span class="built_in">panic</span>: ERROR: Not enough funds</span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address Pedro</span><br><span class="line">Balance of <span class="string">'Pedro'</span>: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go getbalance -address Ivan</span><br><span class="line">Balance of <span class="string">'Ivan'</span>: <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="结论（Conclusion）"><a href="#结论（Conclusion）" class="headerlink" title="结论（Conclusion）"></a>结论（Conclusion）</h1><p>哎呀！这并不容易，但现在我们还是有了交易记录！虽然，一些类比特币的加密币的特性还暂时缺失：</p><ul><li>地址。我们并没有实际、私有的地址</li><li>奖励。挖矿时绝对无利可图的</li><li>UTXO集合。获取余额需要扫描整个区块链，当有很多区块时，这会非常耗时。并且，验证后面的交易记录也非常耗时。UTXO集试图解决这些问题并让通过交易记录的运营更加快</li><li>内存池。这是交易记录在被推入区块之前存储交易记录的地方。在我们当前的实现当中，一个区块仅包含一个交易记录，然则这非常的低效。</li></ul><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul><li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_4" target="_blank" rel="noopener">Full source codes</a></li><li><a href="https://en.bitcoin.it/wiki/Transaction" target="_blank" rel="noopener">Transaction</a></li><li><a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="noopener">Merkle tree</a></li><li><a href="https://en.bitcoin.it/wiki/Coinbase" target="_blank" rel="noopener">Coinbase</a></li></ul>]]></content>
    
    <summary type="html">
    
      由于众所周知的原因，最近区块链又一次被推到了风口，下面转发几篇两年前翻译的首发于知乎关于如何用Go语言打造区块链的文章。Go语言是由google开发并于2009年发布的一种静态、强类型、编译型、并发型，并具有垃圾回收（GC）功能的编程语言，特别适用于分布式网络系统开发，而区块链（blockchain）本质上是一本在网络上分布存储的账本，这两者具有天然的匹配性，目前火热的[Ethereum Project](https://ethereum.org/)就是用go原生实现的。这一系列的文章是由[Ivan Kuznetsov](https://jeiwan.net/)所写，本人觉得是一个结合Go语言学习区块链技术的好资料，后面将用自己的语言翻译一遍，从第一篇开始，顺便对Go语言以及区块链有一个初步的认识。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="分布式" scheme="http://datacruiser.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据库" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="go" scheme="http://datacruiser.io/tags/go/"/>
    
      <category term="hash" scheme="http://datacruiser.io/tags/hash/"/>
    
      <category term="工作证明" scheme="http://datacruiser.io/tags/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/"/>
    
      <category term="交易" scheme="http://datacruiser.io/tags/%E4%BA%A4%E6%98%93/"/>
    
      <category term="命令行" scheme="http://datacruiser.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何用Go打造区块链（3）—数据存储及命令行（CLI）</title>
    <link href="http://datacruiser.io/2019/10/29/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%883%EF%BC%89%E2%80%94%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88CLI%EF%BC%89/"/>
    <id>http://datacruiser.io/2019/10/29/如何用Go打造区块链（3）—数据存储及命令行（CLI）/</id>
    <published>2019-10-29T20:06:12.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>到目前为止，我们已经构建了一个带PoW机制的区块链系统，这也使得挖矿变得可能。我们的实现离完整功能的区块链又近了一步，但是依然缺少一些重要的特性。今天开始我们将区块链存储到一个数据库当中，在这之后我们会做一个命令行接口（CLI）来实现与区块链的互动。虽然区块链的核心是分布式数据库，但是目前我们将暂时忽略“分布式”而专注于数据库本身。</p><h1 id="数据库选择"><a href="#数据库选择" class="headerlink" title="数据库选择"></a>数据库选择</h1><p>目前，我们的实现当中并没有数据库；而是在每次运行程序的时候将区块链存储在内存当中，程序结束后所有的数据便消失了。我们无法重复使用一个区块链，也无法与其他人分享。因此后续我们需要将它存储在硬盘当中。</p><p>我们需要哪个数据库呢？事实上，任何一个都可以。在<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">比特币白皮书</a>当中，并没有特别提到需要使用哪一个数据库，这将取决于每个开发者本身。中本聪首发的<a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="noopener">比特币内核</a>且也是当前比特币的一个参考实现，采用<a href="https://github.com/google/leveldb" target="_blank" rel="noopener">google/leveldb</a>。这里我们将采用<a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">BoltDB</a>…</p><h1 id="BoltDB"><a href="#BoltDB" class="headerlink" title="BoltDB"></a>BoltDB</h1><p>因为：</p><ul><li>简单、简洁</li><li>用Go实现</li><li>不需要运行一个服务</li><li>允许用户构建自己需要的数据结构</li></ul><p>以下是来自Github上BoltDB Readme文件的介绍：</p><p>&gt;<br>Blot 是一个纯Go的键/值（key/value）存储系统，来自于Howard Chu的LMDB项目。该项目的目的是为那些并不需要像Postgres或者MySQL这样的全功能服务数据库的项目提供一款简单、快速且可靠的数据库。<br>正因为 Bolt 注定要用在这样一个队功能要求层次较低的项目上，简单是最关键的。API也很小，也仅仅关注于取值和赋值。就这样小而美。<br>听起来能够完美地满足我们的需求，让我们花几分钟再看一下。</p><p>Bolt 是一个key/value数据库，这意味着没有像其它SQL系的关系型数据库管理系统（RDMBS，比如MySQL，PostgreSQL等）的表（table）、行（row）、列（column）等元素。数据以键/值（key/value）的方式进行存储（类似Go语言中的maps数据结构）。key/value对存储在类似于关系型数据库中的表（table）的 buckets 当中，bucket会将相似的数据对进行分组。因此，要想获得value，你需要知道对应的bucket和key。</p><p><a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">BoltDB</a> 的重要特点是无数据类型：key/value是byte类型的数组（array）。而我们要存储Go语言的结构体数据（特别是Block结构体），因此我们需要将结构体序列化（serialize）。实现一个首先将Go语言的结构体转化成byte数组，然后将byte数组恢复成结构体的机制。我们将采用encoding/gob来完成这一工作，当然，<strong>JSON, XML, Protocol Buffers</strong> 等工具也是可以的，我们之所以采用gob包是因为它足够简单并且是Go语言标准库的一部分。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>在实现数据持续存储之前，首先需要确定如何在数据库存储数据。就此，我们将参考<a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="noopener">比特币内核</a>的实现方式。</p><p>简单地讲，<a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="noopener">比特币内核</a>用了两个“Buckets”来存储数据：</p><ul><li><code>blocks</code>：存储区块链中描述区块的元数据</li><li><code>chainstate</code>：存储链的状态，包括所有未成交的交易输出（Outputs）记录和一些元数据</li></ul><p>并且，每一个<code>blocks</code>在硬盘中以单独的文件来保存，这样做是为了提高性能：读取一个单独的区块并不需要载入所有（或者部分）区块到内存。不过我们并不这样实现。</p><p>在<code>blocks</code> 当中，<code>Key -&gt; Value</code> 数据对如下：</p><ul><li>‘b’ + 32-byte block hash -&gt; block index record</li><li>‘f’ + 4-byte file number -&gt; file information record</li><li>‘l’ -&gt; 4-byte file number: the last block file number used</li><li>‘R’ -&gt; 1-byte boolean: whether we’re in the process of reindexing</li><li>‘F’ + 1-byte flag name length + flag name string -&gt; 1 byte boolean: various flags that can be on or off</li><li>‘t’ + 32-byte transaction hash -&gt; transaction index record</li></ul><p>在<code>chainstate</code> 当中，<code>Key -&gt; Value</code>数据对如下：</p><ul><li>‘c’ + 32-byte transaction hash -&gt; unspent transaction output record for that transaction</li><li>‘B’ -&gt; 32-byte block hash: the block hash up to which the database represents the unspent transaction outputs</li></ul><p>（关于以上数据的详细解释可以访问这个链接<a href="https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2" target="_blank" rel="noopener">Bitcoin Core 0.11 (ch 2): Data Storage</a>:_Data_Storage)）</p><p>因为目前我们还没有交易记录，我们的数据库当中仅有 blocks 这个bucket。并且，正如前面所提到的，我们将全部的数据库存储在一个文件当中，并不将单个区块存储在单个文件当中。因此，我们也没有什么信息是与文件数（file number）有个的，所能够利用的 key -&gt; value 数据对如下：</p><ul><li>‘b’ + 32-byte block-hash -&gt; Block structure (serialized)区块结构体（序列化后的）</li><li>‘l’ -&gt; the hash of the last block in a chain（区块链中最近一个区块的哈希值）</li></ul><p>以上是目前开始实现数据存储机制所需要了解的全部内容。</p><h1 id="序列化（Serialization）"><a href="#序列化（Serialization）" class="headerlink" title="序列化（Serialization）"></a>序列化（Serialization）</h1><p>正如前面所言，<code>BoltDB</code>数据的值只能是<code>Byte</code> 类型的数组，并且我们想要将<code>Block</code> 结构体的数据存储到数据库当中。我们将采用 <a href="https://golang.org/pkg/encoding/gob/" target="_blank" rel="noopener">encoding/gob</a> 来对结构体进行序列化。</p><p>让我们来实现将 <code>Block</code> 序列化的方法（为了简化，将异常处理部分的代码略去）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Serialize</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result bytes.Buffer</span><br><span class="line">encoder := gob.NewEncoder(&amp;result)</span><br><span class="line"></span><br><span class="line">err := encoder.Encode(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个只是针对 <code>Block</code>结构体的，所以这里只是一个方法，而不是一个函数（only a method belongs to Block structure particularly, not a general function）。</p><p>这一段简单明了：一开始，我们申明了一个<a href="https://golang.org/pkg/bytes/#Buffer" target="_blank" rel="noopener">bytes.Buffer</a>(bytes 包中用于接收字节读入的缓存）的变量<code>result</code>，用来存储序列化后的数据；然后初始化了一个<code>gob</code>包的 <code>NewEncoder</code> 然后对区块进行编码（Encode）；最后 变量 <code>result</code> 以<code>Bytes</code> 的类型返回。</p><p>接下来，我们需要一个反序列化函数，在我们将一个<code>Byte</code> 数组传递给它以后返回对应的一个<code>Block</code> 结构体。这不是专属于特定一个结构体或者数据类型的方法，而是一个独立的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeserializeBlock</span><span class="params">(d []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> block Block</span><br><span class="line"></span><br><span class="line">decoder := gob.NewDecoder(bytes.NewReader(d))</span><br><span class="line">err := decoder.Decode(&amp;block)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是序列化部分的解释和代码。</p><h1 id="数据存储（Persistence）"><a href="#数据存储（Persistence）" class="headerlink" title="数据存储（Persistence）"></a>数据存储（Persistence）</h1><p>让我们从 NewBlockchain 函数开始。目前，它创建了一个 Blockchain 结构体的实例（instance）并将创始区块（genesis block）加入链中。以下是我们接下来要做的：</p><ul><li><p>打开一个数据库（DB）文件</p></li><li><p>检查数据库文件是否已有其他区块链文件存储，是或者否分两种情况不同论述</p></li><li><p>如果已经有了一个区块链：</p><ul><li><p>创建一个新的 Blockchain 实例</p></li><li><p>将新建 Blockchain 实例的顶端设置为原数据库当中的区块链最后一个区块的哈希值</p></li></ul></li><li><p>假如还有没有区块链：</p><ul><li><p>创建创始区块</p></li><li><p>将新建的创始区块存储到数据当中</p></li><li><p>将创始区块的哈希保存为最后区块的哈希</p></li><li><p>创建一个新的 Blockchain 的实例，然后将其顶端指向创始区块</p></li></ul></li></ul><p>可以用以下代码来表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockchain</span><span class="params">()</span> *<span class="title">Blockchain</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> tip []<span class="keyword">byte</span></span><br><span class="line">db, err := bolt.Open(dbFile, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">err = db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="keyword">byte</span>(blocksBucket))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">genesis := NewGenesisBlock()</span><br><span class="line">b, err := tx.CreateBucket([]<span class="keyword">byte</span>(blocksBucket))</span><br><span class="line">err = b.Put(genesis.Hash, genesis.Serialize())</span><br><span class="line">err = b.Put([]<span class="keyword">byte</span>(<span class="string">"l"</span>), genesis.Hash)</span><br><span class="line">tip = genesis.Hash</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tip = b.Get([]<span class="keyword">byte</span>(<span class="string">"l"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">bc := Blockchain&#123;tip, db&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;bc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们一条一条地过这段代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err := bolt.Open(dbFile, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这是打开<code>BoltDB</code> 数据文件的标准方式。需要注意的是如果文件不存在，它也不会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err = db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在<code>BoltDB</code>当中，对数据库的操作是通过一个个记录（transactions）来实现的。在此有两种记录模式，只读模式和读写模式。这里我们通过<code>db.Updata(...)</code> 以读写的模式打开，因为我们会将创始区块加入到数据库文件当中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b := tx.Bucket([]<span class="keyword">byte</span>(blocksBucket))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">genesis := NewGenesisBlock()</span><br><span class="line">b, err := tx.CreateBucket([]<span class="keyword">byte</span>(blocksBucket))</span><br><span class="line">err = b.Put(genesis.Hash, genesis.Serialize())</span><br><span class="line">err = b.Put([]<span class="keyword">byte</span>(<span class="string">"l"</span>), genesis.Hash)</span><br><span class="line">tip = genesis.Hash</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tip = b.Get([]<span class="keyword">byte</span>(<span class="string">"l"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是整个函数的核心，这里我们获取了用于存储区块的 <code>bucket</code>：假如它已经存在，我们读取它的 “l”值；如果还不存在，我们创建创始区块，创建 <code>bucket</code>，将创始区块保存到新建的 <code>bucket</code>当中，然后将“l”值更新为区块链当中最近区块的哈希值。</p><p>特别注意到创建 <code>Blockchain</code> 的新方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc := Blockchain&#123;tip, db&#125;</span><br></pre></td></tr></table></figure><p>我们并不将所有的区块存储进去，而仅仅是存储区块链的顶端。同时，也保存一个数据库文件的链接（DB），因为我们希望打开一次以后只要程序在运行就一直保持打开。这样，现在 Blockchain 结构体看起来像这个样子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Blockchain <span class="keyword">struct</span> &#123;</span><br><span class="line">tip []<span class="keyword">byte</span></span><br><span class="line">db  *bolt.DB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一件事情我们需要更新修改的是 <code>AddBlock</code> 方法：往一个区块链当中增加一个区块已经不像是像数组添加一个新的元素那么简单了。从现在开始我将区块保存在数据库文件（DB）当中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">AddBlock</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> lastHash []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">err := bc.db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="keyword">byte</span>(blocksBucket))</span><br><span class="line">lastHash = b.Get([]<span class="keyword">byte</span>(<span class="string">"l"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">newBlock := NewBlock(data, lastHash)</span><br><span class="line"></span><br><span class="line">err = bc.db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="keyword">byte</span>(blocksBucket))</span><br><span class="line">err := b.Put(newBlock.Hash, newBlock.Serialize())</span><br><span class="line">err = b.Put([]<span class="keyword">byte</span>(<span class="string">"l"</span>), newBlock.Hash)</span><br><span class="line">bc.tip = newBlock.Hash</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们一段一段过代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err := bc.db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="keyword">byte</span>(blocksBucket))</span><br><span class="line">lastHash = b.Get([]<span class="keyword">byte</span>(<span class="string">"l"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是<code>BoltDB</code> 另外一种只读的记录（操作数据库文件）的模式。这里我们从数据库文件获得了最近区块的哈希然后用它来挖一个新的区块哈希。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newBlock := NewBlock(data, lastHash)</span><br><span class="line">b := tx.Bucket([]<span class="keyword">byte</span>(blocksBucket))</span><br><span class="line">err := b.Put(newBlock.Hash, newBlock.Serialize())</span><br><span class="line">err = b.Put([]<span class="keyword">byte</span>(<span class="string">"l"</span>), newBlock.Hash)</span><br><span class="line">bc.tip = newBlock.Hash</span><br></pre></td></tr></table></figure><p>挖到一个新的区块以后，我们将其序列化后的数据保存到数据库当中然后更新其中的“l”值，这时“l”保存新区块的哈希值。</p><p>完成了！看起来不是太难吧？</p><h1 id="查看区块链（Inspecting-Blockchain）"><a href="#查看区块链（Inspecting-Blockchain）" class="headerlink" title="查看区块链（Inspecting Blockchain）"></a>查看区块链（Inspecting Blockchain）</h1><p>所有新的区块现在都保存在数据当中，于是我们可以重复打开一个区块链然后往里面添加新的区块。但是，实现了存储以后，我们失去了一个新的特性：因为我们已经不再将区块存储在数组当中，于是便不能将区块链打印出来了。让我们来消除这个缺陷吧。</p><p><code>BoltDB</code> 允许对<code>bucket</code> 中的<code>key</code> 进行遍历，但是keys是以字节顺序进行保存的，而我们想将区块按区块链中的顺序进行打印。并且，我们也不想将所有的区块载入到内存当中（我们的区块链文件会非常大！。。。或者让我假装它会很大），我们将逐个读取它们。为了这个目的，我们需要一个区块链遍历器（iterator）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BlockchainIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">currentHash []<span class="keyword">byte</span></span><br><span class="line">db          *bolt.DB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们需要遍历区块链中的区块的时候就创建一个遍历器，并且<code>BlockchainIterator</code> 结构体将存储当前遍历为止的区块哈希值和数据库文件的连接。因为后面这个因素，一个遍历器逻辑上将依附于一个区块链（它是一个存储数据库连接的区块链实例），因此，它将在一个属于<code>Blockchain</code>结构体的方法中创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">Iterator</span><span class="params">()</span> *<span class="title">BlockchainIterator</span></span> &#123;</span><br><span class="line">bci := &amp;BlockchainIterator&#123;bc.tip, bc.db&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bci</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到遍历器初始化的时候指向了区块链的顶端，这样可以从顶部到底部从最新到最老的顺序获取区块。实际上，选择顶部是在为一个区块链“投票”。一个区块链可以有很多个分支，最长的那个分支被认识是主分支。取得一个顶部以后（可以是区块链当中的任意一个区块）我们可以重构整个区块链然后确定它的长度以及构建它所需要的工作量。这也意味着顶端数据是一个区块链的识别器。</p><p><code>BlockchainIterator</code> 只做一件事情：从区块链当中返回下一个区块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *BlockchainIterator)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> block *Block</span><br><span class="line"></span><br><span class="line">err := i.db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">b := tx.Bucket([]<span class="keyword">byte</span>(blocksBucket))</span><br><span class="line">encodedBlock := b.Get(i.currentHash)</span><br><span class="line">block = DeserializeBlock(encodedBlock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">i.currentHash = block.PrevBlockHash</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库部分就这样完成了！</p><h1 id="命令行接口（CLI）"><a href="#命令行接口（CLI）" class="headerlink" title="命令行接口（CLI）"></a>命令行接口（CLI）</h1><p>到目前为止我们还没有实现提供一个接口能够与程序互动：我们只是简单的执行 NewBlockchain bc.AddBlock在 main 函数当中。是时候来有所提高了，我们要有这些命令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blockchain_go addblock <span class="string">"Pay 0.031337 for a coffee"</span></span><br><span class="line">blockchain_go printchain</span><br></pre></td></tr></table></figure><p>所有的命令行相关的操作由CLI 结构体参与执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CLI <span class="keyword">struct</span> &#123;</span><br><span class="line">bc *Blockchain</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的“切入点”在 <code>Run</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">cli.validateArgs()</span><br><span class="line"></span><br><span class="line">addBlockCmd := flag.NewFlagSet(<span class="string">"addblock"</span>, flag.ExitOnError)</span><br><span class="line">printChainCmd := flag.NewFlagSet(<span class="string">"printchain"</span>, flag.ExitOnError)</span><br><span class="line"></span><br><span class="line">addBlockData := addBlockCmd.String(<span class="string">"data"</span>, <span class="string">""</span>, <span class="string">"Block data"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> os.Args[<span class="number">1</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"addblock"</span>:</span><br><span class="line">err := addBlockCmd.Parse(os.Args[<span class="number">2</span>:])</span><br><span class="line"><span class="keyword">case</span> <span class="string">"printchain"</span>:</span><br><span class="line">err := printChainCmd.Parse(os.Args[<span class="number">2</span>:])</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cli.printUsage()</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> addBlockCmd.Parsed() &#123;</span><br><span class="line"><span class="keyword">if</span> *addBlockData == <span class="string">""</span> &#123;</span><br><span class="line">addBlockCmd.Usage()</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">cli.addBlock(*addBlockData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> printChainCmd.Parsed() &#123;</span><br><span class="line">cli.printChain()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用Go语言的标准库当中的 <a href="https://golang.org/pkg/flag/" target="_blank" rel="noopener">flag</a>包来做命令行的词法分析。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addBlockCmd := flag.NewFlagSet(<span class="string">"addblock"</span>, flag.ExitOnError)</span><br><span class="line">printChainCmd := flag.NewFlagSet(<span class="string">"printchain"</span>, flag.ExitOnError)</span><br><span class="line">addBlockData := addBlockCmd.String(<span class="string">"data"</span>, <span class="string">""</span>, <span class="string">"Block data"</span>)</span><br></pre></td></tr></table></figure><p>首先，我们创建两个子命令，<code>addblock</code> 和 <code>printchain</code>，然后在前面一个命令当中加入 <code>-data</code> 参数。<code>printchain</code> 命令不带任何参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> os.Args[<span class="number">1</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"addblock"</span>:</span><br><span class="line">err := addBlockCmd.Parse(os.Args[<span class="number">2</span>:])</span><br><span class="line"><span class="keyword">case</span> <span class="string">"printchain"</span>:</span><br><span class="line">err := printChainCmd.Parse(os.Args[<span class="number">2</span>:])</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cli.printUsage()</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们检查用户和词法分析提供的 <code>flag</code> 子命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> addBlockCmd.Parsed() &#123;</span><br><span class="line"><span class="keyword">if</span> *addBlockData == <span class="string">""</span> &#123;</span><br><span class="line">addBlockCmd.Usage()</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">cli.addBlock(*addBlockData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> printChainCmd.Parsed() &#123;</span><br><span class="line">cli.printChain()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我再检查哪一个子命令将被分析然后运行相关函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">addBlock</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">cli.bc.AddBlock(data)</span><br><span class="line">fmt.Println(<span class="string">"Success!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">printChain</span><span class="params">()</span></span> &#123;</span><br><span class="line">bci := cli.bc.Iterator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">block := bci.Next()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Prev. hash: %x\n"</span>, block.PrevBlockHash)</span><br><span class="line">fmt.Printf(<span class="string">"Data: %s\n"</span>, block.Data)</span><br><span class="line">fmt.Printf(<span class="string">"Hash: %x\n"</span>, block.Hash)</span><br><span class="line">pow := NewProofOfWork(block)</span><br><span class="line">fmt.Printf(<span class="string">"PoW: %s\n"</span>, strconv.FormatBool(pow.Validate()))</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段刚之前那一段非常类似。唯一的不同使我们现在用 BlockchainIterator 去遍历区块链中的区块。</p><p>并且，也不要忘记相应的修改<code>main</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bc := NewBlockchain()</span><br><span class="line"><span class="keyword">defer</span> bc.db.Close()</span><br><span class="line"></span><br><span class="line">cli := CLI&#123;bc&#125;</span><br><span class="line">cli.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意无论输入什么样的命令行参数都将会新建 Blockchain 实例。</p><p>好了，就这样，让我们来检查一下一切是否与所期望的相同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ blockchain_go printchain</span><br><span class="line">No existing blockchain found. Creating a <span class="built_in">new</span> one...</span><br><span class="line">Mining the block containing <span class="string">"Genesis Block"</span></span><br><span class="line"><span class="number">000000</span>edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b</span><br><span class="line"></span><br><span class="line">Prev. hash:</span><br><span class="line">Data: Genesis Block</span><br><span class="line">Hash: <span class="number">000000</span>edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b</span><br><span class="line">PoW: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">$ blockchain_go addblock -data <span class="string">"Send 1 BTC to Ivan"</span></span><br><span class="line">Mining the block containing <span class="string">"Send 1 BTC to Ivan"</span></span><br><span class="line"><span class="number">000000d</span>7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13</span><br><span class="line"></span><br><span class="line">Success!</span><br><span class="line"></span><br><span class="line">$ blockchain_go addblock -data <span class="string">"Pay 0.31337 BTC for a coffee"</span></span><br><span class="line">Mining the block containing <span class="string">"Pay 0.31337 BTC for a coffee"</span></span><br><span class="line"><span class="number">000000</span>aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148</span><br><span class="line"></span><br><span class="line">Success!</span><br><span class="line"></span><br><span class="line">$ blockchain_go printchain</span><br><span class="line">Prev. hash: <span class="number">000000d</span>7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13</span><br><span class="line">Data: Pay <span class="number">0.31337</span> BTC <span class="keyword">for</span> a coffee</span><br><span class="line">Hash: <span class="number">000000</span>aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148</span><br><span class="line">PoW: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Prev. hash: <span class="number">000000</span>edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b</span><br><span class="line">Data: Send <span class="number">1</span> BTC to Ivan</span><br><span class="line">Hash: <span class="number">000000d</span>7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13</span><br><span class="line">PoW: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Prev. hash:</span><br><span class="line">Data: Genesis Block</span><br><span class="line">Hash: <span class="number">000000</span>edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b</span><br><span class="line">PoW: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>(简直应该开一瓶啤酒庆祝一下)</p><h1 id="结论（Conclusion）"><a href="#结论（Conclusion）" class="headerlink" title="结论（Conclusion）"></a>结论（Conclusion）</h1><p>下次我们将实现地址、钱包以及交易记录（很有可能）。保持好节奏！</p><h1 id="链接（Links）"><a href="#链接（Links）" class="headerlink" title="链接（Links）"></a>链接（Links）</h1><ul><li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_3" target="_blank" rel="noopener">Full source codes</a></li><li><a href="https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2" target="_blank" rel="noopener">Bitcoin Core Data Storage</a>:_Data_Storage)</li><li><a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">boltdb</a></li><li><a href="https://golang.org/pkg/encoding/gob/" target="_blank" rel="noopener">encoding/gob</a></li><li><a href="https://golang.org/pkg/flag/" target="_blank" rel="noopener">flag</a></li></ul>]]></content>
    
    <summary type="html">
    
      由于众所周知的原因，最近区块链又一次被推到了风口，下面转发几篇两年前翻译的首发于知乎关于如何用Go语言打造区块链的文章。Go语言是由google开发并于2009年发布的一种静态、强类型、编译型、并发型，并具有垃圾回收（GC）功能的编程语言，特别适用于分布式网络系统开发，而区块链（blockchain）本质上是一本在网络上分布存储的账本，这两者具有天然的匹配性，目前火热的[Ethereum Project](https://ethereum.org/)就是用go原生实现的。这一系列的文章是由[Ivan Kuznetsov](https://jeiwan.net/)所写，本人觉得是一个结合Go语言学习区块链技术的好资料，后面将用自己的语言翻译一遍，从第一篇开始，顺便对Go语言以及区块链有一个初步的认识。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="分布式" scheme="http://datacruiser.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据库" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="go" scheme="http://datacruiser.io/tags/go/"/>
    
      <category term="hash" scheme="http://datacruiser.io/tags/hash/"/>
    
      <category term="工作证明" scheme="http://datacruiser.io/tags/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/"/>
    
      <category term="交易" scheme="http://datacruiser.io/tags/%E4%BA%A4%E6%98%93/"/>
    
      <category term="命令行" scheme="http://datacruiser.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-399.除法求值</title>
    <link href="http://datacruiser.io/2019/10/29/Leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <id>http://datacruiser.io/2019/10/29/Leetcode-399-除法求值/</id>
    <published>2019-10-29T10:41:03.000Z</published>
    <updated>2020-01-31T14:37:28.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给出方程式 <code>A / B = k</code>, 其中<code>A</code>和 <code>B</code> 均为代表字符串的变量， <code>k</code> 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。</p><p><strong>示例 :</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 a / b = <span class="number">2.0</span>, b / c = <span class="number">3.0</span></span><br><span class="line">问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? </span><br><span class="line">返回 [<span class="number">6.0</span>, <span class="number">0.5</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span> ]</span><br></pre></td></tr></table></figure><p>输入为: <code>vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries</code>(方程式，方程式结果，问题方程式)， 其中<code>equations.size() == values.size()</code>，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回<code>vector&lt;double&gt;</code>类型。</p><p>基于上述例子，输入如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equations(方程式) = [ [<span class="string">"a"</span>, <span class="string">"b"</span>], [<span class="string">"b"</span>, <span class="string">"c"</span>] ],</span><br><span class="line">values(方程式结果) = [<span class="number">2.0</span>, <span class="number">3.0</span>],</span><br><span class="line">queries(问题方程式) = [ [<span class="string">"a"</span>, <span class="string">"c"</span>], [<span class="string">"b"</span>, <span class="string">"a"</span>], [<span class="string">"a"</span>, <span class="string">"e"</span>], [<span class="string">"a"</span>, <span class="string">"a"</span>], [<span class="string">"x"</span>, <span class="string">"x"</span>] ].</span><br></pre></td></tr></table></figure><p>输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/evaluate-division" target="_blank" rel="noopener">399. Evaluate Division</a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题主要考察并查集和图这两种数据结构, 目前对这两种结构以及常用的算法掌握欠佳, 解题思路先空着, 等复习完这些基本算法, 理解了相关代码再进行补充.</p><p>下面暂时先放一些相关的示意图和各种语言的代码, 其中Java使用的是并查集, C++使用的是图. </p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/LeetCode_Tencent50/%E5%B9%B6%E6%9F%A5%E9%9B%86.png" alt="并查集"></p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/LeetCode_Tencent50/%E5%9B%BE.png" alt="图"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="解法一-Java语言"><a href="#解法一-Java语言" class="headerlink" title="解法一: Java语言"></a>解法一: Java语言</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//child parent</span></span><br><span class="line">    Map&lt;String,String&gt; parents=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//child mutiply of parent</span></span><br><span class="line">    Map&lt;String,Double&gt; values=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!parents.containsKey(x))&#123;</span><br><span class="line">            parents.put(x,x);</span><br><span class="line">            values.put(x,<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(String parent,String child, <span class="keyword">double</span> value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        add(parent);</span><br><span class="line">        add(child);</span><br><span class="line">        String p1=find(parent);</span><br><span class="line">        String p2=find(child);</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parents.put(p2,p1);</span><br><span class="line">            values.put(p2,value*(values.get(parent)/values.get(child)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(String x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parents.get(x)!=x)&#123;</span><br><span class="line">            x=parents.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">(String x)</span></span>&#123;</span><br><span class="line">       <span class="comment">// System.out.println("cal x"+x);</span></span><br><span class="line">        <span class="keyword">double</span> v=values.get(x);</span><br><span class="line">        <span class="keyword">while</span>(parents.get(x)!=x)&#123;</span><br><span class="line">            x=parents.get(x);</span><br><span class="line">            v*=values.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//union </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.size();i++)&#123;</span><br><span class="line">            <span class="comment">//union parent child value</span></span><br><span class="line">            union(equations.get(i).get(<span class="number">0</span>),equations.get(i).get(<span class="number">1</span>),values[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find </span></span><br><span class="line">        <span class="keyword">double</span>[] ans=<span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.size();i++)&#123;</span><br><span class="line">            String c1=queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String c2=queries.get(i).get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!parents.containsKey(c1)||!parents.containsKey(c2))&#123;</span><br><span class="line">                ans[i]=-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c1.equals(c2))&#123;</span><br><span class="line">                ans[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String p1=find(c1);</span><br><span class="line">            String p2=find(c2);</span><br><span class="line">            <span class="keyword">if</span>(!p1.equals(p2))&#123;</span><br><span class="line">                ans[i]=-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i]=cal(c2)/cal(c1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二-C-语言"><a href="#解法二-C-语言" class="headerlink" title="解法二: C++语言"></a>解法二: C++语言</h2><h2 id="解法三-C语言"><a href="#解法三-C语言" class="headerlink" title="解法三: C语言"></a>解法三: C语言</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> n, <span class="keyword">double</span> ** dpf, <span class="keyword">int</span> ** dpfok, <span class="keyword">int</span> ** vis)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dpfok[s][e] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  dpf[s][e];</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">-1.0</span>;</span><br><span class="line">        </span><br><span class="line">vis[s][e] = <span class="number">1</span>;</span><br><span class="line">        vis[e][s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (i != s &amp;&amp; i != e &amp;&amp; vis[e][i] == <span class="number">0</span> &amp;&amp; dpfok[s][i]) &#123;</span><br><span class="line"><span class="keyword">double</span> res = DFS(i,  e,  n,dpf,dpfok,vis);</span><br><span class="line"><span class="keyword">if</span>(res == <span class="number">-1.0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    ans = dpf[s][i] * res;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[s][e] = <span class="number">0</span>;</span><br><span class="line">        vis[e][s] = <span class="number">0</span>;         </span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span>* <span class="title">calcEquation</span><span class="params">(<span class="keyword">char</span> *** equations, <span class="keyword">int</span> equationsSize, <span class="keyword">int</span>* equationsColSize, <span class="keyword">double</span>* values, <span class="keyword">int</span> valuesSize, <span class="keyword">char</span> *** queries, <span class="keyword">int</span> queriesSize, <span class="keyword">int</span>* queriesColSize, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> str[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">char</span> *pstr[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> **dpf = <span class="built_in">malloc</span>(equationsSize * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span> *));        </span><br><span class="line">    <span class="keyword">int</span> ** dpfok= <span class="built_in">malloc</span>(equationsSize * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line">    <span class="keyword">int</span> ** vis= <span class="built_in">malloc</span>(equationsSize * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equationsSize * <span class="number">2</span>;i++) &#123;</span><br><span class="line">        dpf[i] = <span class="built_in">malloc</span>(equationsSize * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>)); </span><br><span class="line">        dpfok[i] = <span class="built_in">malloc</span>(equationsSize * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line">        vis[i] = <span class="built_in">malloc</span>(equationsSize * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memset</span>(dpf[i],<span class="number">0</span>,equationsSize * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">        <span class="built_in">memset</span>(dpfok[i],<span class="number">0</span>,equationsSize * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memset</span>(vis[i],<span class="number">0</span>,equationsSize * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> dp[<span class="number">1000</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">double</span> * res = (<span class="keyword">double</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>) * queriesSize);</span><br><span class="line"> pstr[pos] = equations[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"> str[pos] = pos;</span><br><span class="line"> pos++;</span><br><span class="line"> </span><br><span class="line"> pstr[pos] = equations[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"> str[pos] = pos;</span><br><span class="line"> pos++; </span><br><span class="line"> </span><br><span class="line"> dpf[<span class="number">0</span>][<span class="number">1</span>] = values[<span class="number">0</span>];</span><br><span class="line"> dpf[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1.0</span>/values[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line"> dpfok[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> dpfok[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">          </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt; equationsSize; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> e[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; pos; k++) &#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(equations[i][j],pstr[k]) == <span class="number">0</span>) &#123;</span><br><span class="line">e[j] =  str[k];</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == pos) &#123;</span><br><span class="line">pstr[pos] = equations[i][j];</span><br><span class="line">str[pos] = pos;</span><br><span class="line">e[j] = pos;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">    dpf[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = values[i];</span><br><span class="line">    dpf[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">1.0</span>/values[i];</span><br><span class="line">    dpfok[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    dpfok[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; queriesSize; i++) &#123;</span><br><span class="line"> <span class="keyword">int</span> e[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123; </span><br><span class="line">             <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; pos; k++) &#123;</span><br><span class="line">               </span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(queries[i][j],pstr[k]) == <span class="number">0</span>) &#123;</span><br><span class="line">e[j] =  str[k];</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br><span class="line">            dp[i][j] = e[j];</span><br><span class="line"><span class="keyword">if</span> (k == pos) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 将字符串转换为数组，上面都是c语言处理字符串额外做的工作，下面是代码逻辑</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++) &#123;</span><br><span class="line">  dpf[i][i] = <span class="number">1.0</span>;</span><br><span class="line">  dpfok[i][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; queriesSize; i++) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(dp[i][<span class="number">0</span>] == <span class="number">-1</span> || dp[i][<span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">              res[i] = <span class="number">-1.0</span>;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">  res[i] = DFS(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>],pos,dpf,dpfok,vis);  </span><br><span class="line">  &#125;</span><br><span class="line">  *returnSize = queriesSize;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://leetcode-cn.com/problems/evaluate-division/solution/gou-zao-tu-dfsdai-ma-bi-jiao-chang-dan-shi-ji-bai-/" target="_blank" rel="noopener">构造图，DFS，代码比较长，但是击败100%用户</a></li><li><a href="https://leetcode-cn.com/problems/evaluate-division/solution/chun-cyu-yan-dfswan-quan-shi-zai-jie-jue-cyu-yan-d/" target="_blank" rel="noopener">纯C语言，DFS，完全是在解决C语言对字符串操作</a></li></ul>]]></content>
    
    <summary type="html">
    
      Leetcode刷题系列.
    
    </summary>
    
      <category term="Leetcode TOP 100" scheme="http://datacruiser.io/categories/Leetcode-TOP-100/"/>
    
      <category term="LeetCode" scheme="http://datacruiser.io/categories/LeetCode/"/>
    
    
      <category term="数据结构" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://datacruiser.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C语言" scheme="http://datacruiser.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Java语言" scheme="http://datacruiser.io/tags/Java%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++语言" scheme="http://datacruiser.io/tags/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="并查集" scheme="http://datacruiser.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图" scheme="http://datacruiser.io/tags/%E5%9B%BE/"/>
    
      <category term="DFS" scheme="http://datacruiser.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>如何用Go打造区块链（2）—工作证明机制（PoW）</title>
    <link href="http://datacruiser.io/2019/10/28/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%882%EF%BC%89%E2%80%94%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E%E6%9C%BA%E5%88%B6%EF%BC%88PoW%EF%BC%89/"/>
    <id>http://datacruiser.io/2019/10/28/如何用Go打造区块链（2）—工作证明机制（PoW）/</id>
    <published>2019-10-28T20:22:28.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在<a href="http://datacruiser.io/2019/10/28/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%881%EF%BC%89%E2%80%94%E5%9F%BA%E7%A1%80%E5%8E%9F%E5%9E%8B/">如何用Go打造区块链（1）—基础原型</a>当中我们构建了一个简单的但却是区块链数据库的核心的数据结构。同时，我们也实现了向该数据库当中添加链式关系（chain-like relation）区块的方法：每一个区块都链接到它的前一个区块。令人遗憾的是，我们所实现的区块链有一个致命缺陷：添加新的区块太容易，成本也太低。区块和比特币的重要基本特征之一就是添加新的区块是一项非常难的工作。今天我们将处理完善这个缺陷。</p><h1 id="工作证明（Proof-of-Work）"><a href="#工作证明（Proof-of-Work）" class="headerlink" title="工作证明（Proof-of-Work）"></a>工作证明（Proof-of-Work）</h1><p>区块链的重要设想就是如果你要往里面添加新的区块就要完成一些艰难的工作。而正是这种机制确保了区块链的安全和数据的一致性。同时，给这些艰难的工作适当的奖励（这也是人们挖矿获取比特币的机制）。</p><p>这种机制与现实非常类似：一个人必须通过努力工作获得回报以维持生计。在区块链当中，网络上的参与者（矿工）的工作维持网络的正常运行，向区块链中加入新的区块，并因为他们的努力工作而获得回报。他们的工作结果是将一个个区块以安全的方式连成一个完整的区块链，这也维护了整个区块链数据库的稳定性。更有价值的是，谁完成了工作必须进行自我证明。</p><p>这一整个的“努力工作并证明”的机制被称为“工作证明”（PoW）。它难在需要大量的计算资源：即便是高性能的计算机，也无法快速完成工作。甚至，为了保证新的区块增加速度维持在每10分钟一个，这个计算工作会越来越繁重。在比特币当中，计算工作的目的是为了给区块找一个匹配的并满足一些特定要求的哈希值。同时这个哈希值也为工作服务。因此，实际的工作就是寻找证明。</p><p>最后一点需要注意的，PoW算法必须满足一项要求：虽然计算很困难，但是工作证明的验证要非常容易。因为证明通常会传给网络上的其他参与者进行，不应该消耗他们的太多时间了验证这个证明。</p><h1 id="哈希计算（Hashing）"><a href="#哈希计算（Hashing）" class="headerlink" title="哈希计算（Hashing）"></a>哈希计算（Hashing）</h1><p>在这一段当中，我们将讨论下哈希值及其计算。如果你对这一概念已经熟悉，可以跳过这部分内容。</p><p>哈希计算是取得特定数据对应的哈希值的过程。对于计算出来的哈希值可以作为相应数据的特定代表。哈希函数是针对任意大小的数据产生固定长度的哈希值。哈希的主要特征如下：</p><ul><li>元数据无法通过哈希恢复。这样，哈希本身并不是加密的过程。</li><li>特定数据只能有唯一的哈希值，哈希值是独一无二的。</li><li>即便只是修改输入数据的一个字节，也会导致完全不同的哈希值。</li></ul><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain/hash.jpg" alt=""></p><p>哈希函数被广泛应用于检验数据的一致性。一些软件提供商除了软件包以外会额外发布软件包对应的哈希检验值。在你下载了软件包以后可以将其代入一个哈希函数看生成的哈希值与软件商所提供的是否一致。</p><p>在区块链当中，哈希过程被用于确保一个区块的一致性。哈希算法的输入数据包含前一个区块的哈希值，使得修改区块链当中的区块变得不太可能（至少，非常困难），因为修改便意味着你必须计算该区块以及其之后所有区块的哈希值，而这个计算工作量是非常之大的。</p><h1 id="Hashcash算法"><a href="#Hashcash算法" class="headerlink" title="Hashcash算法"></a>Hashcash算法</h1><p>关于哈希值的计算，比特币采用<a href="https://en.wikipedia.org/wiki/Hashcash" target="_blank" rel="noopener">Hashcash算法</a>，一种最早用于垃圾邮件过滤的带PoW机制的算法。它可以分解为以下的几个步骤：</p><ul><li>采用一些公开数据（在邮件过滤当中，比如接收者的邮箱地址；在比特币当中，区块头部数据）</li><li>给它加一个计数器（counter）。计数器从0开始计数</li><li>将公开数据和计数器组合在一起（Data + counter），并获取组合数据的哈希值</li><li>检验获得的哈希值是否满足特定的要求<ul><li>如果满足，则计算结束</li><li>如果不满足，计数器加1并重复步骤3、4</li></ul></li></ul><p>显然，这是一个暴力求解算法：改变计数器计算新的哈希值，检验，递增计数器，再计算一个哈希值，周而复始。这是其计算开销高昂的原因所在。</p><p>现在我们从头细看一个哈希值需要满足的具体要求。在<a href="https://en.wikipedia.org/wiki/Hashcash" target="_blank" rel="noopener">Hashcash算法</a>的原始实现当中，对哈希值的要求是“前20位必须为0”。在比特币当中，要求随时间变化有所调整，因为，根据设计，必须每10分钟产生一个区块，不管算力如何增加并有越来越多的矿工加入网络当中。</p><p>为了证明这个算法，我以前面例子当中的数据（“I like donuts”）为例并产生前面三个字节为0开头的哈希值：</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/blockchain/hash2.jpg" alt=""></p><p>ca07ca是计数器的十六进制数，对应的十进制数为13240266。</p><h1 id="实现（Implementation）"><a href="#实现（Implementation）" class="headerlink" title="实现（Implementation）"></a>实现（Implementation）</h1><p>好了，理论部门已经清晰明了，让我们开始写代码吧。首先，让我们来设置下挖矿（区块产生）的难度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetBits = <span class="number">24</span></span><br></pre></td></tr></table></figure><p>在比特币当中，“目标位数”（targetBits）是存储在区块头部数据用以指示挖矿难度的指标。目前，我们并不打算实现难度可调的算法。因此，我们可以将难度系数定义为一个全局常量。</p><p>24是一个任意的数字，我们的目的是有一个数在内存中所占的存储空间在256位以下。并且这个差异值能够让我们明显感受到挖矿的难度，但不必太大，因为差异值设置的越大，将越难去找一个合适的哈希值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ProofOfWork <span class="keyword">struct</span> &#123;</span><br><span class="line">block  *Block</span><br><span class="line">target *big.Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofOfWork</span><span class="params">(b *Block)</span> *<span class="title">ProofOfWork</span></span> &#123;</span><br><span class="line">target := big.NewInt(<span class="number">1</span>)</span><br><span class="line">target.Lsh(target, <span class="keyword">uint</span>(<span class="number">256</span>-targetBits))</span><br><span class="line"></span><br><span class="line">pow := &amp;ProofOfWork&#123;b, target&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了 <code>ProofOfWork</code> 结构体来保存一个区块的指针和一个目标（target）的指针。这里的“target”与我们之前讨论的对哈希值的要求等同。我们之所以用Big整型来定义“target”在于我们将哈希值与目标比较的方式。我们将一个哈希值转换为一个<code>Big</code>整型然后检验其是否小于目标值。</p><p>然后在<code>NewProofOfWork</code>函数当中，我们初始化了一个<code>Big</code>整型数据为1并将其赋值给<code>target</code>随后将其左移（二进制的位操作）（256-targetBits）位。256是<code>SHA-256</code>哈希值的总体位数，在本文当中<code>targetBits</code>是24，因此这里总共左移了232位。后面我们也将采用<code>SHA-256</code>算法来产生哈希值。计算后的<code>target</code>的十六进制表示如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x10000000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><p>在内存当中占据29个字节空间，下面是将其与我们之前例子中产生的哈希值的直观比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0f</span>ac49161af82ed938add1d8725835cc123a1a87b1b196488360e58d4bfb51e3</span><br><span class="line"><span class="number">0000010000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="number">0000008</span>b0f41ec78bab747864db66bcb9fb89920ee75f43fdaaeb5544f7f76ca</span><br></pre></td></tr></table></figure><p>第一个哈希（基于“I like donuts”计算）比<code>target</code>大，不是一个有效的工作证明。第二个哈希（基于“I like donutsca07ca”）比<code>target</code>小，是一个有效的证明。</p><p>你可以将<code>target</code>理解成一个范围的上边界：假如一个数（一个哈希值）比这个边界小，有效，反之，则无效。减小边界的数值，会导致更少的有效数字的个数，这样得到一个有效哈希值的难度将加大。</p><p>现在，我们来准备需要计算哈希值的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span> <span class="title">prepareData</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">data := bytes.Join(</span><br><span class="line">[][]<span class="keyword">byte</span>&#123;</span><br><span class="line">pow.block.PrevBlockHash,</span><br><span class="line">pow.block.Data,</span><br><span class="line">IntToHex(pow.block.Timestamp),</span><br><span class="line">IntToHex(<span class="keyword">int64</span>(targetBits)),</span><br><span class="line">IntToHex(<span class="keyword">int64</span>(nonce)),</span><br><span class="line">&#125;,</span><br><span class="line">[]<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的 <code>prepareData</code> 方法（因为在<code>prepareData</code>之前有<code>ProofOfWork</code>的结构体声明，这样的一种特殊的函数在Go语言当中叫做<code>method</code>）比较简单明了：我们通过调用<code>bytes</code>包的<code>Join</code>函数将区块信息与<code>targetBits</code>（在比特币当中，难度系数也是属于区块头部数据，这里也把它当做公开数据的一部分）以及<code>nonce（临时值）</code>相合并。<strong>nonce</strong>变量在这里就是前面<a href="https://en.wikipedia.org/wiki/Hashcash" target="_blank" rel="noopener">Hashcash算法</a>中描述的<code>counter</code>（计数器），它是一个密码学术语。<br>OK，所有的准备已经就绪，来让我们实现<code>PoW</code>算法的核心部分吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span> <span class="title">Run</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> hashInt big.Int</span><br><span class="line"><span class="keyword">var</span> hash [<span class="number">32</span>]<span class="keyword">byte</span></span><br><span class="line">nonce := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Mining the block containing \"%s\"\n"</span>, pow.block.Data)</span><br><span class="line"><span class="keyword">for</span> nonce &lt; maxNonce &#123;</span><br><span class="line">data := pow.prepareData(nonce)</span><br><span class="line">hash = sha256.Sum256(data)</span><br><span class="line">fmt.Printf(<span class="string">"\r%x"</span>, hash)</span><br><span class="line">hashInt.SetBytes(hash[:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hashInt.Cmp(pow.target) == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nonce++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nonce, hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们初始化了几个变量：<code>hashInt</code> 是 <code>hash</code> 的整数型代表；<code>nonce</code> 是计数器。接下来我们开始一个循环：循环次数由 <code>maxNonce</code> 来控制，<code>maxNonce</code>等同于<code>math.MaxIn64</code>；这样是为了避免 <code>nonce</code> 的溢出。虽然我们所设置的难度想溢出还是比较困难的，以防万一，最好还是这样设置一下。</p><p>在这个循环体内，我们主要做了以下几件事情：</p><ul><li>准备数据</li><li>用<code>SHA-256</code>算法计算该数据的哈希值</li><li>将哈希值转换成<code>Big</code>整型数据</li><li>将转换后的哈希值与<code>target</code>进行比较</li></ul><p>像之前解释的一样简单。现在我们可以删除 <code>Block</code> 结构体的 <code>SetHash</code>方法然后修改<code>NewBlock</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="keyword">string</span>, prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">block := &amp;Block&#123;time.Now().Unix(), []<span class="keyword">byte</span>(data), prevBlockHash, []<span class="keyword">byte</span>&#123;&#125;, <span class="number">0</span>&#125;</span><br><span class="line">pow := NewProofOfWork(block)</span><br><span class="line">nonce, hash := pow.Run()</span><br><span class="line"></span><br><span class="line">block.Hash = hash[:]</span><br><span class="line">block.Nonce = nonce</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此你可以看到 <code>nonce</code> 存储为<code>Block</code> 的一部分。这是很有必要的，因为 <code>nonce</code>要用于工作证明的验证。同时 <code>Block</code> 结构体也按照以下代码进行修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">Timestamp     <span class="keyword">int64</span></span><br><span class="line">Data          []<span class="keyword">byte</span></span><br><span class="line">PrevBlockHash []<span class="keyword">byte</span></span><br><span class="line">Hash          []<span class="keyword">byte</span></span><br><span class="line">Nonce         <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，让我运行下程序看看是不是一切工作正常。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Mining the block containing <span class="string">"Genesis Block"</span></span><br><span class="line"><span class="number">00000041662</span>c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1</span><br><span class="line"></span><br><span class="line">Mining the block containing <span class="string">"Send 1 BTC to Ivan"</span></span><br><span class="line"><span class="number">00000077</span>a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804</span><br><span class="line"></span><br><span class="line">Mining the block containing <span class="string">"Send 2 more BTC to Ivan"</span></span><br><span class="line"><span class="number">000000</span>b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe</span><br><span class="line"></span><br><span class="line">Prev. hash:</span><br><span class="line">Data: Genesis Block</span><br><span class="line">Hash: <span class="number">00000041662</span>c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1</span><br><span class="line"></span><br><span class="line">Prev. hash: <span class="number">00000041662</span>c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1</span><br><span class="line">Data: Send <span class="number">1</span> BTC to Ivan</span><br><span class="line">Hash: <span class="number">00000077</span>a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804</span><br><span class="line"></span><br><span class="line">Prev. hash: <span class="number">00000077</span>a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804</span><br><span class="line">Data: Send <span class="number">2</span> more BTC to Ivan</span><br><span class="line">Hash: <span class="number">000000</span>b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe</span><br></pre></td></tr></table></figure><p>(＾－＾)V 现在可以可以看到每一个哈希值以三个字节的0值开头，而且需要花一点时间才能获得这些哈希值。</p><p>还剩下一件事情需要完成：让我们来实现工作证明的验证。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span> <span class="title">Validate</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> hashInt big.Int</span><br><span class="line"></span><br><span class="line">data := pow.prepareData(pow.block.Nonce)</span><br><span class="line">hash := sha256.Sum256(data)</span><br><span class="line">hashInt.SetBytes(hash[:])</span><br><span class="line"></span><br><span class="line">isValid := hashInt.Cmp(pow.target) == <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isValid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也是我们需要将 <code>nonce</code> 保存下来的原因。</p><p>让我们再来测试一下一切是否正常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, block := <span class="keyword">range</span> bc.blocks &#123;</span><br><span class="line">...</span><br><span class="line">pow := NewProofOfWork(block)</span><br><span class="line">fmt.Printf(<span class="string">"PoW: %s\n"</span>, strconv.FormatBool(pow.Validate()))</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">Prev. hash:</span><br><span class="line">Data: Genesis Block</span><br><span class="line">Hash: <span class="number">00000093253</span>acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038</span><br><span class="line">PoW: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Prev. hash: <span class="number">00000093253</span>acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038</span><br><span class="line">Data: Send <span class="number">1</span> BTC to Ivan</span><br><span class="line">Hash: <span class="number">0000003</span>eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b</span><br><span class="line">PoW: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Prev. hash: <span class="number">0000003</span>eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b</span><br><span class="line">Data: Send <span class="number">2</span> more BTC to Ivan</span><br><span class="line">Hash: <span class="number">000000e42</span>afddf57a3daa11b43b2e0923f23e894f96d1f24bfd9b8d2d494c57a</span><br><span class="line">PoW: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们的区块链离它的实际架构又近了一步：往区块链里面增加区块需要复杂的计算工作，这样挖矿变得可能。然后它依然缺少一些关键的特性：区块链数据库无法持续存在，程序完成后数据就丢失了，也没有钱包、地址、交易记录、共识机制（consensus mechanism）。所有这些特性将会在后面的文章中实现，然后现在，先让我们快乐的挖矿吧！</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul><li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_2" target="_blank" rel="noopener">Full source codes</a></li><li><a href="https://en.bitcoin.it/wiki/Block_hashing_algorithm" target="_blank" rel="noopener">Blockchain hashing algorithm</a></li><li><a href="https://en.bitcoin.it/wiki/Proof_of_work" target="_blank" rel="noopener">Proof of work</a></li><li><a href="https://en.bitcoin.it/wiki/Hashcash" target="_blank" rel="noopener">Hashcash</a></li></ul>]]></content>
    
    <summary type="html">
    
      由于众所周知的原因，最近区块链又一次被推到了风口，下面转发几篇两年前翻译的首发于知乎关于如何用Go语言打造区块链的文章。Go语言是由google开发并于2009年发布的一种静态、强类型、编译型、并发型，并具有垃圾回收（GC）功能的编程语言，特别适用于分布式网络系统开发，而区块链（blockchain）本质上是一本在网络上分布存储的账本，这两者具有天然的匹配性，目前火热的[Ethereum Project](https://ethereum.org/)就是用go原生实现的。这一系列的文章是由[Ivan Kuznetsov](https://jeiwan.net/)所写，本人觉得是一个结合Go语言学习区块链技术的好资料，后面将用自己的语言翻译一遍，从第一篇开始，顺便对Go语言以及区块链有一个初步的认识。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="分布式" scheme="http://datacruiser.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="go" scheme="http://datacruiser.io/tags/go/"/>
    
      <category term="hash" scheme="http://datacruiser.io/tags/hash/"/>
    
      <category term="工作证明" scheme="http://datacruiser.io/tags/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/"/>
    
      <category term="交易" scheme="http://datacruiser.io/tags/%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>如何用Go打造区块链（1）—基础原型</title>
    <link href="http://datacruiser.io/2019/10/28/%E5%A6%82%E4%BD%95%E7%94%A8Go%E6%89%93%E9%80%A0%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%881%EF%BC%89%E2%80%94%E5%9F%BA%E7%A1%80%E5%8E%9F%E5%9E%8B/"/>
    <id>http://datacruiser.io/2019/10/28/如何用Go打造区块链（1）—基础原型/</id>
    <published>2019-10-28T11:13:22.000Z</published>
    <updated>2020-01-31T14:37:28.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>区块链（blockchain）是21世纪最具革命性的技术之一，正在不断地变得更为成熟，潜力无限。本质上，区块链只是一个分布式记录账本的数据库。其独特性在于它不是一个私有的数据库，而是一个公共数据库。它的每一个使用者都拥有它的全部或者部分，并且当且仅当数据库的多数持有者达成一致意见时才能够加进去新的数据记录。正是这样的原因，区块链使得加密货币和智能合约变得可能。</p><p>在这一系列的文章当中，我们将基于区块链的简单实现构建一个简化版的加密货币。</p><h1 id="区块（Block）"><a href="#区块（Block）" class="headerlink" title="区块（Block）"></a>区块（Block）</h1><p>让我们从区块链中的区块开始。区块链中的区块存储着有价值的信息。举个例子，比特币的区块存储对于任何加密货币都是核心的交易记录。除此之外，一个区块还包含一些技术信息，比如它的版本号，当前的时间戳以及上一个区块的哈希值（hash）。</p><p>在这篇文章当中我们并不打算去实现区块链或者比特币规范所定义的区块，而是一个简化版本的区块，它只包含最重要的核心信息。差不多是这个样子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">Timestamp     <span class="keyword">int64</span></span><br><span class="line">Data          []<span class="keyword">byte</span></span><br><span class="line">PrevBlockHash []<span class="keyword">byte</span></span><br><span class="line">Hash          []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Timestamp</code>是当前的时间戳（即区块被创建的时间）</li><li><code>Data</code>是区块中实际包含的有用信息</li><li><code>PrevBlockHash</code>存储着前一个区块的哈希值</li><li><code>Hash</code>是当前区块的哈希值</li></ul><p>在比特币规范当中，<code>Timestamp</code>，<code>PrevBlockHash</code>，<code>Hash</code>是区块头部数据（block headers），自成一个单独的数据结构，而交易记录（Transactions，在我们这个版本当中就是Data）构成另外一个单独的数据结构。为了简化，这里我们将两者混合到一个数据结构当中。</p><p>接下来我们如何计算哈希值？哈希值如何计算是区块链的重要特性，也正是这一特性让区块链确保安全。哈希值在计算上是一个非常困难的操作，即便是非常快的计算机也需要一些时间（这也是人们为什么购买计算能力更强的GPU来挖矿的原因）。这是人为有意的设计，目的是让在区块链当中增加新的区块变得更难，以确保一旦有新的区块成功加入便很难被篡改。在后面的文章当中我们会讨论并实现这一机制。</p><p>现在我们只需要将区块中的各个值关联起来，然后据此计算一个<a href="https://zh.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener">SHA-256哈希</a>。让我们在<code>SetHash()</code>函数中实现哈希值的计算，<code>SetHash()</code>会调用<code>bytes</code>包和<code>sha256</code>包中的函数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">SetHash</span><span class="params">()</span></span> &#123;</span><br><span class="line">timestamp := []<span class="keyword">byte</span>(strconv.FormatInt(b.Timestamp, <span class="number">10</span>))</span><br><span class="line">headers := bytes.Join([][]<span class="keyword">byte</span>&#123;b.PrevBlockHash, b.Data, timestamp&#125;, []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">hash := sha256.Sum256(headers)</span><br><span class="line"></span><br><span class="line">b.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后按照Go语言的惯例，实现一个简化创建区块的函数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="keyword">string</span>, prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">block := &amp;Block&#123;time.Now().Unix(), []<span class="keyword">byte</span>(data), prevBlockHash, []<span class="keyword">byte</span>&#123;&#125;&#125;</span><br><span class="line">block.SetHash()</span><br><span class="line"><span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后区块部分的代码就完成了！</p><h1 id="区块链（Blockchain）"><a href="#区块链（Blockchain）" class="headerlink" title="区块链（Blockchain）"></a>区块链（Blockchain）</h1><p>现在让我们来实现一个区块链。本质上，区块链是带有特定数据结构的数据库：它是一个有序的、反向链接的列表（back-linked list）。这意味着区块是按照插入的顺利存储的，并且每个区块都链接到前面一个区块。这种结构允许快速地获取最新的区块，也可以非常高效地通过哈希值获得其对应的区块。</p><p>在Go语言中这种结构可以通过数组（Array）和图（Map）来实现：数据用来存储有序哈希（在Go语言中数组是有序的）；然后图来存储哈希（hash） [公式] 区块（block）对（图是无序的数据结构）。不过就我们目前的区块链原型当中，只使用数组就可以了，因为暂时还不需要通过哈希来获取区块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Blockchain <span class="keyword">struct</span> &#123;</span><br><span class="line">blocks []*Block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们的第一个区块链！我从来没有想到过原来这么简单！</p><p>现在要考虑往区块链里面添加区块了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">AddBlock</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">prevBlock := bc.blocks[<span class="built_in">len</span>(bc.blocks)<span class="number">-1</span>]</span><br><span class="line">newBlock := NewBlock(data, prevBlock.Hash)</span><br><span class="line">bc.blocks = <span class="built_in">append</span>(bc.blocks, newBlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样了吗？还是。。。？</p><p>显然，要增加一个区块需要一个已经存在的区块，但是目前我们的区块链里面还没有区块！因此，在任何区块链，必须至少有一个区块，并且这个最先在这个链中的区块被称为“创始块”（Genesis Block）。来让我们实现创建创始块的方法吧。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGenesisBlock</span><span class="params">()</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewBlock(<span class="string">"Genesis Block"</span>, []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们来实现一个用创始块创建一个区块链的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockchain</span><span class="params">()</span> *<span class="title">Blockchain</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Blockchain&#123;[]*Block&#123;NewGenesisBlock()&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们测试一下这个区块链能否正常工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bc := NewBlockchain()</span><br><span class="line"></span><br><span class="line">bc.AddBlock(<span class="string">"Send 1 BTC to Ivan"</span>)</span><br><span class="line">bc.AddBlock(<span class="string">"Send 2 more BTC to Ivan"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, block := <span class="keyword">range</span> bc.blocks &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Prev. hash: %x\n"</span>, block.PrevBlockHash)</span><br><span class="line">fmt.Printf(<span class="string">"Data: %s\n"</span>, block.Data)</span><br><span class="line">fmt.Printf(<span class="string">"Hash: %x\n"</span>, block.Hash)</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Prev. hash:</span><br><span class="line">Data: Genesis Block</span><br><span class="line">Hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168</span><br><span class="line"></span><br><span class="line">Prev. hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168</span><br><span class="line">Data: Send <span class="number">1</span> BTC to Ivan</span><br><span class="line">Hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1</span><br><span class="line"></span><br><span class="line">Prev. hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1</span><br><span class="line">Data: Send <span class="number">2</span> more BTC to Ivan</span><br><span class="line">Hash: <span class="number">561237522</span>bb7fcfbccbc6fe0e98bbbde7427ffe01c6fb223f7562288ca2295d1</span><br></pre></td></tr></table></figure><p>完全正确。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们创建了一个极简的区块链原型：它只不过是一个由区块构成的数组，每个区块都链接指向上一个区块。当然，真正的区块链远比这个复杂的多。在我们的区块链里面添加一个区块又快又容易，然后在实际的区块链当中添加一个区块着实需要一些工作：在获得增加区块的允许之前要做很繁重的计算才行（这个机制被称之为“工作证明机制”，即“Proof-of-Work”，POW）。并且，区块链是一个没有单一决策者的分布式数据库。因此，任何一个区块被加入之前都需要得到网络中其他的参与和的确认和批准（这个机制被称之为“共识机制”，即“Consenus”），还有，在我们的区块链里面还没有任何交易记录呢！</p><p>在后面的文章里面，我们将进一步实现上述缺失的特性。</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul><li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_1" target="_blank" rel="noopener">Full source codes</a> </li><li><a href="https://en.bitcoin.it/wiki/Block_hashing_algorithm" target="_blank" rel="noopener">Block hashing algorithm</a></li></ul>]]></content>
    
    <summary type="html">
    
      由于众所周知的原因，最近区块链又一次被推到了风口，下面转发几篇两年前翻译的首发于知乎关于如何用Go语言打造区块链的文章。Go语言是由google开发并于2009年发布的一种静态、强类型、编译型、并发型，并具有垃圾回收（GC）功能的编程语言，特别适用于分布式网络系统开发，而区块链（blockchain）本质上是一本在网络上分布存储的账本，这两者具有天然的匹配性，目前火热的[Ethereum Project](https://ethereum.org/)就是用go原生实现的。这一系列的文章是由[Ivan Kuznetsov](https://jeiwan.net/)所写，本人觉得是一个结合Go语言学习区块链技术的好资料，后面将用自己的语言翻译一遍，从第一篇开始，顺便对Go语言以及区块链有一个初步的认识。
    
    </summary>
    
      <category term="区块链" scheme="http://datacruiser.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="分布式" scheme="http://datacruiser.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="go" scheme="http://datacruiser.io/tags/go/"/>
    
      <category term="hash" scheme="http://datacruiser.io/tags/hash/"/>
    
      <category term="工作证明" scheme="http://datacruiser.io/tags/%E5%B7%A5%E4%BD%9C%E8%AF%81%E6%98%8E/"/>
    
      <category term="交易" scheme="http://datacruiser.io/tags/%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-279. 完全平方数</title>
    <link href="http://datacruiser.io/2019/10/27/Leetcode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>http://datacruiser.io/2019/10/27/Leetcode-279-完全平方数/</id>
    <published>2019-10-27T18:08:01.000Z</published>
    <updated>2020-01-31T14:37:28.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定正整数 n，找到若干个完全平方数（比如<code>1, 4, 9, 16, ...</code>）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4.</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">13</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9.</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/perfect-squares" target="_blank" rel="noopener">279. Perfect Squares</a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题和之前的<a href="http://datacruiser.io/2019/10/24/Leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/">322. 零钱兑换</a>这道题神似，可以将完全平方数当作各种可能用来组合的零钱，利用动态规划进行求解应该也是常规方法。不过本题的考察点除此之外，也是另有玄机的。比如<a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">四平方和定理</a>。</p><h2 id="数学思路"><a href="#数学思路" class="headerlink" title="数学思路"></a>数学思路</h2><p>说实话，第一次听说这个定理，这个定理主要是说<strong>每个正整数均可表示为4个整数的平方和</strong>，其实是可以表示为4个以内的平方数之和，那么就是说返回结果只有 1,2,3 或4其中的一个。</p><p>首先我们将数字简化一下，由于一个数如果含有因子4，那么我们可以把4都去掉，这样并不会影响结果，比如将8变成2，个数都是2，把12变成3，个数都是3，返回的结果都相同。另外一个可以化简的地方就是如果一个数除以8余7的话，那么肯定是由4个完全平方数组成，具体俺也不会证明。</p><p>接下来尝试将其拆分为两个平方数之和，如果拆成功了那么就会返回1或者2，因为其中一个平方数可能为0。</p><p>具体的代码实现请见解法一。</p><p>注意下面的 <code>!!a + !!b</code> 这个表达式，可能很多人不太理解这个的意思，其实很简单，感叹号!表示逻辑取反，那么一个正整数逻辑取反为0，再取反为1，所以用两个感叹号!!的作用就是看a和b是否为正整数，都为正整数的话返回2，只有一个是正整数的话返回1。</p><p>解法一是纯数学的角度，除此之外依然可以用动态规划的解法来做。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="找子问题"><a href="#找子问题" class="headerlink" title="找子问题"></a>找子问题</h3><p>我们建立一个长度为<code>n+1</code>的一维数组<code>dp</code>，其中<code>dp[i]</code>代表到数字<code>i</code>组成最少完全平方个数，如果把<code>dp</code>数组都求解出来了，那么原问题也就迎刃而解了，其值即为<code>dp[n]</code>。</p><h3 id="确定状态"><a href="#确定状态" class="headerlink" title="确定状态"></a>确定状态</h3><p>子问题只和一个变量–数字的位置相关。因此，序列中数的位置<code>i</code>就是<strong>状态</strong>，而状态<code>i</code>对应的值，就是组成正整数<code>n</code>所需要的最少完全平方数的个数。显然，状态一共有<code>n+1</code>个。</p><h3 id="找出状态转移方程"><a href="#找出状态转移方程" class="headerlink" title="找出状态转移方程"></a>找出状态转移方程</h3><p>假设<code>dp[i]=x</code>，则表示组成正整数<code>i</code>的最少完全平方数是<code>x</code>个，我们现在看看<code>dp[i + j * j]</code>会是如何，如果从正整数<code>i + j * j</code>的状态转移到正整数<code>i</code>的状态。 显然，因为要求最小值，<code>dp[i + j * j]</code>是其本身与<code>dp[i] + 1</code>两者之间较小的值，因为<code>i + j * j</code>比起<code>i</code>，起码会多一个完全平方数<code>j</code>。</p><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p><code>dp</code>数组按如下要求进行初始化：</p><ul><li><code>dp[0] = 0</code></li><li>其余初始化为<code>INT_MAX</code></li></ul><p>具体代码见解法二。</p><p>需要注意的是这里的写法，<code>i</code>必须从0开始，到<code>n</code>结束，是[0,n]的闭区间。<code>j</code>必须从1开始，因为我们的初衷是想用 <code>dp[i]</code> 来更新 <code>dp[i + j * j]</code>，如果 i=0, j=0 了，那么 dp[i] 和 dp[i + j * j] 就相等了，怎么能用本身<code>dp</code> 值加1来更新自身。</p><h2 id="BFS广度优先解法"><a href="#BFS广度优先解法" class="headerlink" title="BFS广度优先解法"></a>BFS广度优先解法</h2><p>下面再来看一个BFS的解法，第一次在题解当中抄BFS的解法，首先还是先让自己弄懂，但是在MOOC听了一遍以后就一直懵懵懂懂的状态。</p><p>可以看作从根节点0出发，往下搜索子节点，找到匹配则返回深度即可，相当于最短路径，即BFS广度优先搜索。</p><p>每层节点的子节点分别为父节点加上$(1, 4, 9, 16….(i^2 &lt; n)$ 。使用队列存储节点，每次遍历前先获取当层节点数，即队列长度。然后依次遍历该节点子节点，如果长度符合则返回，不符合且是第一次访问，则添加到队列中去，如果已经访问过，则不需要添加。需要额外的哈希数组，用来存储访问过的元素，队列和哈希数组总共需要额外的2N的空间。搜索图如下：</p><p><img src="https://pic.leetcode-cn.com/fade3888433f7428772b99ebc783a7df63cc26fd23378a3814059eca27a2a8a8-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.png" alt="搜索图"></p><p>具体代码见解法三。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">4</span> == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        n /= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">8</span> ==<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a * a &lt;= n; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">sqrt</span>(n - a * a);</span><br><span class="line">        <span class="keyword">if</span>(a * a + b * b == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> !!a + !!b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i] = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i + j * j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i + j * j] = min(dp[i] + <span class="number">1</span>, dp[i + j * j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BFS */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> length, max;</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">    <span class="keyword">int</span> *sq;</span><br><span class="line">&#125; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">queue</span>* <span class="title">queueCreate</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>* a;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a = (<span class="built_in">queue</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="keyword">if</span> (!a)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        a-&gt;max = k+<span class="number">1</span>;</span><br><span class="line">        a-&gt;length = a-&gt;front = a-&gt;rear = <span class="number">0</span>;</span><br><span class="line">        a-&gt;sq = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (k+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (!a-&gt;sq)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(a);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(<span class="built_in">queue</span>* obj, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;length == (obj-&gt;max - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;sq[obj-&gt;rear] = value;</span><br><span class="line">        obj-&gt;rear = (obj-&gt;rear + <span class="number">1</span>) % obj-&gt;max;</span><br><span class="line">        obj-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deQueue</span><span class="params">(<span class="built_in">queue</span>* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;front == obj-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head= obj-&gt;front;</span><br><span class="line">        obj-&gt;front = (obj-&gt;front + <span class="number">1</span>) % obj-&gt;max;</span><br><span class="line">        obj-&gt;length--;</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;sq[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queueLength</span><span class="params">(<span class="built_in">queue</span> *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(<span class="built_in">queue</span>* obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (obj-&gt;front == obj-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isFull</span><span class="params">(<span class="built_in">queue</span>* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;length == obj-&gt;max - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueFree</span><span class="params">(<span class="built_in">queue</span>* obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;sq);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,next, curr, size, steps = <span class="number">0</span>, *visited;</span><br><span class="line">    <span class="built_in">queue</span> *q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    q = queueCreate(n + <span class="number">1</span>);</span><br><span class="line">    visited = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根节点入队列</span></span><br><span class="line">    enQueue(q, <span class="number">0</span>);</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//深度加一</span></span><br><span class="line">        steps++;</span><br><span class="line">        size = queueLength(q);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历子节点</span></span><br><span class="line">            curr = deQueue(q);</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j * j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                next = curr + j*j;</span><br><span class="line">                <span class="keyword">if</span> (next == n) <span class="keyword">return</span> steps;</span><br><span class="line">                <span class="keyword">if</span> (next &gt; n) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (visited[next]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//加入队列，以待访问其子节点</span></span><br><span class="line">                visited[next] = <span class="number">1</span>;</span><br><span class="line">                enQueue(q, next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queueFree(q);</span><br><span class="line">    <span class="built_in">free</span>(visited);</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/grandyang/p/4800552.html" target="_blank" rel="noopener">[LeetCode] 279. Perfect Squares 完全平方数</a></li><li><a href="https://leetcode-cn.com/problems/perfect-squares/solution/cyu-yan-bfsyan-du-you-xian-jie-fa-tu-jie-by-mrsonk/" target="_blank" rel="noopener">c语言 BFS广度优先解法 图解</a></li></ul>]]></content>
    
    <summary type="html">
    
      Leetcode刷题系列.
    
    </summary>
    
      <category term="Leetcode TOP 100" scheme="http://datacruiser.io/categories/Leetcode-TOP-100/"/>
    
      <category term="LeetCode" scheme="http://datacruiser.io/categories/LeetCode/"/>
    
    
      <category term="数据结构" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://datacruiser.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C语言" scheme="http://datacruiser.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数学" scheme="http://datacruiser.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="动态规划" scheme="http://datacruiser.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="广度优先搜索" scheme="http://datacruiser.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-19.删除链表的倒数第N个节点</title>
    <link href="http://datacruiser.io/2019/10/27/Leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://datacruiser.io/2019/10/27/Leetcode-19-删除链表的倒数第N个节点/</id>
    <published>2019-10-27T08:10:21.000Z</published>
    <updated>2020-01-31T14:37:28.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 n = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 n 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题放在中等难度也是有点说不过去，这里讲两个思路，第一个需要两次遍历，第一次遍历先求出链表的长度<code>len</code>，然后第二次遍历就知道从头再遍历<code>len-n</code>个节点后删除当时遍历到的节点后面的那个节点就可以了。</p><p>这里需要注意的是为了防止<code>Head</code>本身被删除，最好新建一个虚拟节点<code>newHead</code>，然后令<code>newhead-&gt;next=head</code>，最后返回虚拟节点的<code>next</code>。</p><p>具体代码见解法一。</p><p>本题的进阶是减少一次遍历，那么需要设置双指针，且双指针初始都指向新建的虚拟节点<code>newHead</code>，那么让其中一个指针先走<code>n+1</code>个节点，这样快慢指针之间就相差<code>n</code>个节点了，然后同时移动快慢指针，直到快指针指向了<code>NULL</code>，最后将慢指针的下一个节点指向其下下个节点即可。</p><p>具体代码见解法二。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">List</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getListLen</span><span class="params">(List head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">removeNthFromEnd</span><span class="params">(List head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List newHead = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    List tmp = newHead;</span><br><span class="line"></span><br><span class="line">    newHead-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = getListLen(head);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除len-n次遍历后节点的节点</span></span><br><span class="line">    tmp-&gt;next = tmp-&gt;next-&gt;next;</span><br><span class="line">        </span><br><span class="line">    List res = newHead-&gt;next;</span><br><span class="line">    <span class="comment">//free(tmp);</span></span><br><span class="line">    <span class="built_in">free</span>(newHead);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">List</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">removeNthFromEnd</span><span class="params">(List head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List newHead = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    newHead-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    List slow = newHead, fast = newHead;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n + <span class="number">1</span> ; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//List tmp = slow-&gt;next;</span></span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="comment">//free(tmp);</span></span><br><span class="line">    </span><br><span class="line">    List res = newHead-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(newHead);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Leetcode刷题系列.
    
    </summary>
    
      <category term="Leetcode TOP 100" scheme="http://datacruiser.io/categories/Leetcode-TOP-100/"/>
    
      <category term="LeetCode" scheme="http://datacruiser.io/categories/LeetCode/"/>
    
    
      <category term="数据结构" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://datacruiser.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C语言" scheme="http://datacruiser.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="双指针" scheme="http://datacruiser.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="http://datacruiser.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-300. 最长上升子序列</title>
    <link href="http://datacruiser.io/2019/10/25/Leetcode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://datacruiser.io/2019/10/25/Leetcode-300-最长上升子序列/</id>
    <published>2019-10-25T14:39:06.000Z</published>
    <updated>2020-01-31T14:37:28.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p><strong>示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">4</span> </span><br><span class="line">解释: 最长的上升子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，它的长度是 <span class="number">4</span>。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 $O(n^2)$ 。</li></ul><p>进阶: 你能将算法的时间复杂度降低到 $O(n \log n)$ 吗?</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">300. Longest increasing Subsequence</a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>早上在上班通勤的路上正好在看郭炜老师讲动态规划的视频，里面正好也有这道题<a href="https://www.icourse163.org/learn/PKU-1001894005#/learn/content?type=detail&amp;id=1211268468&amp;cid=1213844100" target="_blank" rel="noopener">最长上升子序列</a></p><h2 id="找子问题"><a href="#找子问题" class="headerlink" title="找子问题"></a>找子问题</h2><p>令输入的数组为$A_n$，我们将原问题转化为求以$A_k(k=1,2,3…N)$为终点的最长上升子序列的长度的问题，其中<strong>终点</strong>为该上升子序列最右边的那个数。</p><p>虽然这个子问题和原问题形式上并不完全一致，但是只要这$N$个子问题都解决了，那么这$N$个问题的解当中最大的那个就是整个问题的解。</p><h2 id="确定状态"><a href="#确定状态" class="headerlink" title="确定状态"></a>确定状态</h2><p>子问题只和一个变量–数字的位置相关。因此，序列中数的位置$k$就是<strong>状态</strong>，而状态$k$对应的值，就是以$A_k$作为终点的最长上升子序列的长度。显然，状态一共有$N$个。</p><h2 id="找出状态转移方程"><a href="#找出状态转移方程" class="headerlink" title="找出状态转移方程"></a>找出状态转移方程</h2><p>我们用一个一维数组<code>dp[k]</code>来表示$A_k$作为终点的最长上升子序列的长度, 那么状态转移方程如下:</p><ul><li>初始状态: dp[1] = 1</li><li>转移方程: dp[k] = max{dp[i]: 1 &lt;= i &lt; k, 且 Ai &lt; Ak 且 k 不等于 1} + 1, 如果找不到这样的i, 则dp[k] = 1</li></ul><p><code>dp[k]</code>的值就是在$A_k$左边, 终点数值小于$A_k$，且长度最大的那个上升子序列的长度再加1，因为$A_k$左边任何终点小于$A_k$的子序列，加上$A_k$后就能够形成一个更长的上升子序列。</p><p>上面的原理弄清楚了，代码写起来就比较简单了，除了<code>dp</code>数组，我们还定义一个返回变量<code>res</code>，用这个变量在每次循环的时候保存更新后的<code>dp</code>数组当中的最大值。</p><p>另外，需要特别注意下：在用<code>numsSize</code>作为参量来定义<code>dp</code>数组长度时，一定要提前判断一下是否为0，如果为0则直接返回0。</p><p>我们来总结下动态规划的设计流程：</p><ul><li>首先明确<code>dp</code>数组所存数组的定义，也就是子问题如何定义，这步很重要，如果不得当或者不够清晰，会严重阻碍之后的步骤，这个在郭老师的视频里面也有涉及，一开始定义的子问题就无法进行状态转移方程的推导</li><li>然后根据子问题的定义确定状态，即状态与什么变量相关</li><li>运用数学归纳法的思路，假设<code>dp[0...i-1]</code>都已知的情况下，想办法求出<code>dp[i]</code>，如果<code>dp</code>定义得当，这一步不难，可以找几个例子在纸上画一画先手工推一推。这一步如果完成了，整个题目基本就迎刃而解了</li><li>如果上一步无法完成，可能是 <code>dp</code> 数组的定义不够恰当，需要重新定义 <code>dp</code> 数组的含义；或者可能是 <code>dp</code> 数组存储的信息还不够，不足以推出下一步的答案，需要把 <code>dp</code> 数组扩大成二维数组甚至三维数组</li><li>最后就是要思考一下初始状态下会如何，以此来对<code>dp</code>数组进行初始化，以确保算法能够正确运行</li></ul><p>具体代码见解法一。</p><p>本题的进阶是将算法的时间复杂度降低到$O(n \log n)$，那就需要进一步优化了，上述算法的算法时间复杂度为$O(N^2)$。</p><p>不得不说，对于此题，能想到用二分查找法来进行求解的，不是一般人。</p><p>二分法也有不同的解法，下面介绍其中的两种，第一种来自<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/" target="_blank" rel="noopener">动态规划设计方法&amp;&amp;纸牌游戏讲解二分解法</a>，大家自己看吧，就不再贴图和复述了。</p><p>如果能够看懂作者的讲解下面代码实现应该非常容易，具体请看解法二。</p><p>另外一种也是神仙级的解法，主要思路如下：</p><ul><li>建立一个数组<code>ends</code>，把首元素放进去</li><li>遍历之后的元素，分以下几种情况<ul><li>遍历之后的新元素比<code>ends</code>数组中的首元素小的话，将<code>ends</code>数组的首元素替换为遍历到的新元素</li><li>遍历之后的新元素比<code>ends</code>数组中的末尾元素还大的话，那么将新元素添加到<code>ends</code>数组的末尾，并不覆盖</li><li>如果遍历到的新元素比<code>ends</code>数组中的首元素大、<code>ends</code>数组中的末尾元素小的话，此时用二分查找法，找到第一个不小于此元素的位置并覆盖掉该位置上面原来的数字</li></ul></li><li>遍历完整个<code>nums</code>数组当中的全部元素以后，此时<code>ends</code>数组的长度就是要求的LIS（Longest Increasing Subsequence）的长度，需要特别注意的是，<code>ends</code>数组本身的值并不一定是一个真实的LIS，比如若输入数组<code>nums</code> 为<code>{4, 2， 4， 5， 3， 7}</code>，那么算完后的 <code>ends</code> 数组为<code>{2， 3， 5， 7}</code>，可以发现它不是一个原数组的 LIS，只是长度相等而已，千万要注意这点</li></ul><p>具体代码请看解法三。</p><p>还有一种解法与上述思路类似，主要也是考虑到C语言没有STL可用，用<code>len</code>变量来保存<code>ends</code>数组的长度，在遍历<code>nums</code>数组元素的时候，每次都用二分查找在<code>ends</code>数组的[0,len]区域内搜索新元素的位置，如果新元素的位置正好位于右边界，则<code>len++</code>，最后返回<code>len</code>。</p><p>真是办法总比困难多，没有想不到，只有做不到，有一句话说得好：所有的程序都是人想出来的！</p><p>具体代码见解法四。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//一定要判断</span></span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dp[numsSize];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//memset(dp, 1, (numsSize) * sizeof(int));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res = max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断数组不为空</span></span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> top[numsSize];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 牌堆数初始化为 0</span></span><br><span class="line">    <span class="keyword">int</span> piles = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要处理的扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> poker = nums[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/***** 搜索左侧边界的二分查找 *****/</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = piles;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(top[mid] &gt; poker)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(top[mid] &lt; poker)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*********************************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 没找到合适的牌堆，新建一堆</span></span><br><span class="line">        <span class="keyword">if</span>(left == piles)</span><br><span class="line">            piles++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把这张牌放到牌堆顶</span></span><br><span class="line">        top[left] = poker;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 牌堆数就是 LIS 长度</span></span><br><span class="line">    <span class="keyword">return</span> piles;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ends&#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; ends[<span class="number">0</span>]) ends[<span class="number">0</span>] = a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; ends.back()) ends.push_back(a);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">0</span>, right = ends.size();</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (ends[mid] &lt; a) left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                ends[right] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ends.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ends[numsSize];</span><br><span class="line">    </span><br><span class="line">    ends[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = binarySearch(ends, <span class="number">0</span>, len, nums[i]);</span><br><span class="line">        </span><br><span class="line">        ends[pos] = nums[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pos == len)</span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/grandyang/p/4938187.html" target="_blank" rel="noopener">[LeetCode] 300. Longest Increasing Subsequence 最长递增子序列</a></li><li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/" target="_blank" rel="noopener">动态规划设计方法&amp;&amp;纸牌游戏讲解二分解法</a></li><li>Leetcode他人解法</li></ul>]]></content>
    
    <summary type="html">
    
      Leetcode刷题系列.
    
    </summary>
    
      <category term="Leetcode TOP 100" scheme="http://datacruiser.io/categories/Leetcode-TOP-100/"/>
    
      <category term="LeetCode" scheme="http://datacruiser.io/categories/LeetCode/"/>
    
    
      <category term="数据结构" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://datacruiser.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C语言" scheme="http://datacruiser.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="动态规划" scheme="http://datacruiser.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二分查找" scheme="http://datacruiser.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-322. 零钱兑换</title>
    <link href="http://datacruiser.io/2019/10/24/Leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>http://datacruiser.io/2019/10/24/Leetcode-322-零钱兑换/</id>
    <published>2019-10-24T20:15:14.000Z</published>
    <updated>2020-01-31T14:37:28.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p><strong>示例 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以认为每种硬币的数量是无限的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/coin-change" target="_blank" rel="noopener">322. Coin Change</a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>关于这道题, 这个<a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/" target="_blank" rel="noopener">题解</a>给出了非常详细的描述, 从动态规划的基本思路开始, 一步步怎么从暴力方法到到备忘录的递归再到迭代的动态规划, 深入浅出, 图文并茂, 是不可多得的题解. </p><p>首先来看暴力解法, 最困难得一步, 就是写出状态转移方程, 这个问题的状态转移方程如下:</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/LeetCode_Tencent50/332-%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png" alt=""></p><p>附图来自<a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/" target="_blank" rel="noopener">题解</a>，原作者公众号<code>labuladong</code>，欢迎大家关注。</p><p>其实，这个方程就用到了「最优子结构」性质：<strong>原问题的解由子问题的最优解构成</strong>。即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来。</p><p>具体代码见解法一。</p><p>画出递归树：</p><p><img src="https://machinelearning-1255641038.cos.ap-chengdu.myqcloud.com/Datacruiser_Blog_Sources/LeetCode_Tencent50/322-%E9%80%92%E5%BD%92%E6%A0%91.png" alt=""></p><p>时间复杂度分析：递归的总时间是子问题总数 x 每个子问题的时间。子问题总数为递归树节点个数，这个比较难看出来，是$O(N^k)$，总之是指数级别。每个子问题当中还有一个 for 循环，复杂度为$O(k)$，所以最终依然还是指数级别。</p><p>下面给递归的解法加一个记忆数组，将中间的计算结果进行保存，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。这个思路跟<a href="http://datacruiser.io/2019/10/23/Leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/">Leetcode-139. 单词拆分</a>的解法是类似的。</p><p>如果要加入记忆数组，通常的做法是在主调用函数当中什么记忆数组并进行初始化，然后在递归函数当中加入一个记忆数组的变量，因为最后记忆数组是要返回的，需要以指针或者引用的方式进行传参。</p><p>具体代码见解法二。</p><p>最后再来看看动态规划的解法。</p><p>我们维护一个一维动态数组<code>dp</code>，其中<code>dp[i]</code> 表示钱数为<code>i</code>时的最小硬币数的找零，注意由于数组是从0开始的，所以要多申请一位，数组大小为 <code>amount + 1</code>，这样最终结果就可以保存在 <code>dp[amount]</code>中。</p><p>初始化 <code>dp[0] = 0</code>，因为目标值若为0时，就不需要任何硬币。其他值可以初始化是 <code>amount + 1</code>，因为最小的硬币是1，所以 <code>amount</code> 最多需要 <code>amount</code> 个硬币，<code>amount + 1</code> 也就相当于当前的最大值了，注意这里不能用整型最大值来初始化，因为在后面的状态转移方程有加1的操作，有可能会溢出.</p><p>好，接下来就是要找状态转移方程了。我们先回归例子1，假设我取了一个值为5的硬币，那么由于目标值是 11，所以是不是假如我们知道 <code>dp[6]</code>，那么就知道了组成 11 的<code>dp</code>值了？所以更新 <code>dp[i]</code> 的方法就是遍历每个硬币，如果遍历到的硬币值小于<code>i</code>值（比如不能用值为5的硬币去更新 <code>dp[3]</code>）时，用 <code>dp[i - coins[j]] + 1</code> 来更新 <code>dp[i]</code>，所以状态转移方程为：</p><p>$$dp[i] = min(dp[i], dp[i - coins[j]] + 1)$$</p><p>其中 <code>coins[j]</code> 为第<code>j</code>个硬币，而 <code>i - coins[j]</code> 为钱数<code>i</code>减去其中一个硬币的值，剩余的钱数在 <code>dp</code>数组中找到值，然后加1和当前 <code>dp</code> 数组中的值做比较，取较小的那个更新 <code>dp</code>数组。</p><p>具体代码见解法三。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>* coins, <span class="keyword">int</span> coinsSize, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//金额为0 返回0</span></span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coinsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//金额比当前硬币面额小，换一个硬币</span></span><br><span class="line">        <span class="keyword">if</span> (amount - coins[i] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归调用，去掉当前可用硬币，因为硬皮可重复使用 *coins变量不变</span></span><br><span class="line">        <span class="keyword">int</span> tmp = coinChange(coins, coinsSize, amount - coins[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果子问题无解，换一个硬币</span></span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//利用状态转移方程更新</span></span><br><span class="line">        ans = min(ans, tmp + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChangeSolver</span><span class="params">(<span class="keyword">int</span>* coins, <span class="keyword">int</span> coinsSize, <span class="keyword">int</span> target, <span class="keyword">int</span> *memo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(memo[target] != INT_MAX)</span><br><span class="line">        <span class="keyword">return</span> memo[target];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coinsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//计算子问题的解</span></span><br><span class="line">        <span class="keyword">int</span> tmp = coinChangeSolver(coins, coinsSize, target - coins[i], memo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果子问题有解，更新答案</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= <span class="number">0</span>)</span><br><span class="line">            memo[target] = min(memo[target], tmp + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录并返回本轮答案</span></span><br><span class="line">    <span class="keyword">return</span> memo[target] = (memo[target] == INT_MAX) ? <span class="number">-1</span> : memo[target];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>* coins, <span class="keyword">int</span> coinsSize, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记忆数组初始化为INT_MAX</span></span><br><span class="line">    <span class="keyword">int</span> memo[amount + <span class="number">1</span>];</span><br><span class="line">    memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++)</span><br><span class="line">        memo[i] = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> coinChangeSolver(coins, coinsSize, amount, memo);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>* coins, <span class="keyword">int</span> coinsSize, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dp数组初始化</span></span><br><span class="line">    <span class="keyword">int</span> dp[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++)</span><br><span class="line">        dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coinsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(coins[j] &lt;= i)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (dp[amount] &gt; amount) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/grandyang/p/5138186.html" target="_blank" rel="noopener">[LeetCode] 322. Coin Change 硬币找零</a></li><li><a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/" target="_blank" rel="noopener">动态规划套路详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      Leetcode刷题系列.
    
    </summary>
    
      <category term="Leetcode TOP 100" scheme="http://datacruiser.io/categories/Leetcode-TOP-100/"/>
    
      <category term="LeetCode" scheme="http://datacruiser.io/categories/LeetCode/"/>
    
    
      <category term="数据结构" scheme="http://datacruiser.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://datacruiser.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C语言" scheme="http://datacruiser.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="动态规划" scheme="http://datacruiser.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
